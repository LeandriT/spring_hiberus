# BIAN Payment Initiation - Java Spring Boot Migration Rules

## Context
You are an expert software architect specialized in banking systems with 10+ years in fintech, migrating legacy SOAP services to REST APIs aligned with BIAN (Banking Industry Architecture Network) standards. This project involves migrating a Payment Order SOAP service to a BIAN-compliant REST microservice.

## SOAP to REST Migration Analysis

### Legacy SOAP Service Analysis
**WSDL**: PaymentOrderService.wsdl
**Operations Identified**:
1. **SubmitPaymentOrder** → Maps to BIAN **Initiate** operation
2. **GetPaymentOrderStatus** → Maps to BIAN **Retrieve Status** operation

### SOAP to BIAN Field Mapping

| SOAP Field | BIAN REST Field | Type | Notes |
|------------|-----------------|------|-------|
| externalId | externalReference | string | Client-provided reference |
| debtorIban | debtorAccount.iban | string | Payer account identifier |
| creditorIban | creditorAccount.iban | string | Payee account identifier |
| amount | instructedAmount.amount | decimal | Payment amount |
| currency | instructedAmount.currency | string | ISO 4217 currency code |
| remittanceInfo | remittanceInformation | string | Payment purpose/description |
| requestedExecutionDate | requestedExecutionDate | date | ISO 8601 date format |
| paymentOrderId | paymentOrderReference | string | BIAN-compliant reference (PO-xxxx) |
| status | paymentOrderStatus | enum | SOAP: ACCEPTED, SETTLED, REJECTED<br>BIAN: INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED |
| lastUpdate | lastUpdated | datetime | ISO 8601 datetime format |

### Status Mapping Strategy

```java
// SOAP Legacy Status → BIAN Status
ACCEPTED    → INITIATED
PENDING     → PENDING
PROCESSING  → PROCESSED
SETTLED     → COMPLETED
REJECTED    → FAILED
CANCELLED   → CANCELLED
```

### Key Migration Decisions
1. **externalId** becomes **externalReference** (keeps external system traceability)
2. **IBAN** fields wrapped in account objects for better structure
3. **amount + currency** combined into **instructedAmount** object (ISO 20022 compliant)
4. **paymentOrderId** renamed to **paymentOrderReference** (BIAN naming)
5. Status values normalized to BIAN lifecycle
6. Added missing fields required by BIAN (createdAt, updatedAt)

## Project Specifications
- **BIAN Service Domain**: Payment Initiation
- **Behavior Qualifier**: PaymentOrder
- **Migration**: SOAP (legacy) → REST (BIAN-aligned)
- **Architecture**: Hexagonal (Ports & Adapters)
- **Approach**: Contract-First with OpenAPI 3.0
- **Stack**: Java 17+, Spring Boot 3+, Spring MVC, H2 Database, Gradle, MapStruct

## Core Principles

### 1. BIAN Alignment (Critical)
- **Service Domain Naming**: Always use `payment-initiation` as the base path
- **Behavior Qualifier**: PaymentOrder is the main BQ
- **Resource Naming**: Use BIAN nomenclature
  - Control Record (CR): PaymentOrder instance
  - Use `cr-reference-id` for the main resource identifier
- **Standard Operations**: Follow BIAN service operations
  - `Initiate`: POST to create new payment order
  - `Retrieve`: GET to fetch payment order or status
  - `Update`: PUT/PATCH to modify (if needed)
  - `Execute`: POST to trigger execution (if applicable)

### 2. API Design Patterns

#### Endpoint Structure (Based on Postman Collection)
```
POST   /payment-initiation/payment-orders              # Initiate (was: SubmitPaymentOrder)
GET    /payment-initiation/payment-orders/{id}         # Retrieve (new in BIAN)
GET    /payment-initiation/payment-orders/{id}/status  # Retrieve Status (was: GetPaymentOrderStatus)
```

**Important**: The `{id}` parameter is the **paymentOrderReference** (e.g., "PO-0001"), NOT a UUID.

#### Request/Response Standards (From SOAP Migration)
- Use RFC 7807 (`application/problem+json`) for errors
- Follow BIAN JSON schema conventions aligned with SOAP fields:
  ```json
  {
    "externalReference": "EXT-1",
    "debtorAccount": {
      "iban": "EC12DEBTOR"
    },
    "creditorAccount": {
      "iban": "EC98CREDITOR"
    },
    "instructedAmount": {
      "amount": 150.75,
      "currency": "USD"
    },
    "remittanceInformation": "Factura 001-123",
    "requestedExecutionDate": "2025-10-31",
    "paymentOrderReference": "PO-0001",
    "paymentOrderStatus": "INITIATED"
  }
  ```

#### HTTP Status Codes (BIAN-aligned)
- `201 Created`: Successful Initiate (POST new resource)
- `200 OK`: Successful Retrieve (GET), Update (PUT/PATCH), or Execute
- `204 No Content`: Successful DELETE or operation with no response body
- `400 Bad Request`: Validation errors, malformed request
- `404 Not Found`: Resource not found
- `409 Conflict`: Idempotency violation, business rule conflict
- `422 Unprocessable Entity`: Semantic errors (valid format, invalid business logic)
- `500 Internal Server Error`: System errors, unexpected failures
- `503 Service Unavailable`: Temporary service issues

### 3. Hexagonal Architecture (Mandatory)

#### Package Structure (Updated with SOAP Migration Context)
```
com.hiberus.banking.payment
├── domain/                          # Core business logic (framework-independent)
│   ├── model/
│   │   ├── PaymentOrder.java       # Aggregate root
│   │   ├── Account.java            # Value object (IBAN holder)
│   │   ├── InstructedAmount.java   # Value object (amount + currency)
│   │   ├── PaymentStatus.java      # Enum (BIAN lifecycle)
│   │   ├── ExternalReference.java  # Value object (from SOAP externalId)
│   │   └── PaymentOrderReference.java  # Value object (PO-xxxx format)
│   ├── port/
│   │   ├── in/                     # Input ports (use cases)
│   │   │   ├── InitiatePaymentOrderUseCase.java
│   │   │   ├── RetrievePaymentOrderUseCase.java
│   │   │   └── RetrievePaymentOrderStatusUseCase.java
│   │   └── out/                    # Output ports (repositories, external services)
│   │       ├── PaymentOrderRepository.java
│   │       ├── PaymentValidationPort.java
│   │       └── LegacySoapPort.java  # Optional: for hybrid transition
│   ├── exception/
│   │   ├── PaymentOrderNotFoundException.java
│   │   ├── InvalidPaymentException.java
│   │   ├── DuplicateExternalReferenceException.java
│   │   └── DomainException.java
│   └── service/                    # Domain services
│       ├── PaymentOrderDomainService.java
│       └── StatusMappingService.java  # SOAP → BIAN status mapping
├── application/                     # Application services (orchestration)
│   ├── service/
│   │   ├── InitiatePaymentOrderService.java
│   │   ├── RetrievePaymentOrderService.java
│   │   └── RetrievePaymentOrderStatusService.java
│   └── mapper/
│       ├── PaymentOrderMapper.java              # MapStruct interface
│       └── PaymentOrderMapperImpl.java          # Generated by MapStruct
├── adapter/                         # Adapters (infrastructure)
│   ├── in/
│   │   ├── rest/
│   │   │   ├── PaymentInitiationController.java
│   │   │   ├── dto/               # Generated from OpenAPI
│   │   │   │   ├── InitiatePaymentOrderRequest.java
│   │   │   │   ├── InitiatePaymentOrderResponse.java
│   │   │   │   ├── RetrievePaymentOrderResponse.java
│   │   │   │   ├── PaymentOrderStatusResponse.java
│   │   │   │   ├── AccountDto.java
│   │   │   │   └── InstructedAmountDto.java
│   │   │   └── mapper/
│   │   │       └── PaymentOrderRestMapper.java  # MapStruct for DTO ↔ Domain
│   │   └── config/
│   │       └── OpenApiConfig.java
│   └── out/
│       ├── persistence/
│       │   ├── PaymentOrderRepositoryAdapter.java
│       │   ├── entity/
│       │   │   └── PaymentOrderEntity.java
│       │   ├── jpa/
│       │   │   └── PaymentOrderJpaRepository.java  # Spring Data JPA
│       │   └── mapper/
│       │       └── PaymentOrderPersistenceMapper.java  # MapStruct for Entity ↔ Domain
│       └── legacy/
│           └── SoapClientAdapter.java  # Optional: backward compatibility
└── config/                          # Spring configuration
    ├── WebMvcConfig.java
    ├── JpaConfig.java
    ├── H2ConsoleConfig.java
    └── SecurityConfig.java
```

#### Key Rules
- **Domain Layer**: NEVER import Spring or framework-specific annotations
- **Ports**: Define interfaces in domain layer, implement in adapters
- **Dependencies**: Always point inward (adapter → application → domain)
- **Value Objects**: Immutable, validation in constructor
- **Aggregates**: PaymentOrder is the aggregate root, enforce invariants
- **MapStruct**: Use in application and adapter layers, NEVER in domain

### 4. Contract-First Development (SOAP to REST Migration)

#### OpenAPI Generation with Gradle (Based on SOAP Analysis)
```yaml
# openapi.yaml structure - Migrated from PaymentOrderService.wsdl
openapi: 3.0.3
info:
  title: BIAN Payment Initiation API
  version: 1.0.0
  description: |
    Payment Order management aligned with BIAN Service Domain.
    Migrated from legacy SOAP service (PaymentOrderService.wsdl).
    
    **Migration mapping**:
    - SubmitPaymentOrder (SOAP) → POST /payment-orders (REST Initiate)
    - GetPaymentOrderStatus (SOAP) → GET /payment-orders/{id}/status (REST Retrieve)
    - Added: GET /payment-orders/{id} (Full retrieve - BIAN standard)

servers:
  - url: http://localhost:8080
    description: Local development server

paths:
  /payment-initiation/payment-orders:
    post:
      operationId: initiatePaymentOrder
      tags: [Payment Initiation]
      summary: Initiate a new payment order
      description: |
        Initiates a payment order (BIAN Initiate operation).
        Equivalent to SOAP SubmitPaymentOrder operation.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InitiatePaymentOrderRequest'
            examples:
              standard:
                summary: Standard payment order
                value:
                  externalReference: "EXT-1"
                  debtorAccount:
                    iban: "EC12DEBTOR"
                  creditorAccount:
                    iban: "EC98CREDITOR"
                  instructedAmount:
                    amount: 150.75
                    currency: "USD"
                  remittanceInformation: "Factura 001-123"
                  requestedExecutionDate: "2025-10-31"
      responses:
        '201':
          description: Payment order successfully initiated
          headers:
            Location:
              description: URI of the created payment order
              schema:
                type: string
                example: "/payment-initiation/payment-orders/PO-0001"
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InitiatePaymentOrderResponse'
              examples:
                success:
                  summary: Successful initiation
                  value:
                    paymentOrderReference: "PO-0001"
                    paymentOrderStatus: "INITIATED"
                    externalReference: "EXT-1"
                    debtorAccount:
                      iban: "EC12DEBTOR"
                    creditorAccount:
                      iban: "EC98CREDITOR"
                    instructedAmount:
                      amount: 150.75
                      currency: "USD"
                    createdAt: "2025-10-30T10:00:00Z"
        '400':
          $ref: '#/components/responses/BadRequest'
        '409':
          description: Conflict - Duplicate external reference
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/ProblemDetail'
        '500':
          $ref: '#/components/responses/InternalServerError'
  
  /payment-initiation/payment-orders/{id}:
    get:
      operationId: retrievePaymentOrder
      tags: [Payment Initiation]
      summary: Retrieve complete payment order details
      description: |
        Retrieves full payment order information (BIAN Retrieve operation).
        This is a new endpoint not present in legacy SOAP service.
      parameters:
        - $ref: '#/components/parameters/PaymentOrderId'
      responses:
        '200':
          description: Payment order retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RetrievePaymentOrderResponse'
              examples:
                completed:
                  summary: Completed payment order
                  value:
                    paymentOrderReference: "PO-0001"
                    paymentOrderStatus: "COMPLETED"
                    externalReference: "EXT-1"
                    debtorAccount:
                      iban: "EC12DEBTOR"
                    creditorAccount:
                      iban: "EC98CREDITOR"
                    instructedAmount:
                      amount: 150.75
                      currency: "USD"
                    remittanceInformation: "Factura 001-123"
                    requestedExecutionDate: "2025-10-31"
                    createdAt: "2025-10-30T10:00:00Z"
                    updatedAt: "2025-10-30T16:25:30Z"
        '404':
          $ref: '#/components/responses/NotFound'
  
  /payment-initiation/payment-orders/{id}/status:
    get:
      operationId: retrievePaymentOrderStatus
      tags: [Payment Initiation]
      summary: Retrieve payment order status
      description: |
        Retrieves payment order status (BIAN Retrieve Status).
        Equivalent to SOAP GetPaymentOrderStatus operation.
      parameters:
        - $ref: '#/components/parameters/PaymentOrderId'
      responses:
        '200':
          description: Payment order status retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentOrderStatusResponse'
              examples:
                settled:
                  summary: Settled payment (SOAP: SETTLED → BIAN: COMPLETED)
                  value:
                    paymentOrderReference: "PO-0001"
                    paymentOrderStatus: "COMPLETED"
                    statusReason: "Payment successfully completed"
                    lastUpdated: "2025-10-30T16:25:30Z"
        '404':
          $ref: '#/components/responses/NotFound'

components:
  parameters:
    PaymentOrderId:
      name: id
      in: path
      required: true
      description: Payment Order Reference (format PO-xxxx)
      schema:
        type: string
        pattern: '^PO-[0-9]{4,}
```yaml
# openapi.yaml structure
openapi: 3.0.3
info:
  title: BIAN Payment Initiation API
  version: 1.0.0
  description: Payment Order management aligned with BIAN Service Domain

servers:
  - url: http://localhost:8080
    description: Local development server

paths:
  /payment-initiation/payment-orders:
    post:
      operationId: initiatePaymentOrder
      tags: [Payment Initiation]
      summary: Initiate a new payment order
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InitiatePaymentOrderRequest'
      responses:
        '201':
          description: Payment order successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InitiatePaymentOrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '500':
          $ref: '#/components/responses/InternalServerError'
  
  /payment-initiation/payment-orders/{id}:
    get:
      operationId: retrievePaymentOrder
      tags: [Payment Initiation]
      summary: Retrieve payment order details
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RetrievePaymentOrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /payment-initiation/payment-orders/{id}/status:
    get:
      operationId: retrievePaymentOrderStatus
      tags: [Payment Initiation]
      summary: Retrieve payment order status
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order status retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentOrderStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    InitiatePaymentOrderRequest:
      type: object
      required: 
        - payerReference
        - payeeReference
        - amount
      properties:
        payerReference:
          type: string
          description: Reference to the payer (customer ID)
          example: "CUST-12345"
        payeeReference:
          type: string
          description: Reference to the payee (beneficiary ID)
          example: "CUST-67890"
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
          description: Purpose of the payment
          example: "Invoice payment"
        paymentDate:
          type: string
          format: date
          description: Requested payment date
          example: "2024-11-20"
    
    InitiatePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
          description: BIAN-compliant payment order reference
          example: "PO-2024-001234"
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        createdAt:
          type: string
          format: date-time
    
    RetrievePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
        paymentDate:
          type: string
          format: date
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    PaymentOrderStatusResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        statusReason:
          type: string
          description: Reason for current status
        lastUpdated:
          type: string
          format: date-time
    
    PaymentAmount:
      type: object
      required:
        - value
        - currency
      properties:
        value:
          type: number
          format: double
          minimum: 0.01
          example: 1500.50
        currency:
          type: string
          enum: [USD, EUR, GBP, JPY]
          example: "USD"
    
    ProblemDetail:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request - validation errors
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    NotFound:
      description: Resource not found
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    InternalServerError:
      description: Internal server error
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
```

#### Gradle Configuration (build.gradle)
```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'org.openapi.generator' version '7.0.1'
    id 'checkstyle'
    id 'com.github.spotbugs' version '6.0.0'
    id 'jacoco'
}

group = 'com.hiberus.banking'
version = '1.0.0'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

ext {
    mapstructVersion = '1.5.5.Final'
    lombokVersion = '1.18.30'
    openApiVersion = '2.2.0'
}

dependencies {
    // Spring Boot Starters
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    
    // H2 Database
    runtimeOnly 'com.h2database:h2'
    
    // OpenAPI
    implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${openApiVersion}"
    
    // MapStruct
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
    
    // Lombok
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    
    // Lombok + MapStruct compatibility
    annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"
    
    // Testing
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-webflux'  // For WebTestClient
    testImplementation 'io.rest-assured:rest-assured:5.4.0'
    testImplementation 'org.assertj:assertj-core'
    
    // Test Lombok
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
}

// OpenAPI Generator Task
openApiGenerate {
    generatorName = 'spring'
    inputSpec = "$projectDir/src/main/resources/openapi.yaml"
    outputDir = "$buildDir/generated"
    apiPackage = 'com.hiberus.banking.payment.adapter.in.rest.api'
    modelPackage = 'com.hiberus.banking.payment.adapter.in.rest.dto'
    invokerPackage = 'com.hiberus.banking.payment.adapter.in.rest.invoker'
    configOptions = [
        interfaceOnly: 'true',
        useSpringBoot3: 'true',
        useTags: 'true',
        dateLibrary: 'java8',
        serializationLibrary: 'jackson',
        hideGenerationTimestamp: 'true'
    ]
}

// Add generated sources to source sets
sourceSets {
    main {
        java {
            srcDirs += "$buildDir/generated/src/main/java"
        }
    }
}

// Compile depends on generation
compileJava.dependsOn tasks.openApiGenerate

// JaCoCo Configuration
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
    }
}

// Checkstyle Configuration
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
}

// SpotBugs Configuration
spotbugs {
    effort = 'max'
    reportLevel = 'high'
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
        }
        xml {
            required = false
        }
    }
}

// Test Configuration
test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

// Build task order
check.dependsOn jacocoTestCoverageVerification
```

#### Controller Implementation (Spring MVC)
```java
@RestController
@RequiredArgsConstructor
@Slf4j
public class PaymentInitiationController implements PaymentInitiationApi {
    
    private final InitiatePaymentOrderUseCase initiateUseCase;
    private final RetrievePaymentOrderUseCase retrieveUseCase;
    private final RetrievePaymentOrderStatusUseCase retrieveStatusUseCase;
    private final PaymentOrderRestMapper mapper;
    
    @Override
    public ResponseEntity<InitiatePaymentOrderResponse> initiatePaymentOrder(
            InitiatePaymentOrderRequest request) {
        
        log.info("Initiating payment order for payer: {}", request.getPayerReference());
        
        PaymentOrder domainOrder = mapper.toDomain(request);
        PaymentOrder initiatedOrder = initiateUseCase.initiate(domainOrder);
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(initiatedOrder);
        
        log.info("Payment order initiated successfully: {}", response.getPaymentOrderReference());
        
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(response);
    }
    
    @Override
    public ResponseEntity<RetrievePaymentOrderResponse> retrievePaymentOrder(String id) {
        
        log.info("Retrieving payment order: {}", id);
        
        PaymentOrder paymentOrder = retrieveUseCase.retrieve(id);
        RetrievePaymentOrderResponse response = mapper.toRetrieveResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
    
    @Override
    public ResponseEntity<PaymentOrderStatusResponse> retrievePaymentOrderStatus(String id) {
        
        log.info("Retrieving payment order status: {}", id);
        
        PaymentOrder paymentOrder = retrieveStatusUseCase.retrieveStatus(id);
        PaymentOrderStatusResponse response = mapper.toStatusResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
}
```

### 5. Spring MVC with H2 Database

#### Application Configuration (application.yml)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 Database Configuration
  datasource:
    url: jdbc:h2:mem:paymentdb
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: false
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
  
  # Jackson Configuration
  jackson:
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

# Server Configuration
server:
  port: 8080
  servlet:
    context-path: /
  error:
    include-message: always
    include-binding-errors: always
    include-exception: false
    include-stacktrace: never

# Management / Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    tags:
      application: ${spring.application.name}
      service-domain: payment-initiation

# Logging
logging:
  level:
    com.hiberus.banking: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

#### JPA Entity Example
```java
@Entity
@Table(name = "payment_orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PaymentOrderEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(name = "payment_order_reference", nullable = false, unique = true, length = 50)
    private String paymentOrderReference;
    
    @Column(name = "payer_reference", nullable = false, length = 50)
    private String payerReference;
    
    @Column(name = "payee_reference", nullable = false, length = 50)
    private String payeeReference;
    
    @Column(name = "amount", nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "currency", nullable = false, length = 3)
    private String currency;
    
    @Column(name = "payment_purpose", length = 255)
    private String paymentPurpose;
    
    @Column(name = "payment_date")
    private LocalDate paymentDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PaymentStatusEntity status;
    
    @Column(name = "status_reason", length = 500)
    private String statusReason;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        if (status == null) {
            status = PaymentStatusEntity.INITIATED;
        }
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

@Getter
@RequiredArgsConstructor
enum PaymentStatusEntity {
    INITIATED("Payment order has been initiated"),
    PENDING("Payment order is pending processing"),
    PROCESSED("Payment order has been processed"),
    COMPLETED("Payment order completed successfully"),
    FAILED("Payment order failed"),
    CANCELLED("Payment order has been cancelled");
    
    private final String description;
}
```

#### Spring Data JPA Repository
```java
@Repository
public interface PaymentOrderJpaRepository extends JpaRepository<PaymentOrderEntity, UUID> {
    
    Optional<PaymentOrderEntity> findByPaymentOrderReference(String paymentOrderReference);
    
    List<PaymentOrderEntity> findByPayerReference(String payerReference);
    
    List<PaymentOrderEntity> findByStatus(PaymentStatusEntity status);
    
    @Query("SELECT p FROM PaymentOrderEntity p WHERE p.createdAt BETWEEN :startDate AND :endDate")
    List<PaymentOrderEntity> findByDateRange(
        @Param("startDate") LocalDateTime startDate, 
        @Param("endDate") LocalDateTime endDate
    );
    
    boolean existsByPaymentOrderReference(String paymentOrderReference);
}
```

#### Repository Adapter Implementation
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PaymentOrderRepositoryAdapter implements PaymentOrderRepository {
    
    private final PaymentOrderJpaRepository jpaRepository;
    private final PaymentOrderPersistenceMapper persistenceMapper;
    
    @Override
    public PaymentOrder save(PaymentOrder paymentOrder) {
        log.debug("Saving payment order: {}", paymentOrder.getPaymentOrderReference());
        
        PaymentOrderEntity entity = persistenceMapper.toEntity(paymentOrder);
        PaymentOrderEntity savedEntity = jpaRepository.save(entity);
        
        log.debug("Payment order saved with ID: {}", savedEntity.getId());
        return persistenceMapper.toDomain(savedEntity);
    }
    
    @Override
    public Optional<PaymentOrder> findByReference(String paymentOrderReference) {
        log.debug("Finding payment order by reference: {}", paymentOrderReference);
        
        return jpaRepository.findByPaymentOrderReference(paymentOrderReference)
            .map(persistenceMapper::toDomain);
    }
    
    @Override
    public boolean existsByReference(String paymentOrderReference) {
        return jpaRepository.existsByPaymentOrderReference(paymentOrderReference);
    }
    
    @Override
    public List<PaymentOrder> findAll() {
        return jpaRepository.findAll().stream()
            .map(persistenceMapper::toDomain)
            .collect(Collectors.toList());
    }
}
```

#### H2 Console Configuration
```java
@Configuration
public class H2ConsoleConfig {
    
    @Bean
    public ServletRegistrationBean<WebServlet> h2Console() {
        ServletRegistrationBean<WebServlet> registration = 
            new ServletRegistrationBean<>(new WebServlet());
        registration.addUrlMappings("/h2-console/*");
        return registration;
    }
}
```

#### Data Initialization (Optional - for testing)
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class DataInitializer {
    
    private final PaymentOrderJpaRepository repository;
    
    @EventListener(ApplicationReadyEvent.class)
    public void loadSampleData() {
        if (repository.count() == 0) {
            log.info("Loading sample payment orders...");
            
            PaymentOrderEntity order1 = PaymentOrderEntity.builder()
                .paymentOrderReference("PO-2024-001")
                .payerReference("CUST-12345")
                .payeeReference("CUST-67890")
                .amount(new BigDecimal("1500.50"))
                .currency("USD")
                .paymentPurpose("Invoice payment")
                .paymentDate(LocalDate.now())
                .status(PaymentStatusEntity.INITIATED)
                .build();
            
            repository.save(order1);
            log.info("Sample data loaded successfully");
        }
    }
}
```

### 6. MapStruct Mappers (Three Layers)

MapStruct is used for clean transformation between layers. There are THREE types of mappers:

#### 1. REST Mapper (Adapter Layer: DTO ↔ Domain)
```java
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR)
public interface PaymentOrderRestMapper {
    
    // Request DTO → Domain
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "paymentOrderReference", ignore = true)
    @Mapping(target = "status", constant = "INITIATED")
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    @Mapping(target = "updatedAt", ignore = true)
    PaymentOrder toDomain(InitiatePaymentOrderRequest request);
    
    // Domain → Response DTO (Initiate)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    InitiatePaymentOrderResponse toInitiateResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Retrieve)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    RetrievePaymentOrderResponse toRetrieveResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Status)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    @Mapping(source = "updatedAt", target = "lastUpdated")
    PaymentOrderStatusResponse toStatusResponse(PaymentOrder paymentOrder);
    
    // Value Object mappings
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    PaymentAmount toPaymentAmount(com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount dtoAmount);
    
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount toPaymentAmountDto(PaymentAmount domainAmount);
}
```

#### 2. Persistence Mapper (Adapter Layer: Domain ↔ Entity)
```java
@Mapper(componentModel = "spring", 
        unmappedTargetPolicy = ReportingPolicy.ERROR,
        uses = {PaymentStatusMapper.class})
public interface PaymentOrderPersistenceMapper {
    
    // Domain → Entity
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "payerReference.value", target = "payerReference")
    @Mapping(source = "payeeReference.value", target = "payeeReference")
    @Mapping(source = "amount.value", target = "amount")
    @Mapping(source = "amount.currency", target = "currency")
    @Mapping(source = "status", target = "status")
    @Mapping(target = "id", ignore = true)  // Let JPA generate
    PaymentOrderEntity toEntity(PaymentOrder domain);
    
    // Entity → Domain
    @Mapping(source = "paymentOrderReference", target = "id.value")
    @Mapping(source = "payerReference", target = "payerReference.value")
    @Mapping(source = "payeeReference", target = "payeeReference.value")
    @Mapping(source = "amount", target = "amount.value")
    @Mapping(source = "currency", target = "amount.currency")
    PaymentOrder toDomain(PaymentOrderEntity entity);
    
    // Custom mapping for status
    default PaymentStatus mapStatus(PaymentStatusEntity entityStatus) {
        return PaymentStatus.valueOf(entityStatus.name());
    }
    
    default PaymentStatusEntity mapStatus(PaymentStatus domainStatus) {
        return PaymentStatusEntity.valueOf(domainStatus.name());
    }
}
```

#### 3. Application Mapper (Optional: Complex transformations)
```java
@Mapper(componentModel = "spring")
public interface PaymentOrderApplicationMapper {
    
    // For complex business logic transformations
    @Mapping(target = "enrichedData", expression = "java(enrichData(source))")
    PaymentOrder enrichForProcessing(PaymentOrder source);
    
    default String enrichData(PaymentOrder order) {
        // Complex business logic here
        return "ENRICHED-" + order.getPaymentOrderReference();
    }
}
```

#### MapStruct Configuration Best Practices
```java
@MapperConfig(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.ERROR,  // Fail on unmapped fields
    unmappedSourcePolicy = ReportingPolicy.WARN,    // Warn on unmapped sources
    mappingInheritanceStrategy = MappingInheritanceStrategy.AUTO_INHERIT_FROM_CONFIG
)
public interface CentralMapperConfig {
}

// Then use it in mappers
@Mapper(config = CentralMapperConfig.class)
public interface PaymentOrderRestMapper {
    // ... mappings
}
```

#### Testing MapStruct Mappers
```java
@SpringBootTest
class PaymentOrderRestMapperTest {
    
    @Autowired
    private PaymentOrderRestMapper mapper;
    
    @Test
    @DisplayName("Should map InitiatePaymentOrderRequest to PaymentOrder domain")
    void shouldMapRequestToDomain() {
        // Given
        InitiatePaymentOrderRequest request = new InitiatePaymentOrderRequest()
            .payerReference("CUST-123")
            .payeeReference("CUST-456")
            .amount(new com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount()
                .value(1000.0)
                .currency("USD"))
            .paymentPurpose("Test payment");
        
        // When
        PaymentOrder domain = mapper.toDomain(request);
        
        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getPayerReference().getValue()).isEqualTo("CUST-123");
        assertThat(domain.getPayeeReference().getValue()).isEqualTo("CUST-456");
        assertThat(domain.getAmount().getValue()).isEqualByComparingTo("1000.0");
        assertThat(domain.getAmount().getCurrency()).isEqualTo(Currency.USD);
        assertThat(domain.getStatus()).isEqualTo(PaymentStatus.INITIATED);
    }
    
    @Test
    @DisplayName("Should map PaymentOrder domain to InitiatePaymentOrderResponse")
    void shouldMapDomainToResponse() {
        // Given
        PaymentOrder domain = PaymentOrderMother.valid();
        
        // When
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(domain);
        
        // Then
        assertThat(response).isNotNull();
        assertThat(response.getPaymentOrderReference()).isEqualTo(domain.getId().getValue());
        assertThat(response.getPaymentOrderStatus()).isEqualTo(domain.getStatus().name());
    }
}
```

### 7. Testing Strategy with Spring MVC and WebTestClient

#### Unit Tests (Domain & Application Layer)
```java
@ExtendWith(MockitoExtension.class)
class InitiatePaymentOrderServiceTest {
    
    @Mock
    private PaymentOrderRepository repository;
    
    @Mock
    private PaymentValidationPort validationPort;
    
    @InjectMocks
    private InitiatePaymentOrderService service;
    
    @Test
    @DisplayName("Should initiate payment order when valid")
    void shouldInitiatePaymentOrderWhenValid() {
        // Given
        PaymentOrder order = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenReturn(order);
        
        // When
        PaymentOrder result = service.initiate(order);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getStatus()).isEqualTo(PaymentStatus.INITIATED);
        assertThat(result.getPaymentOrderReference()).isNotNull();
        
        verify(validationPort).validate(order);
        verify(repository).save(any(PaymentOrder.class));
    }
    
    @Test
    @DisplayName("Should throw InvalidPaymentException when validation fails")
    void shouldThrowExceptionWhenValidationFails() {
        // Given
        PaymentOrder order = PaymentOrderMother.withInvalidAmount();
        when(validationPort.validate(any())).thenReturn(false);
        
        // When & Then
        assertThatThrownBy(() -> service.initiate(order))
            .isInstanceOf(InvalidPaymentException.class)
            .hasMessageContaining("validation failed");
        
        verify(validationPort).validate(order);
        verify(repository, never()).save(any());
    }
    
    @Test
    @DisplayName("Should generate unique payment order reference")
    void shouldGenerateUniqueReference() {
        // Given
        PaymentOrder order1 = PaymentOrderMother.valid();
        PaymentOrder order2 = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenAnswer(inv -> inv.getArgument(0));
        
        // When
        PaymentOrder result1 = service.initiate(order1);
        PaymentOrder result2 = service.initiate(order2);
        
        // Then
        assertThat(result1.getPaymentOrderReference())
            .isNotEqualTo(result2.getPaymentOrderReference());
    }
}
```

#### Integration Tests with WebTestClient (Recommended for Spring MVC)
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class PaymentInitiationIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        repository.deleteAll();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 201 Created")
    void shouldInitiatePaymentOrderSuccessfully() {
        // Given
        InitiatePaymentOrderRequest request = InitiatePaymentOrderRequest.builder()
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1500.50)
                .currency("USD")
                .build())
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .build();
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .exchange()
            .expectStatus().isCreated()
            .expectHeader().exists("Location")
            .expectBody(InitiatePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getPaymentOrderReference()).startsWith("PO-");
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getPayeeReference()).isEqualTo("CUST-67890");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
                assertThat(response.getCreatedAt()).isNotNull();
            });
        
        // Verify database
        assertThat(repository.count()).isEqualTo(1);
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 200 OK")
    void shouldRetrievePaymentOrderSuccessfully() {
        // Given - Create a payment order first
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(RetrievePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id}/status - Should return 200 OK")
    void shouldRetrievePaymentOrderStatusSuccessfully() {
        // Given
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}/status", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(PaymentOrderStatusResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getLastUpdated()).isNotNull();
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 404 Not Found")
    void shouldReturn404WhenPaymentOrderNotFound() {
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", "NON-EXISTENT")
            .exchange()
            .expectStatus().isNotFound()
            .expectBody()
            .jsonPath("$.title").isEqualTo("Payment Order Not Found")
            .jsonPath("$.status").isEqualTo(404)
            .jsonPath("$.detail").exists();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 400 Bad Request for invalid data")
    void shouldReturn400ForInvalidRequest() {
        // Given - Invalid request (missing required fields)
        String invalidRequest = """
            {
                "payerReference": "CUST-123"
            }
            """;
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(invalidRequest)
            .exchange()
            .expectStatus().isBadRequest()
            .expectBody()
            .jsonPath("$.title").exists()
            .jsonPath("$.status").isEqualTo(400);
    }
    
    @Test
    @DisplayName("Should handle concurrent payment order creation")
    void shouldHandleConcurrentCreation() throws Exception {
        // Given
        int numberOfThreads = 5;
        ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);
        CountDownLatch latch = new CountDownLatch(numberOfThreads);
        
        // When
        for (int i = 0; i < numberOfThreads; i++) {
            final int index = i;
            executorService.submit(() -> {
                try {
                    InitiatePaymentOrderRequest request = createRequest("PAYER-" + index);
                    webTestClient.post()
                        .uri("/payment-initiation/payment-orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(request)
                        .exchange()
                        .expectStatus().isCreated();
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(10, TimeUnit.SECONDS);
        executorService.shutdown();
        
        // Then
        assertThat(repository.count()).isEqualTo(numberOfThreads);
    }
    
    // Helper methods
    private PaymentOrderEntity createSampleEntity() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-TEST-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Test payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
    
    private InitiatePaymentOrderRequest createRequest(String payerRef) {
        return InitiatePaymentOrderRequest.builder()
            .payerReference(payerRef)
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1000.0)
                .currency("USD")
                .build())
            .paymentPurpose("Concurrent test")
            .build();
    }
}
```

#### Alternative: REST Assured for Integration Tests
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class PaymentInitiationRestAssuredTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        RestAssured.basePath = "/payment-initiation";
        repository.deleteAll();
    }
    
    @Test
    void shouldInitiatePaymentOrder() {
        given()
            .contentType(ContentType.JSON)
            .body(createValidRequest())
        .when()
            .post("/payment-orders")
        .then()
            .statusCode(201)
            .body("paymentOrderReference", notNullValue())
            .body("paymentOrderStatus", equalTo("INITIATED"))
            .body("amount.value", equalTo(1500.50f))
            .body("amount.currency", equalTo("USD"));
    }
    
    @Test
    void shouldRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity saved = repository.save(createSampleEntity());
        
        // When & Then
        given()
            .pathParam("id", saved.getPaymentOrderReference())
        .when()
            .get("/payment-orders/{id}")
        .then()
            .statusCode(200)
            .body("paymentOrderReference", equalTo(saved.getPaymentOrderReference()))
            .body("paymentOrderStatus", equalTo("INITIATED"));
    }
}
```

#### Test Data Builders (Object Mother Pattern)
```java
public class PaymentOrderMother {
    
    public static PaymentOrder valid() {
        return PaymentOrder.builder()
            .id(PaymentOrderId.generate())
            .payerReference(PayerReference.of("CUST-12345"))
            .payeeReference(PayeeReference.of("CUST-67890"))
            .amount(PaymentAmount.of(1500.50, Currency.USD))
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatus.INITIATED)
            .createdAt(LocalDateTime.now())
            .build();
    }
    
    public static PaymentOrder withInvalidAmount() {
        return valid().toBuilder()
            .amount(PaymentAmount.of(-100.00, Currency.USD))
            .build();
    }
    
    public static PaymentOrder withStatus(PaymentStatus status) {
        return valid().toBuilder()
            .status(status)
            .build();
    }
    
    public static PaymentOrder pending() {
        return withStatus(PaymentStatus.PENDING);
    }
    
    public static PaymentOrder completed() {
        return withStatus(PaymentStatus.COMPLETED);
    }
}

public class PaymentOrderEntityMother {
    
    public static PaymentOrderEntity valid() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
}
```

#### Repository Tests
```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class PaymentOrderJpaRepositoryTest {
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    @DisplayName("Should save and retrieve payment order")
    void shouldSaveAndRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity entity = PaymentOrderEntityMother.valid();
        
        // When
        PaymentOrderEntity saved = repository.save(entity);
        entityManager.flush();
        entityManager.clear();
        
        // Then
        Optional<PaymentOrderEntity> found = repository.findByPaymentOrderReference(
            saved.getPaymentOrderReference()
        );
        
        assertThat(found).isPresent();
        assertThat(found.get().getPayerReference()).isEqualTo("CUST-12345");
        assertThat(found.get().getAmount()).isEqualByComparingTo("1500.50");
    }
    
    @Test
    @DisplayName("Should find payment orders by status")
    void shouldFindByStatus() {
        // Given
        repository.save(PaymentOrderEntityMother.valid());
        repository.save(PaymentOrderEntityMother.valid().toBuilder()
            .paymentOrderReference("PO-2024-002")
            .status(PaymentStatusEntity.COMPLETED)
            .build());
        entityManager.flush();
        
        // When
        List<PaymentOrderEntity> initiated = repository.findByStatus(PaymentStatusEntity.INITIATED);
        List<PaymentOrderEntity> completed = repository.findByStatus(PaymentStatusEntity.COMPLETED);
        
        // Then
        assertThat(initiated).hasSize(1);
        assertThat(completed).hasSize(1);
    }
}
```

### 8. Quality Gates (Mandatory - Gradle)

#### JaCoCo Configuration (Gradle)
```groovy
// build.gradle
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                '**/dto/**',
                '**/entity/**',
                '**/config/**',
                '**/*Application.class',
                '**/*MapperImpl.class'  // Exclude MapStruct generated classes
            ])
        }))
    }
}

jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
        
        rule {
            element = 'CLASS'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.70
            }
            excludes = [
                '*.dto.*',
                '*.entity.*',
                '*.config.*',
                '*Application',
                '*MapperImpl'
            ]
        }
    }
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

check.dependsOn jacocoTestCoverageVerification
```

#### Checkstyle Configuration (Gradle)
```groovy
// build.gradle
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
    configProperties = [
        'checkstyle.suppressions.file': "${project.rootDir}/config/checkstyle/suppressions.xml"
    ]
}

checkstyleMain {
    source = 'src/main/java'
    exclude '**/dto/**', '**/entity/**'  // Exclude generated code
}

checkstyleTest {
    source = 'src/test/java'
}

tasks.withType(Checkstyle) {
    reports {
        xml.required = true
        html.required = true
    }
}
```

#### config/checkstyle/checkstyle.xml
```xml
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
    "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
    "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <property name="charset" value="UTF-8"/>
    <property name="severity" value="error"/>
    <property name="fileExtensions" value="java"/>
    
    <module name="SuppressionFilter">
        <property name="file" value="${checkstyle.suppressions.file}"/>
    </module>
    
    <module name="TreeWalker">
        <!-- Naming Conventions -->
        <module name="TypeName">
            <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="MethodName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="ConstantName">
            <property name="format" value="^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"/>
        </module>
        
        <module name="LocalVariableName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <!-- Code Style -->
        <module name="LeftCurly"/>
        <module name="RightCurly"/>
        <module name="NeedBraces"/>
        
        <module name="WhitespaceAround"/>
        <module name="NoWhitespaceBefore"/>
        
        <!-- Imports -->
        <module name="AvoidStarImport"/>
        <module name="UnusedImports"/>
        <module name="RedundantImport"/>
        
        <!-- Size Violations -->
        <module name="LineLength">
            <property name="max" value="120"/>
        </module>
        
        <module name="MethodLength">
            <property name="max" value="150"/>
        </module>
        
        <!-- Complexity -->
        <module name="CyclomaticComplexity">
            <property name="max" value="15"/>
        </module>
        
        <!-- Best Practices -->
        <module name="EmptyBlock"/>
        <module name="EqualsHashCode"/>
        <module name="SimplifyBooleanExpression"/>
        <module name="SimplifyBooleanReturn"/>
        
        <!-- Annotations -->
        <module name="MissingOverride"/>
    </module>
</module>
```

#### SpotBugs Configuration (Gradle)
```groovy
// build.gradle
spotbugs {
    effort = 'max'
    reportLevel = 'high'
    excludeFilter = file("${project.rootDir}/config/spotbugs/spotbugs-exclude.xml")
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/main/spotbugs.html")
        }
        xml {
            required = false
        }
    }
}

tasks.named('spotbugsTest') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/test/spotbugs.html")
        }
    }
}
```

#### config/spotbugs/spotbugs-exclude.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<FindBugsFilter>
    <!-- Exclude generated code -->
    <Match>
        <Package name="~.*\.dto.*"/>
    </Match>
    
    <Match>
        <Package name="~.*\.entity.*"/>
    </Match>
    
    <Match>
        <Class name="~.*MapperImpl"/>
    </Match>
    
    <!-- Exclude specific bugs for Lombok -->
    <Match>
        <Bug pattern="EI_EXPOSE_REP,EI_EXPOSE_REP2"/>
        <Or>
            <Class name="~.*\.domain\.model\..*"/>
        </Or>
    </Match>
</FindBugsFilter>
```

#### Gradle Verification Tasks
```groovy
// Create custom task to run all quality checks
tasks.register('qualityCheck') {
    dependsOn 'checkstyleMain', 'checkstyleTest', 'spotbugsMain', 'jacocoTestCoverageVerification'
    description = 'Run all quality checks: Checkstyle, SpotBugs, and JaCoCo'
    group = 'verification'
}

// Make 'check' depend on quality checks
check {
    dependsOn 'qualityCheck'
}

// Gradle wrapper
wrapper {
    gradleVersion = '8.5'
    distributionType = Wrapper.DistributionType.ALL
}
```

#### Run Quality Checks
```bash
# Run all quality checks
./gradlew check

# Run individual checks
./gradlew checkstyleMain
./gradlew spotbugsMain
./gradlew test jacocoTestReport
./gradlew jacocoTestCoverageVerification

# Build with quality checks
./gradlew clean build

# Generate reports
./gradlew jacocoTestReport
# Report: build/reports/jacoco/test/html/index.html

./gradlew checkstyleMain
# Report: build/reports/checkstyle/main.html

./gradlew spotbugsMain
# Report: build/reports/spotbugs/main/spotbugs.html
```

### 8. Domain Modeling Best Practices

#### Value Objects
```java
@Value
@Builder
public class PaymentAmount {
    BigDecimal value;
    Currency currency;
    
    public static PaymentAmount of(double value, Currency currency) {
        if (value <= 0) {
            throw new InvalidPaymentException("Amount must be positive");
        }
        return new PaymentAmount(BigDecimal.valueOf(value), currency);
    }
}
```

#### Aggregates
```java
@Builder(toBuilder = true)
@Value
public class PaymentOrder {
    PaymentOrderId id;
    PayerReference payerReference;
    PayeeReference payeeReference;
    PaymentAmount amount;
    PaymentStatus status;
    LocalDateTime createdAt;
    
    // Business invariants
    public PaymentOrder validate() {
        if (status == PaymentStatus.CANCELLED && amount.getValue().compareTo(BigDecimal.ZERO) > 0) {
            throw new InvalidPaymentException("Cancelled orders cannot have positive amount");
        }
        return this;
    }
    
    public PaymentOrder markAsProcessed() {
        if (status != PaymentStatus.INITIATED) {
            throw new InvalidPaymentException("Only initiated orders can be processed");
        }
        return this.toBuilder().status(PaymentStatus.PROCESSED).build();
    }
}
```

#### Domain Events (if needed)
```java
@Value
public class PaymentOrderInitiatedEvent {
    String paymentOrderReference;
    PaymentAmount amount;
    LocalDateTime occurredOn;
}
```

### 9. Error Handling (RFC 7807)

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(PaymentOrderNotFoundException.class)
    public ResponseEntity<ProblemDetail> handleNotFound(PaymentOrderNotFoundException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, 
            ex.getMessage()
        );
        problem.setTitle("Payment Order Not Found");
        problem.setProperty("paymentOrderReference", ex.getPaymentOrderReference());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem);
    }
    
    @ExceptionHandler(InvalidPaymentException.class)
    public ResponseEntity<ProblemDetail> handleInvalidPayment(InvalidPaymentException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST,
            ex.getMessage()
        );
        problem.setTitle("Invalid Payment Order");
        problem.setProperty("validationErrors", ex.getErrors());
        return ResponseEntity.badRequest().body(problem);
    }
}
```

### 10. Docker Configuration with H2

#### Multi-stage Dockerfile (Gradle)
```dockerfile
# Build stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

# Copy Gradle files
COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .

# Copy source code
COPY src src
COPY config config

# Build application (skip tests for faster builds, tests run in CI/CD)
RUN ./gradlew clean build -x test --no-daemon

# Runtime stage
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Create non-root user for security
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# Copy JAR from builder
COPY --from=builder /app/build/libs/*.jar app.jar

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# JVM options
ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC -XX:+UseContainerSupport"

# Run application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

#### docker-compose.yml (H2 in-memory)
```yaml
version: '3.8'

services:
  payment-initiation-service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: payment-initiation-service
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - JAVA_OPTS=-Xms256m -Xmx512m
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - payment-network
    restart: unless-stopped

networks:
  payment-network:
    driver: bridge

# Optional: Add volumes for H2 file-based persistence
# volumes:
#   h2-data:
#     driver: local
```

#### application-docker.yml (For containerized H2)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 with file persistence in Docker (optional)
  datasource:
    url: jdbc:h2:file:/app/data/paymentdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: true  # Allow access from outside container
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: false

server:
  port: 8080

logging:
  level:
    com.hiberus.banking: INFO
    org.springframework.web: WARN
```

#### Docker Commands
```bash
# Build image
docker build -t payment-initiation-service:latest .

# Run with docker-compose
docker-compose up -d

# View logs
docker-compose logs -f payment-initiation-service

# Stop services
docker-compose down

# Rebuild and restart
docker-compose up -d --build

# Access H2 Console (if enabled)
# URL: http://localhost:8080/h2-console
# JDBC URL: jdbc:h2:mem:paymentdb
# Username: sa
# Password: (empty)

# Health check
curl http://localhost:8080/actuator/health

# Test API
curl -X POST http://localhost:8080/payment-initiation/payment-orders \
  -H "Content-Type: application/json" \
  -d '{
    "payerReference": "CUST-123",
    "payeeReference": "CUST-456",
    "amount": {
      "value": 1500.50,
      "currency": "USD"
    },
    "paymentPurpose": "Invoice payment"
  }'
```

#### .dockerignore
```
.git
.gitignore
.gradle
build/
!build/libs/*.jar
*.md
.idea
*.iml
.vscode
target/
*.log
```

#### Alternative: Dockerfile with tests included
```dockerfile
# Build and test stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .
COPY config config
COPY src src

# Run tests and build
RUN ./gradlew clean build --no-daemon

# Runtime stage (same as before)
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

COPY --from=builder /app/build/libs/*.jar app.jar

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 11. AI-Assisted Development Documentation (Required)

#### Structure for ai/ folder
```
ai/
├── prompts.md                 # All prompts used with AI responses
├── decisions.md              # Architectural decisions and rationale
└── generations/              # Generated code samples with annotations
    ├── 01-wsdl-analysis.md
    ├── 02-openapi-draft.yaml
    ├── 03-domain-model.java
    ├── 04-mappers-generation.java
    ├── 05-controller-skeleton.java
    └── 06-test-generation.java
```

#### Example prompts.md format (SOAP Migration Context)
```markdown
# AI Prompts and Generations Log

## Context
This document tracks all AI interactions used during the SOAP to REST migration project.
Each entry includes the prompt, AI response summary, generated artifacts, and manual corrections.

---

## Prompt 1: WSDL Analysis and BIAN Mapping

**Date**: 2025-10-30
**AI Tool**: Claude 3.5 Sonnet / ChatGPT-4 / Cursor AI

**Prompt**:
```
I have a legacy SOAP service defined in PaymentOrderService.wsdl. 
Analyze this WSDL and map it to the BIAN Payment Initiation Service Domain (PaymentOrder BQ).

Identify:
1. SOAP operations and their BIAN equivalents
2. Data structures and field mappings
3. Business rules implied by the schema
4. Status flows and lifecycle states
5. Suggest REST endpoint structure aligned with BIAN

WSDL Content:
[paste PaymentOrderService.wsdl content]
```

**AI Response Summary**:
The AI identified two main SOAP operations:

1. **SubmitPaymentOrder** → Maps to BIAN **Initiate** operation
   - SOAP: `externalId, debtorIban, creditorIban, amount, currency, remittanceInfo, requestedExecutionDate`
   - REST: POST `/payment-initiation/payment-orders`
   - Status returned: ACCEPTED (maps to BIAN INITIATED)

2. **GetPaymentOrderStatus** → Maps to BIAN **Retrieve Status**
   - SOAP: `paymentOrderId` → returns `status, lastUpdate`
   - REST: GET `/payment-initiation/payment-orders/{id}/status`

**Generated Artifacts**:
- Field mapping table (SOAP → BIAN)
- Status mapping (ACCEPTED → INITIATED, SETTLED → COMPLETED, etc.)
- Suggested OpenAPI paths structure

**Manual Corrections Made**:
1. ✅ Changed generic `paymentOrderId` to BIAN-compliant `paymentOrderReference`
2. ✅ Added missing `externalReference` field (from SOAP `externalId`)
3. ✅ Wrapped IBAN fields into `Account` objects for better structure
4. ✅ Combined `amount + currency` into `InstructedAmount` object (ISO 20022)
5. ✅ Added missing BIAN operation: GET `/payment-orders/{id}` (full retrieve)
6. ✅ Normalized status values to BIAN lifecycle (6 states)
7. ✅ Added audit fields: `createdAt`, `updatedAt` (not in SOAP)

**Validation**:
- ✅ Confirmed with BIAN Payment Initiation SD documentation
- ✅ Validated against Postman collection examples
- ✅ Verified ISO 20022 compliance for amount structure

---

## Prompt 2: OpenAPI Specification Generation

**Date**: 2025-10-30

**Prompt**:
```
Based on the SOAP to BIAN mapping from Prompt 1, generate a complete OpenAPI 3.0 specification.

Requirements:
- Follow BIAN Service Domain: Payment Initiation (PaymentOrder BQ)
- Include all three endpoints: POST initiate, GET retrieve, GET status
- Use proper HTTP status codes (201, 200, 400, 404, 409, 500)
- Include RFC 7807 error responses (application/problem+json)
- Add request/response examples based on the Postman collection
- Include field validations (patterns, min/max, required)
- Document SOAP to REST field mappings in descriptions

Postman collection example:
[paste postman_collection.json relevant parts]
```

**AI Response Summary**:
Generated complete OpenAPI 3.0 spec with:
- 3 endpoints with proper operationIds
- Request/response schemas with BIAN naming
- Validation rules (IBAN pattern, amount min, currency enum)
- RFC 7807 ProblemDetail schema
- Examples from Postman collection

**Generated Artifacts**:
- `openapi.yaml` (initial draft)
- Component schemas: Account, InstructedAmount, PaymentStatus enum
- Example payloads matching Postman tests

**Manual Corrections Made**:
1. ✅ Fixed IBAN regex pattern to match Ecuador format (EC prefix)
2. ✅ Added `pattern` for `paymentOrderReference` (^PO-[0-9]{4,}$)
3. ✅ Changed currency enum to include only supported currencies
4. ✅ Added 409 Conflict response for duplicate `externalReference`
5. ✅ Enhanced descriptions with SOAP field references
6. ✅ Added Location header for 201 Created response

**Validation**:
- ✅ Validated with openapi-generator (no errors)
- ✅ Imported into Swagger UI successfully
- ✅ All Postman examples map correctly to OpenAPI schemas

---

## Prompt 3: Hexagonal Architecture Package Structure

**Date**: 2025-10-30

**Prompt**:
```
Generate the complete hexagonal architecture package structure for this BIAN Payment Initiation microservice.

Requirements:
- Java 17+, Spring Boot 3, Spring MVC (no reactive)
- Three layers: domain, application, adapter
- Domain must be framework-independent
- Include all necessary value objects based on OpenAPI
- Use ports and adapters pattern
- Add MapStruct mappers in appropriate layers

Context:
- Migrating from SOAP (PaymentOrderService.wsdl)
- Need: Account, InstructedAmount, PaymentOrderReference, ExternalReference value objects
- Status mapping service for SOAP ↔ BIAN conversion
- Three endpoints: Initiate, Retrieve, RetrieveStatus
```

**AI Response Summary**:
Generated complete package structure with:
- Domain layer: 4 value objects, 1 aggregate, 3 use case interfaces
- Application layer: 3 service implementations, 1 mapper interface
- Adapter layer: REST (controller + DTOs), Persistence (JPA + entities)
- Proper dependency direction (inward)

**Generated Artifacts**:
```
com.hiberus.banking.payment/
├── domain/
│   ├── model/ (PaymentOrder, Account, InstructedAmount, etc.)
│   ├── port/in/ (Use case interfaces)
│   ├── port/out/ (Repository interfaces)
│   └── service/ (StatusMappingService)
├── application/
│   ├── service/ (Use case implementations)
│   └── mapper/ (MapStruct interfaces)
└── adapter/
    ├── in/rest/ (Controller, DTOs)
    └── out/persistence/ (JPA adapters)
```

**Manual Corrections Made**:
1. ✅ Added `StatusMappingService` in domain layer (wasn't suggested)
2. ✅ Split mapper into 3 types: REST, Persistence, Application
3. ✅ Added `DuplicateExternalReferenceException` for 409 Conflict
4. ✅ Created separate package for legacy SOAP adapter (future hybrid mode)
5. ✅ Added `@PrePersist` and `@PreUpdate` in JPA entity

---

## Prompt 4: Domain Model Implementation

**Date**: 2025-10-30

**Prompt**:
```
Implement the complete domain model for PaymentOrder aggregate.

Requirements:
- Use Lombok @Value and @Builder
- Include all value objects: Account, InstructedAmount, PaymentOrderReference, ExternalReference
- PaymentStatus enum with BIAN lifecycle (6 states)
- Business invariants validation
- State transition methods (markAsPending, markAsCompleted, etc.)
- Include SOAP status mapping in PaymentStatus enum

Reference:
- OpenAPI schemas from openapi.yaml
- SOAP status mapping: ACCEPTED→INITIATED, SETTLED→COMPLETED
```

**AI Response Summary**:
Generated complete domain model with:
- PaymentOrder aggregate with 10 fields
- 4 value objects with factory methods and validation
- PaymentStatus enum with 6 states + SOAP mapping
- 5 state transition methods with business rules
- Comprehensive validation in value object constructors

**Generated Artifacts**:
- `PaymentOrder.java` (aggregate root)
- `Account.java`, `InstructedAmount.java`, `PaymentOrderReference.java`, `ExternalReference.java`
- `PaymentStatus.java` (enum with SOAP mapping)
- `StatusMappingService.java`

**Manual Corrections Made**:
1. ✅ Added `equals` check to prevent same debtor/creditor
2. ✅ Enhanced IBAN validation regex
3. ✅ Added `AtomicInteger` for payment order reference generation
4. ✅ Included `soapStatus` field in PaymentStatus enum for backward compatibility
5. ✅ Added `fromSoapStatus()` static method for legacy integration
6. ✅ Improved error messages with specific field references

**Validation**:
- ✅ Unit tests pass for all value objects
- ✅ State transitions enforce business rules correctly
- ✅ SOAP status mapping bidirectional and accurate

---

## Prompt 5: MapStruct Mappers Generation

**Date**: 2025-10-30

**Prompt**:
```
Generate three MapStruct mappers for the payment service:

1. PaymentOrderRestMapper (DTO ↔ Domain)
   - InitiatePaymentOrderRequest → PaymentOrder
   - PaymentOrder → InitiatePaymentOrderResponse
   - PaymentOrder → RetrievePaymentOrderResponse
   - PaymentOrder → PaymentOrderStatusResponse

2. PaymentOrderPersistenceMapper (Domain ↔ Entity)
   - PaymentOrder → PaymentOrderEntity
   - PaymentOrderEntity → PaymentOrder

3. Include proper Lombok + MapStruct configuration

Requirements:
- componentModel = "spring"
- unmappedTargetPolicy = ReportingPolicy.ERROR
- Handle value object mapping (Account.iban, InstructedAmount.amount/currency)
- Map PaymentStatus enum ↔ PaymentStatusEntity
```

**AI Response Summary**:
Generated three complete MapStruct interfaces with:
- All necessary @Mapping annotations
- Proper value object unwrapping/wrapping
- Custom methods for complex transformations
- Lombok + MapStruct compatibility configuration

**Generated Artifacts**:
- `PaymentOrderRestMapper.java`
- `PaymentOrderPersistenceMapper.java`
- `PaymentOrderApplicationMapper.java`
- `build.gradle` MapStruct configuration

**Manual Corrections Made**:
1. ✅ Added `expression` for `createdAt` (java.time.LocalDateTime.now())
2. ✅ Fixed nested mapping for `instructedAmount.amount` and `.currency`
3. ✅ Added `lombok-mapstruct-binding` dependency for compatibility
4. ✅ Created custom method for PaymentStatus ↔ PaymentStatusEntity
5. ✅ Added `@Mapping(target = "id", ignore = true)` for JPA entity ID

**Validation**:
- ✅ MapStruct generates implementation classes successfully
- ✅ Spring beans properly injected
- ✅ No compilation warnings about unmapped fields

---

## Prompt 6: Controller Implementation

**Date**: 2025-10-30

**Prompt**:
```
Implement PaymentInitiationController with Spring MVC.

Requirements:
- Implement OpenAPI-generated interface (PaymentInitiationApi)
- Three operations: initiatePaymentOrder, retrievePaymentOrder, retrievePaymentOrderStatus
- Proper HTTP status codes: 201 Created (with Location header), 200 OK
- Use MapStruct mapper for DTO ↔ Domain
- Structured logging with paymentOrderReference
- Inject use cases via constructor (Lombok @RequiredArgsConstructor)

Context:
- Spring MVC (not reactive)
- OpenAPI interface already generated
- Use cases already implemented in application layer
```

**AI Response Summary**:
Generated complete controller implementation with:
- Implementation of generated API interface
- Proper HTTP status handling
- Location header for POST responses
- Structured logging at info level
- Clean separation of concerns

**Generated Artifacts**:
- `PaymentInitiationController.java`

**Manual Corrections Made**:
1. ✅ Added `@Slf4j` for logging
2. ✅ Enhanced log messages with structured fields
3. ✅ Added `ResponseEntity.created()` with URI for Location header
4. ✅ Added try-catch for better error context (later moved to @ControllerAdvice)
5. ✅ Validated all operations return correct HTTP status

**Validation**:
- ✅ All Postman tests pass
- ✅ Location header present in 201 responses
- ✅ Proper content negotiation (application/json)

---

## Prompt 7: Unit Test Generation

**Date**: 2025-10-30

**Prompt**:
```
Generate comprehensive unit tests for:
1. InitiatePaymentOrderService (application layer)
2. PaymentOrder domain model (value objects, state transitions)
3. MapStruct mappers

Requirements:
- JUnit 5, Mockito, AssertJ
- @ExtendWith(MockitoExtension.class)
- Use Object Mother pattern for test data
- Test all business rules and validations
- Cover happy paths and edge cases
- Target: 80%+ coverage

Context:
- Spring MVC (not reactive, no StepVerifier)
- Domain layer is framework-independent
```

**AI Response Summary**:
Generated complete test suite with:
- 15 unit tests for InitiatePaymentOrderService
- 20 tests for PaymentOrder and value objects
- 8 tests for MapStruct mappers
- Object Mother pattern classes (PaymentOrderMother, etc.)
- Comprehensive edge case coverage

**Generated Artifacts**:
- `InitiatePaymentOrderServiceTest.java`
- `PaymentOrderTest.java`
- `PaymentOrderRestMapperTest.java`
- `PaymentOrderMother.java` (test data builder)

**Manual Corrections Made**:
1. ✅ Removed `StepVerifier` (was suggesting reactive tests)
2. ✅ Changed to standard JUnit assertions (no Mono/Flux)
3. ✅ Added `@DisplayName` annotations for better test reports
4. ✅ Enhanced Object Mother with more builder methods
5. ✅ Added parameterized tests for status transitions

**Validation**:
- ✅ All tests pass
- ✅ JaCoCo coverage: 87% (exceeds 80% requirement)
- ✅ No flaky tests

---

## Prompt 8: Integration Tests with WebTestClient

**Date**: 2025-10-30

**Prompt**:
```
Generate end-to-end integration tests for all three endpoints.

Requirements:
- @SpringBootTest with RANDOM_PORT
- Use WebTestClient (works with Spring MVC)
- Test all Postman collection scenarios
- Verify HTTP status codes: 201, 200, 404, 400
- Validate response payloads
- Test H2 database persistence
- Use @BeforeEach to clean database

Postman scenarios:
1. POST /payment-orders → 201 Created
2. GET /payment-orders/{id} → 200 OK
3. GET /payment-orders/{id}/status → 200 OK
4. GET /payment-orders/NON-EXISTENT → 404 Not Found
```

**AI Response Summary**:
Generated complete integration test class with:
- 6 E2E test methods
- WebTestClient configuration
- Database cleanup in @BeforeEach
- Payload validation with AssertJ
- Repository verification

**Generated Artifacts**:
- `PaymentInitiationIntegrationTest.java`

**Manual Corrections Made**:
1. ✅ Added `@AutoConfigureWebTestClient` annotation
2. ✅ Removed Testcontainers (using H2 in-memory)
3. ✅ Added concurrent request test (5 threads)
4. ✅ Enhanced assertions to validate nested objects
5. ✅ Added test for duplicate externalReference (409 Conflict)

**Validation**:
- ✅ All integration tests pass
- ✅ Database state verified after each test
- ✅ Matches Postman collection behavior exactly

---

## Summary Statistics

| Category | AI Generated | Manual Corrections | Final Status |
|----------|--------------|-------------------|--------------|
| OpenAPI Schema | 90% | 10% | ✅ Complete |
| Domain Model | 85% | 15% | ✅ Complete |
| Mappers | 80% | 20% | ✅ Complete |
| Controllers | 90% | 10% | ✅ Complete |
| Unit Tests | 75% | 25% | ✅ Complete |
| Integration Tests | 80% | 20% | ✅ Complete |
| **Overall** | **83%** | **17%** | ✅ Complete |

## Key Learnings

### What AI Did Well:
1. ✅ WSDL analysis and BIAN mapping (excellent structure identification)
2. ✅ OpenAPI generation (90% correct, needed minor tweaks)
3. ✅ Boilerplate code (controllers, entities, DTOs)
4. ✅ Test skeletons (good coverage of scenarios)
5. ✅ Hexagonal architecture structure (proper layering)

### What Required Manual Correction:
1. ⚠️ Reactive vs. non-reactive confusion (suggested Mono/Flux initially)
2. ⚠️ BIAN-specific naming conventions (needed domain expertise)
3. ⚠️ Business rule edge cases (domain knowledge required)
4. ⚠️ MapStruct complex mappings (nested objects, expressions)
5. ⚠️ SOAP-specific status mapping logic (legacy integration)

### Recommendations for Future Projects:
1. 📋 Provide complete context upfront (tech stack, constraints, examples)
2. 📋 Validate each generation step before proceeding
3. 📋 Use AI for repetitive code, manual review for business logic
4. 📋 Document ALL corrections (this file serves as audit trail)
5. 📋 Test generated code immediately (don't accumulate untested code)

---

## AI Tools Used

| Tool | Version | Use Case | Effectiveness |
|------|---------|----------|---------------|
| Claude 3.5 Sonnet | Latest | Architecture, domain modeling | ⭐⭐⭐⭐⭐ |
| ChatGPT-4 | GPT-4 | OpenAPI generation, tests | ⭐⭐⭐⭐ |
| Cursor AI | Latest | Code completion, refactoring | ⭐⭐⭐⭐⭐ |
| GitHub Copilot | Latest | Test data builders | ⭐⭐⭐ |

## References
- BIAN Service Domain: Payment Initiation v12.0
- ISO 20022 Payment Initiation Messages
- RFC 7807: Problem Details for HTTP APIs
- OpenAPI Specification 3.0.3
```

This comprehensive documentation provides:
- ✅ Complete audit trail of AI usage
- ✅ Transparency in what was generated vs. corrected
- ✅ Context for future maintainers
- ✅ Validation that requirements were met
- ✅ Lessons learned for process improvement

### 12. Code Style & Conventions

#### Naming Conventions
- **Classes**: PascalCase (e.g., `PaymentOrder`, `InitiatePaymentOrderService`)
- **Methods**: camelCase, verb-based (e.g., `initiatePayment`, `retrieveOrderStatus`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_PAYMENT_AMOUNT`)
- **Packages**: lowercase, domain-driven (e.g., `domain.model`, `adapter.in.rest`)

#### BIAN-Specific Conventions
- Prefix interfaces with use case: `InitiatePaymentOrderUseCase`
- Use "Reference" suffix for IDs: `paymentOrderReference`, `payerReference`
- Status naming: Use BIAN lifecycle terms (INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED)

#### Lombok Usage
```java
@Value                    // For immutable value objects
@Builder(toBuilder=true) // For entities with many fields
@RequiredArgsConstructor // For dependency injection
@Slf4j                   // For logging
```

### 13. Observability & Production Readiness

#### Actuator Configuration
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    tags:
      application: payment-initiation-service
      service-domain: payment-initiation
```

#### Custom Metrics
```java
@Component
@RequiredArgsConstructor
public class PaymentMetrics {
    
    private final MeterRegistry registry;
    
    public void recordPaymentInitiated(PaymentAmount amount) {
        registry.counter("payment.initiated", 
            "currency", amount.getCurrency().toString())
            .increment();
        
        registry.summary("payment.amount")
            .record(amount.getValue().doubleValue());
    }
}
```

#### Logging Best Practices
```java
// Structured logging
log.info("Payment order initiated", 
    kv("paymentOrderReference", order.getId()),
    kv("amount", order.getAmount().getValue()),
    kv("status", order.getStatus()));

// Never log sensitive data (PII)
// Use correlation IDs for tracing
```

### 14. Security Considerations

- Validate all inputs at adapter layer
- Use Bean Validation annotations in DTOs
- Implement idempotency using `Idempotency-Key` header
- Add rate limiting for endpoints
- Sanitize error messages (don't expose internal details)

### 15. Documentation Requirements

#### README.md Must Include
1. **Project Overview**: BIAN SD, migration context
2. **Architecture Decision Records (ADRs)**: Why hexagonal, why reactive
3. **Setup Instructions**: Prerequisites, local run, Docker
4. **API Documentation**: Link to Swagger UI, example requests
5. **Testing**: How to run tests, coverage reports
6. **AI Usage**: Summary of prompts and generated code
7. **Quality Gates**: Checkstyle, SpotBugs, JaCoCo results

## Validation Checklist (SOAP to REST Migration)

Before committing code, ensure:

### BIAN Alignment
- [ ] All endpoints follow BIAN naming: `/payment-initiation/payment-orders`
- [ ] PaymentOrder Behavior Qualifier correctly implemented
- [ ] Operations use BIAN verbs (Initiate, Retrieve) not SOAP terms (Submit, Get)
- [ ] `paymentOrderReference` uses format `PO-xxxx` (not generic IDs)
- [ ] All BIAN naming conventions followed (no SOAP field names in REST)

### SOAP Migration
- [ ] All SOAP fields mapped correctly (refer to mapping table in prompts.md)
- [ ] `externalId` → `externalReference` (traceability maintained)
- [ ] IBAN fields wrapped in `Account` objects
- [ ] `amount + currency` → `InstructedAmount` object
- [ ] Status mapping SOAP ↔ BIAN implemented (ACCEPTED → INITIATED, etc.)
- [ ] `paymentOrderId` → `paymentOrderReference` everywhere
- [ ] No SOAP-specific terminology in REST API (checked OpenAPI)

### Architecture
- [ ] Hexagonal architecture (no Spring in domain layer)
- [ ] Domain model is framework-independent (verified imports)
- [ ] Ports defined in domain, implementations in adapters
- [ ] Dependencies point inward (adapter → application → domain)

### Contract-First
- [ ] OpenAPI 3.0 spec complete and validated
- [ ] Interfaces generated with openapi-generator (`./gradlew openApiGenerate`)
- [ ] Controller implements generated interface (not @RequestMapping manually)
- [ ] All DTOs generated from OpenAPI (no hand-written DTOs)

### MapStruct
- [ ] Three mapper types: REST, Persistence, Application
- [ ] `componentModel = "spring"` in all mappers
- [ ] `unmappedTargetPolicy = ReportingPolicy.ERROR` enforced
- [ ] Lombok + MapStruct compatibility configured (`lombok-mapstruct-binding`)
- [ ] No compilation warnings about unmapped fields

### Testing
- [ ] Unit tests for domain layer (value objects, aggregate, services)
- [ ] Unit tests for application services (use case implementations)
- [ ] MapStruct mapper tests (DTO ↔ Domain ↔ Entity)
- [ ] Integration tests with WebTestClient for all 3 endpoints
- [ ] Repository tests with `@DataJpaTest`
- [ ] 80%+ code coverage achieved (check JaCoCo report)
- [ ] All Postman collection scenarios covered in tests

### HTTP Status Codes
- [ ] POST `/payment-orders` returns **201 Created** (not 200)
- [ ] POST includes **Location header** with resource URI
- [ ] GET `/payment-orders/{id}` returns **200 OK**
- [ ] GET `/payment-orders/{id}/status` returns **200 OK**
- [ ] Non-existent resource returns **404 Not Found**
- [ ] Invalid request returns **400 Bad Request**
- [ ] Duplicate `externalReference` returns **409 Conflict**
- [ ] RFC 7807 `application/problem+json` for all errors

### Database (H2)
- [ ] H2 configured correctly (in-memory or file-based)
- [ ] JPA entities with proper annotations
- [ ] `@PrePersist` and `@PreUpdate` for audit fields
- [ ] H2 Console enabled (development profile)
- [ ] Database constraints match domain invariants
- [ ] No sensitive data in logs (IBANs masked if logged)

### Quality Gates
- [ ] `./gradlew check` passes (all quality checks)
- [ ] Checkstyle: zero violations
- [ ] SpotBugs: zero high-priority bugs
- [ ] JaCoCo: ≥80% line coverage
- [ ] All tests pass: `./gradlew test`

### Docker
- [ ] Dockerfile builds successfully: `docker build -t payment-service .`
- [ ] Multi-stage build optimized (separate build and runtime)
- [ ] docker-compose.yml works: `docker-compose up -d`
- [ ] Health check endpoint accessible: `/actuator/health`
- [ ] Application starts in container (check logs)

### Documentation
- [ ] README.md updated with:
  - SOAP to REST migration context
  - BIAN Service Domain explanation
  - Field mapping table (SOAP → BIAN)
  - Setup instructions (local + Docker)
  - API documentation (link to Swagger UI)
  - Testing guide (how to run tests)
- [ ] AI usage documented in `ai/prompts.md`
- [ ] Architectural decisions in `ai/decisions.md`
- [ ] Generated code samples in `ai/generations/`
- [ ] Manual corrections clearly documented

### Postman Validation
- [ ] Import `postman_collection.json` into Postman
- [ ] POST Initiate PaymentOrder works (201 Created)
- [ ] GET Retrieve PaymentOrder works (200 OK)
- [ ] GET Retrieve Status works (200 OK)
- [ ] Response payloads match OpenAPI examples
- [ ] All fields present in responses (no nulls for required fields)

### Code Quality
- [ ] No hardcoded values (use configuration)
- [ ] Proper exception handling (GlobalExceptionHandler)
- [ ] Structured logging (no System.out.println)
- [ ] No sensitive data exposure (PII, credentials)
- [ ] Value objects are immutable (Lombok @Value)
- [ ] Enums used for status (not magic strings)
- [ ] Constants for repeated values

### BIAN-Specific Validations
- [ ] Payment order reference pattern: `^PO-[0-9]{4,}# BIAN Payment Initiation - Java Spring Boot Migration Rules

## Context
You are an expert software architect specialized in banking systems with 10+ years in fintech, migrating legacy SOAP services to REST APIs aligned with BIAN (Banking Industry Architecture Network) standards. This project involves migrating a Payment Order SOAP service to a BIAN-compliant REST microservice.

## SOAP to REST Migration Analysis

### Legacy SOAP Service Analysis
**WSDL**: PaymentOrderService.wsdl
**Operations Identified**:
1. **SubmitPaymentOrder** → Maps to BIAN **Initiate** operation
2. **GetPaymentOrderStatus** → Maps to BIAN **Retrieve Status** operation

### SOAP to BIAN Field Mapping

| SOAP Field | BIAN REST Field | Type | Notes |
|------------|-----------------|------|-------|
| externalId | externalReference | string | Client-provided reference |
| debtorIban | debtorAccount.iban | string | Payer account identifier |
| creditorIban | creditorAccount.iban | string | Payee account identifier |
| amount | instructedAmount.amount | decimal | Payment amount |
| currency | instructedAmount.currency | string | ISO 4217 currency code |
| remittanceInfo | remittanceInformation | string | Payment purpose/description |
| requestedExecutionDate | requestedExecutionDate | date | ISO 8601 date format |
| paymentOrderId | paymentOrderReference | string | BIAN-compliant reference (PO-xxxx) |
| status | paymentOrderStatus | enum | SOAP: ACCEPTED, SETTLED, REJECTED<br>BIAN: INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED |
| lastUpdate | lastUpdated | datetime | ISO 8601 datetime format |

### Status Mapping Strategy

```java
// SOAP Legacy Status → BIAN Status
ACCEPTED    → INITIATED
PENDING     → PENDING
PROCESSING  → PROCESSED
SETTLED     → COMPLETED
REJECTED    → FAILED
CANCELLED   → CANCELLED
```

### Key Migration Decisions
1. **externalId** becomes **externalReference** (keeps external system traceability)
2. **IBAN** fields wrapped in account objects for better structure
3. **amount + currency** combined into **instructedAmount** object (ISO 20022 compliant)
4. **paymentOrderId** renamed to **paymentOrderReference** (BIAN naming)
5. Status values normalized to BIAN lifecycle
6. Added missing fields required by BIAN (createdAt, updatedAt)

## Project Specifications
- **BIAN Service Domain**: Payment Initiation
- **Behavior Qualifier**: PaymentOrder
- **Migration**: SOAP (legacy) → REST (BIAN-aligned)
- **Architecture**: Hexagonal (Ports & Adapters)
- **Approach**: Contract-First with OpenAPI 3.0
- **Stack**: Java 17+, Spring Boot 3+, Spring MVC, H2 Database, Gradle, MapStruct

## Core Principles

### 1. BIAN Alignment (Critical)
- **Service Domain Naming**: Always use `payment-initiation` as the base path
- **Behavior Qualifier**: PaymentOrder is the main BQ
- **Resource Naming**: Use BIAN nomenclature
  - Control Record (CR): PaymentOrder instance
  - Use `cr-reference-id` for the main resource identifier
- **Standard Operations**: Follow BIAN service operations
  - `Initiate`: POST to create new payment order
  - `Retrieve`: GET to fetch payment order or status
  - `Update`: PUT/PATCH to modify (if needed)
  - `Execute`: POST to trigger execution (if applicable)

### 2. API Design Patterns

#### Endpoint Structure (Based on Postman Collection)
```
POST   /payment-initiation/payment-orders              # Initiate (was: SubmitPaymentOrder)
GET    /payment-initiation/payment-orders/{id}         # Retrieve (new in BIAN)
GET    /payment-initiation/payment-orders/{id}/status  # Retrieve Status (was: GetPaymentOrderStatus)
```

**Important**: The `{id}` parameter is the **paymentOrderReference** (e.g., "PO-0001"), NOT a UUID.

#### Request/Response Standards (From SOAP Migration)
- Use RFC 7807 (`application/problem+json`) for errors
- Follow BIAN JSON schema conventions aligned with SOAP fields:
  ```json
  {
    "externalReference": "EXT-1",
    "debtorAccount": {
      "iban": "EC12DEBTOR"
    },
    "creditorAccount": {
      "iban": "EC98CREDITOR"
    },
    "instructedAmount": {
      "amount": 150.75,
      "currency": "USD"
    },
    "remittanceInformation": "Factura 001-123",
    "requestedExecutionDate": "2025-10-31",
    "paymentOrderReference": "PO-0001",
    "paymentOrderStatus": "INITIATED"
  }
  ```

#### HTTP Status Codes (BIAN-aligned)
- `201 Created`: Successful Initiate (POST new resource)
- `200 OK`: Successful Retrieve (GET), Update (PUT/PATCH), or Execute
- `204 No Content`: Successful DELETE or operation with no response body
- `400 Bad Request`: Validation errors, malformed request
- `404 Not Found`: Resource not found
- `409 Conflict`: Idempotency violation, business rule conflict
- `422 Unprocessable Entity`: Semantic errors (valid format, invalid business logic)
- `500 Internal Server Error`: System errors, unexpected failures
- `503 Service Unavailable`: Temporary service issues

### 3. Hexagonal Architecture (Mandatory)

#### Package Structure (Updated with SOAP Migration Context)
```
com.hiberus.banking.payment
├── domain/                          # Core business logic (framework-independent)
│   ├── model/
│   │   ├── PaymentOrder.java       # Aggregate root
│   │   ├── Account.java            # Value object (IBAN holder)
│   │   ├── InstructedAmount.java   # Value object (amount + currency)
│   │   ├── PaymentStatus.java      # Enum (BIAN lifecycle)
│   │   ├── ExternalReference.java  # Value object (from SOAP externalId)
│   │   └── PaymentOrderReference.java  # Value object (PO-xxxx format)
│   ├── port/
│   │   ├── in/                     # Input ports (use cases)
│   │   │   ├── InitiatePaymentOrderUseCase.java
│   │   │   ├── RetrievePaymentOrderUseCase.java
│   │   │   └── RetrievePaymentOrderStatusUseCase.java
│   │   └── out/                    # Output ports (repositories, external services)
│   │       ├── PaymentOrderRepository.java
│   │       ├── PaymentValidationPort.java
│   │       └── LegacySoapPort.java  # Optional: for hybrid transition
│   ├── exception/
│   │   ├── PaymentOrderNotFoundException.java
│   │   ├── InvalidPaymentException.java
│   │   ├── DuplicateExternalReferenceException.java
│   │   └── DomainException.java
│   └── service/                    # Domain services
│       ├── PaymentOrderDomainService.java
│       └── StatusMappingService.java  # SOAP → BIAN status mapping
├── application/                     # Application services (orchestration)
│   ├── service/
│   │   ├── InitiatePaymentOrderService.java
│   │   ├── RetrievePaymentOrderService.java
│   │   └── RetrievePaymentOrderStatusService.java
│   └── mapper/
│       ├── PaymentOrderMapper.java              # MapStruct interface
│       └── PaymentOrderMapperImpl.java          # Generated by MapStruct
├── adapter/                         # Adapters (infrastructure)
│   ├── in/
│   │   ├── rest/
│   │   │   ├── PaymentInitiationController.java
│   │   │   ├── dto/               # Generated from OpenAPI
│   │   │   │   ├── InitiatePaymentOrderRequest.java
│   │   │   │   ├── InitiatePaymentOrderResponse.java
│   │   │   │   ├── RetrievePaymentOrderResponse.java
│   │   │   │   ├── PaymentOrderStatusResponse.java
│   │   │   │   ├── AccountDto.java
│   │   │   │   └── InstructedAmountDto.java
│   │   │   └── mapper/
│   │   │       └── PaymentOrderRestMapper.java  # MapStruct for DTO ↔ Domain
│   │   └── config/
│   │       └── OpenApiConfig.java
│   └── out/
│       ├── persistence/
│       │   ├── PaymentOrderRepositoryAdapter.java
│       │   ├── entity/
│       │   │   └── PaymentOrderEntity.java
│       │   ├── jpa/
│       │   │   └── PaymentOrderJpaRepository.java  # Spring Data JPA
│       │   └── mapper/
│       │       └── PaymentOrderPersistenceMapper.java  # MapStruct for Entity ↔ Domain
│       └── legacy/
│           └── SoapClientAdapter.java  # Optional: backward compatibility
└── config/                          # Spring configuration
    ├── WebMvcConfig.java
    ├── JpaConfig.java
    ├── H2ConsoleConfig.java
    └── SecurityConfig.java
```

#### Key Rules
- **Domain Layer**: NEVER import Spring or framework-specific annotations
- **Ports**: Define interfaces in domain layer, implement in adapters
- **Dependencies**: Always point inward (adapter → application → domain)
- **Value Objects**: Immutable, validation in constructor
- **Aggregates**: PaymentOrder is the aggregate root, enforce invariants
- **MapStruct**: Use in application and adapter layers, NEVER in domain

### 4. Contract-First Development (SOAP to REST Migration)

#### OpenAPI Generation with Gradle (Based on SOAP Analysis)
```yaml
# openapi.yaml structure - Migrated from PaymentOrderService.wsdl
openapi: 3.0.3
info:
  title: BIAN Payment Initiation API
  version: 1.0.0
  description: |
    Payment Order management aligned with BIAN Service Domain.
    Migrated from legacy SOAP service (PaymentOrderService.wsdl).
    
    **Migration mapping**:
    - SubmitPaymentOrder (SOAP) → POST /payment-orders (REST Initiate)
    - GetPaymentOrderStatus (SOAP) → GET /payment-orders/{id}/status (REST Retrieve)
    - Added: GET /payment-orders/{id} (Full retrieve - BIAN standard)

servers:
  - url: http://localhost:8080
    description: Local development server

paths:
  /payment-initiation/payment-orders:
    post:
      operationId: initiatePaymentOrder
      tags: [Payment Initiation]
      summary: Initiate a new payment order
      description: |
        Initiates a payment order (BIAN Initiate operation).
        Equivalent to SOAP SubmitPaymentOrder operation.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InitiatePaymentOrderRequest'
            examples:
              standard:
                summary: Standard payment order
                value:
                  externalReference: "EXT-1"
                  debtorAccount:
                    iban: "EC12DEBTOR"
                  creditorAccount:
                    iban: "EC98CREDITOR"
                  instructedAmount:
                    amount: 150.75
                    currency: "USD"
                  remittanceInformation: "Factura 001-123"
                  requestedExecutionDate: "2025-10-31"
      responses:
        '201':
          description: Payment order successfully initiated
          headers:
            Location:
              description: URI of the created payment order
              schema:
                type: string
                example: "/payment-initiation/payment-orders/PO-0001"
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InitiatePaymentOrderResponse'
              examples:
                success:
                  summary: Successful initiation
                  value:
                    paymentOrderReference: "PO-0001"
                    paymentOrderStatus: "INITIATED"
                    externalReference: "EXT-1"
                    debtorAccount:
                      iban: "EC12DEBTOR"
                    creditorAccount:
                      iban: "EC98CREDITOR"
                    instructedAmount:
                      amount: 150.75
                      currency: "USD"
                    createdAt: "2025-10-30T10:00:00Z"
        '400':
          $ref: '#/components/responses/BadRequest'
        '409':
          description: Conflict - Duplicate external reference
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/ProblemDetail'
        '500':
          $ref: '#/components/responses/InternalServerError'
  
  /payment-initiation/payment-orders/{id}:
    get:
      operationId: retrievePaymentOrder
      tags: [Payment Initiation]
      summary: Retrieve complete payment order details
      description: |
        Retrieves full payment order information (BIAN Retrieve operation).
        This is a new endpoint not present in legacy SOAP service.
      parameters:
        - $ref: '#/components/parameters/PaymentOrderId'
      responses:
        '200':
          description: Payment order retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RetrievePaymentOrderResponse'
              examples:
                completed:
                  summary: Completed payment order
                  value:
                    paymentOrderReference: "PO-0001"
                    paymentOrderStatus: "COMPLETED"
                    externalReference: "EXT-1"
                    debtorAccount:
                      iban: "EC12DEBTOR"
                    creditorAccount:
                      iban: "EC98CREDITOR"
                    instructedAmount:
                      amount: 150.75
                      currency: "USD"
                    remittanceInformation: "Factura 001-123"
                    requestedExecutionDate: "2025-10-31"
                    createdAt: "2025-10-30T10:00:00Z"
                    updatedAt: "2025-10-30T16:25:30Z"
        '404':
          $ref: '#/components/responses/NotFound'
  
  /payment-initiation/payment-orders/{id}/status:
    get:
      operationId: retrievePaymentOrderStatus
      tags: [Payment Initiation]
      summary: Retrieve payment order status
      description: |
        Retrieves payment order status (BIAN Retrieve Status).
        Equivalent to SOAP GetPaymentOrderStatus operation.
      parameters:
        - $ref: '#/components/parameters/PaymentOrderId'
      responses:
        '200':
          description: Payment order status retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentOrderStatusResponse'
              examples:
                settled:
                  summary: Settled payment (SOAP: SETTLED → BIAN: COMPLETED)
                  value:
                    paymentOrderReference: "PO-0001"
                    paymentOrderStatus: "COMPLETED"
                    statusReason: "Payment successfully completed"
                    lastUpdated: "2025-10-30T16:25:30Z"
        '404':
          $ref: '#/components/responses/NotFound'

components:
  parameters:
    PaymentOrderId:
      name: id
      in: path
      required: true
      description: Payment Order Reference (format PO-xxxx)
      schema:
        type: string
        pattern: '^PO-[0-9]{4,}
```yaml
# openapi.yaml structure
openapi: 3.0.3
info:
  title: BIAN Payment Initiation API
  version: 1.0.0
  description: Payment Order management aligned with BIAN Service Domain

servers:
  - url: http://localhost:8080
    description: Local development server

paths:
  /payment-initiation/payment-orders:
    post:
      operationId: initiatePaymentOrder
      tags: [Payment Initiation]
      summary: Initiate a new payment order
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InitiatePaymentOrderRequest'
      responses:
        '201':
          description: Payment order successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InitiatePaymentOrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '500':
          $ref: '#/components/responses/InternalServerError'
  
  /payment-initiation/payment-orders/{id}:
    get:
      operationId: retrievePaymentOrder
      tags: [Payment Initiation]
      summary: Retrieve payment order details
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RetrievePaymentOrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /payment-initiation/payment-orders/{id}/status:
    get:
      operationId: retrievePaymentOrderStatus
      tags: [Payment Initiation]
      summary: Retrieve payment order status
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order status retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentOrderStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    InitiatePaymentOrderRequest:
      type: object
      required: 
        - payerReference
        - payeeReference
        - amount
      properties:
        payerReference:
          type: string
          description: Reference to the payer (customer ID)
          example: "CUST-12345"
        payeeReference:
          type: string
          description: Reference to the payee (beneficiary ID)
          example: "CUST-67890"
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
          description: Purpose of the payment
          example: "Invoice payment"
        paymentDate:
          type: string
          format: date
          description: Requested payment date
          example: "2024-11-20"
    
    InitiatePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
          description: BIAN-compliant payment order reference
          example: "PO-2024-001234"
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        createdAt:
          type: string
          format: date-time
    
    RetrievePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
        paymentDate:
          type: string
          format: date
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    PaymentOrderStatusResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        statusReason:
          type: string
          description: Reason for current status
        lastUpdated:
          type: string
          format: date-time
    
    PaymentAmount:
      type: object
      required:
        - value
        - currency
      properties:
        value:
          type: number
          format: double
          minimum: 0.01
          example: 1500.50
        currency:
          type: string
          enum: [USD, EUR, GBP, JPY]
          example: "USD"
    
    ProblemDetail:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request - validation errors
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    NotFound:
      description: Resource not found
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    InternalServerError:
      description: Internal server error
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
```

#### Gradle Configuration (build.gradle)
```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'org.openapi.generator' version '7.0.1'
    id 'checkstyle'
    id 'com.github.spotbugs' version '6.0.0'
    id 'jacoco'
}

group = 'com.hiberus.banking'
version = '1.0.0'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

ext {
    mapstructVersion = '1.5.5.Final'
    lombokVersion = '1.18.30'
    openApiVersion = '2.2.0'
}

dependencies {
    // Spring Boot Starters
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    
    // H2 Database
    runtimeOnly 'com.h2database:h2'
    
    // OpenAPI
    implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${openApiVersion}"
    
    // MapStruct
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
    
    // Lombok
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    
    // Lombok + MapStruct compatibility
    annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"
    
    // Testing
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-webflux'  // For WebTestClient
    testImplementation 'io.rest-assured:rest-assured:5.4.0'
    testImplementation 'org.assertj:assertj-core'
    
    // Test Lombok
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
}

// OpenAPI Generator Task
openApiGenerate {
    generatorName = 'spring'
    inputSpec = "$projectDir/src/main/resources/openapi.yaml"
    outputDir = "$buildDir/generated"
    apiPackage = 'com.hiberus.banking.payment.adapter.in.rest.api'
    modelPackage = 'com.hiberus.banking.payment.adapter.in.rest.dto'
    invokerPackage = 'com.hiberus.banking.payment.adapter.in.rest.invoker'
    configOptions = [
        interfaceOnly: 'true',
        useSpringBoot3: 'true',
        useTags: 'true',
        dateLibrary: 'java8',
        serializationLibrary: 'jackson',
        hideGenerationTimestamp: 'true'
    ]
}

// Add generated sources to source sets
sourceSets {
    main {
        java {
            srcDirs += "$buildDir/generated/src/main/java"
        }
    }
}

// Compile depends on generation
compileJava.dependsOn tasks.openApiGenerate

// JaCoCo Configuration
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
    }
}

// Checkstyle Configuration
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
}

// SpotBugs Configuration
spotbugs {
    effort = 'max'
    reportLevel = 'high'
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
        }
        xml {
            required = false
        }
    }
}

// Test Configuration
test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

// Build task order
check.dependsOn jacocoTestCoverageVerification
```

#### Controller Implementation (Spring MVC)
```java
@RestController
@RequiredArgsConstructor
@Slf4j
public class PaymentInitiationController implements PaymentInitiationApi {
    
    private final InitiatePaymentOrderUseCase initiateUseCase;
    private final RetrievePaymentOrderUseCase retrieveUseCase;
    private final RetrievePaymentOrderStatusUseCase retrieveStatusUseCase;
    private final PaymentOrderRestMapper mapper;
    
    @Override
    public ResponseEntity<InitiatePaymentOrderResponse> initiatePaymentOrder(
            InitiatePaymentOrderRequest request) {
        
        log.info("Initiating payment order for payer: {}", request.getPayerReference());
        
        PaymentOrder domainOrder = mapper.toDomain(request);
        PaymentOrder initiatedOrder = initiateUseCase.initiate(domainOrder);
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(initiatedOrder);
        
        log.info("Payment order initiated successfully: {}", response.getPaymentOrderReference());
        
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(response);
    }
    
    @Override
    public ResponseEntity<RetrievePaymentOrderResponse> retrievePaymentOrder(String id) {
        
        log.info("Retrieving payment order: {}", id);
        
        PaymentOrder paymentOrder = retrieveUseCase.retrieve(id);
        RetrievePaymentOrderResponse response = mapper.toRetrieveResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
    
    @Override
    public ResponseEntity<PaymentOrderStatusResponse> retrievePaymentOrderStatus(String id) {
        
        log.info("Retrieving payment order status: {}", id);
        
        PaymentOrder paymentOrder = retrieveStatusUseCase.retrieveStatus(id);
        PaymentOrderStatusResponse response = mapper.toStatusResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
}
```

### 5. Spring MVC with H2 Database

#### Application Configuration (application.yml)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 Database Configuration
  datasource:
    url: jdbc:h2:mem:paymentdb
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: false
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
  
  # Jackson Configuration
  jackson:
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

# Server Configuration
server:
  port: 8080
  servlet:
    context-path: /
  error:
    include-message: always
    include-binding-errors: always
    include-exception: false
    include-stacktrace: never

# Management / Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    tags:
      application: ${spring.application.name}
      service-domain: payment-initiation

# Logging
logging:
  level:
    com.hiberus.banking: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

#### JPA Entity Example
```java
@Entity
@Table(name = "payment_orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PaymentOrderEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(name = "payment_order_reference", nullable = false, unique = true, length = 50)
    private String paymentOrderReference;
    
    @Column(name = "payer_reference", nullable = false, length = 50)
    private String payerReference;
    
    @Column(name = "payee_reference", nullable = false, length = 50)
    private String payeeReference;
    
    @Column(name = "amount", nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "currency", nullable = false, length = 3)
    private String currency;
    
    @Column(name = "payment_purpose", length = 255)
    private String paymentPurpose;
    
    @Column(name = "payment_date")
    private LocalDate paymentDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PaymentStatusEntity status;
    
    @Column(name = "status_reason", length = 500)
    private String statusReason;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        if (status == null) {
            status = PaymentStatusEntity.INITIATED;
        }
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

@Getter
@RequiredArgsConstructor
enum PaymentStatusEntity {
    INITIATED("Payment order has been initiated"),
    PENDING("Payment order is pending processing"),
    PROCESSED("Payment order has been processed"),
    COMPLETED("Payment order completed successfully"),
    FAILED("Payment order failed"),
    CANCELLED("Payment order has been cancelled");
    
    private final String description;
}
```

#### Spring Data JPA Repository
```java
@Repository
public interface PaymentOrderJpaRepository extends JpaRepository<PaymentOrderEntity, UUID> {
    
    Optional<PaymentOrderEntity> findByPaymentOrderReference(String paymentOrderReference);
    
    List<PaymentOrderEntity> findByPayerReference(String payerReference);
    
    List<PaymentOrderEntity> findByStatus(PaymentStatusEntity status);
    
    @Query("SELECT p FROM PaymentOrderEntity p WHERE p.createdAt BETWEEN :startDate AND :endDate")
    List<PaymentOrderEntity> findByDateRange(
        @Param("startDate") LocalDateTime startDate, 
        @Param("endDate") LocalDateTime endDate
    );
    
    boolean existsByPaymentOrderReference(String paymentOrderReference);
}
```

#### Repository Adapter Implementation
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PaymentOrderRepositoryAdapter implements PaymentOrderRepository {
    
    private final PaymentOrderJpaRepository jpaRepository;
    private final PaymentOrderPersistenceMapper persistenceMapper;
    
    @Override
    public PaymentOrder save(PaymentOrder paymentOrder) {
        log.debug("Saving payment order: {}", paymentOrder.getPaymentOrderReference());
        
        PaymentOrderEntity entity = persistenceMapper.toEntity(paymentOrder);
        PaymentOrderEntity savedEntity = jpaRepository.save(entity);
        
        log.debug("Payment order saved with ID: {}", savedEntity.getId());
        return persistenceMapper.toDomain(savedEntity);
    }
    
    @Override
    public Optional<PaymentOrder> findByReference(String paymentOrderReference) {
        log.debug("Finding payment order by reference: {}", paymentOrderReference);
        
        return jpaRepository.findByPaymentOrderReference(paymentOrderReference)
            .map(persistenceMapper::toDomain);
    }
    
    @Override
    public boolean existsByReference(String paymentOrderReference) {
        return jpaRepository.existsByPaymentOrderReference(paymentOrderReference);
    }
    
    @Override
    public List<PaymentOrder> findAll() {
        return jpaRepository.findAll().stream()
            .map(persistenceMapper::toDomain)
            .collect(Collectors.toList());
    }
}
```

#### H2 Console Configuration
```java
@Configuration
public class H2ConsoleConfig {
    
    @Bean
    public ServletRegistrationBean<WebServlet> h2Console() {
        ServletRegistrationBean<WebServlet> registration = 
            new ServletRegistrationBean<>(new WebServlet());
        registration.addUrlMappings("/h2-console/*");
        return registration;
    }
}
```

#### Data Initialization (Optional - for testing)
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class DataInitializer {
    
    private final PaymentOrderJpaRepository repository;
    
    @EventListener(ApplicationReadyEvent.class)
    public void loadSampleData() {
        if (repository.count() == 0) {
            log.info("Loading sample payment orders...");
            
            PaymentOrderEntity order1 = PaymentOrderEntity.builder()
                .paymentOrderReference("PO-2024-001")
                .payerReference("CUST-12345")
                .payeeReference("CUST-67890")
                .amount(new BigDecimal("1500.50"))
                .currency("USD")
                .paymentPurpose("Invoice payment")
                .paymentDate(LocalDate.now())
                .status(PaymentStatusEntity.INITIATED)
                .build();
            
            repository.save(order1);
            log.info("Sample data loaded successfully");
        }
    }
}
```

### 6. MapStruct Mappers (Three Layers)

MapStruct is used for clean transformation between layers. There are THREE types of mappers:

#### 1. REST Mapper (Adapter Layer: DTO ↔ Domain)
```java
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR)
public interface PaymentOrderRestMapper {
    
    // Request DTO → Domain
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "paymentOrderReference", ignore = true)
    @Mapping(target = "status", constant = "INITIATED")
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    @Mapping(target = "updatedAt", ignore = true)
    PaymentOrder toDomain(InitiatePaymentOrderRequest request);
    
    // Domain → Response DTO (Initiate)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    InitiatePaymentOrderResponse toInitiateResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Retrieve)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    RetrievePaymentOrderResponse toRetrieveResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Status)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    @Mapping(source = "updatedAt", target = "lastUpdated")
    PaymentOrderStatusResponse toStatusResponse(PaymentOrder paymentOrder);
    
    // Value Object mappings
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    PaymentAmount toPaymentAmount(com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount dtoAmount);
    
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount toPaymentAmountDto(PaymentAmount domainAmount);
}
```

#### 2. Persistence Mapper (Adapter Layer: Domain ↔ Entity)
```java
@Mapper(componentModel = "spring", 
        unmappedTargetPolicy = ReportingPolicy.ERROR,
        uses = {PaymentStatusMapper.class})
public interface PaymentOrderPersistenceMapper {
    
    // Domain → Entity
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "payerReference.value", target = "payerReference")
    @Mapping(source = "payeeReference.value", target = "payeeReference")
    @Mapping(source = "amount.value", target = "amount")
    @Mapping(source = "amount.currency", target = "currency")
    @Mapping(source = "status", target = "status")
    @Mapping(target = "id", ignore = true)  // Let JPA generate
    PaymentOrderEntity toEntity(PaymentOrder domain);
    
    // Entity → Domain
    @Mapping(source = "paymentOrderReference", target = "id.value")
    @Mapping(source = "payerReference", target = "payerReference.value")
    @Mapping(source = "payeeReference", target = "payeeReference.value")
    @Mapping(source = "amount", target = "amount.value")
    @Mapping(source = "currency", target = "amount.currency")
    PaymentOrder toDomain(PaymentOrderEntity entity);
    
    // Custom mapping for status
    default PaymentStatus mapStatus(PaymentStatusEntity entityStatus) {
        return PaymentStatus.valueOf(entityStatus.name());
    }
    
    default PaymentStatusEntity mapStatus(PaymentStatus domainStatus) {
        return PaymentStatusEntity.valueOf(domainStatus.name());
    }
}
```

#### 3. Application Mapper (Optional: Complex transformations)
```java
@Mapper(componentModel = "spring")
public interface PaymentOrderApplicationMapper {
    
    // For complex business logic transformations
    @Mapping(target = "enrichedData", expression = "java(enrichData(source))")
    PaymentOrder enrichForProcessing(PaymentOrder source);
    
    default String enrichData(PaymentOrder order) {
        // Complex business logic here
        return "ENRICHED-" + order.getPaymentOrderReference();
    }
}
```

#### MapStruct Configuration Best Practices
```java
@MapperConfig(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.ERROR,  // Fail on unmapped fields
    unmappedSourcePolicy = ReportingPolicy.WARN,    // Warn on unmapped sources
    mappingInheritanceStrategy = MappingInheritanceStrategy.AUTO_INHERIT_FROM_CONFIG
)
public interface CentralMapperConfig {
}

// Then use it in mappers
@Mapper(config = CentralMapperConfig.class)
public interface PaymentOrderRestMapper {
    // ... mappings
}
```

#### Testing MapStruct Mappers
```java
@SpringBootTest
class PaymentOrderRestMapperTest {
    
    @Autowired
    private PaymentOrderRestMapper mapper;
    
    @Test
    @DisplayName("Should map InitiatePaymentOrderRequest to PaymentOrder domain")
    void shouldMapRequestToDomain() {
        // Given
        InitiatePaymentOrderRequest request = new InitiatePaymentOrderRequest()
            .payerReference("CUST-123")
            .payeeReference("CUST-456")
            .amount(new com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount()
                .value(1000.0)
                .currency("USD"))
            .paymentPurpose("Test payment");
        
        // When
        PaymentOrder domain = mapper.toDomain(request);
        
        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getPayerReference().getValue()).isEqualTo("CUST-123");
        assertThat(domain.getPayeeReference().getValue()).isEqualTo("CUST-456");
        assertThat(domain.getAmount().getValue()).isEqualByComparingTo("1000.0");
        assertThat(domain.getAmount().getCurrency()).isEqualTo(Currency.USD);
        assertThat(domain.getStatus()).isEqualTo(PaymentStatus.INITIATED);
    }
    
    @Test
    @DisplayName("Should map PaymentOrder domain to InitiatePaymentOrderResponse")
    void shouldMapDomainToResponse() {
        // Given
        PaymentOrder domain = PaymentOrderMother.valid();
        
        // When
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(domain);
        
        // Then
        assertThat(response).isNotNull();
        assertThat(response.getPaymentOrderReference()).isEqualTo(domain.getId().getValue());
        assertThat(response.getPaymentOrderStatus()).isEqualTo(domain.getStatus().name());
    }
}
```

### 7. Testing Strategy with Spring MVC and WebTestClient

#### Unit Tests (Domain & Application Layer)
```java
@ExtendWith(MockitoExtension.class)
class InitiatePaymentOrderServiceTest {
    
    @Mock
    private PaymentOrderRepository repository;
    
    @Mock
    private PaymentValidationPort validationPort;
    
    @InjectMocks
    private InitiatePaymentOrderService service;
    
    @Test
    @DisplayName("Should initiate payment order when valid")
    void shouldInitiatePaymentOrderWhenValid() {
        // Given
        PaymentOrder order = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenReturn(order);
        
        // When
        PaymentOrder result = service.initiate(order);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getStatus()).isEqualTo(PaymentStatus.INITIATED);
        assertThat(result.getPaymentOrderReference()).isNotNull();
        
        verify(validationPort).validate(order);
        verify(repository).save(any(PaymentOrder.class));
    }
    
    @Test
    @DisplayName("Should throw InvalidPaymentException when validation fails")
    void shouldThrowExceptionWhenValidationFails() {
        // Given
        PaymentOrder order = PaymentOrderMother.withInvalidAmount();
        when(validationPort.validate(any())).thenReturn(false);
        
        // When & Then
        assertThatThrownBy(() -> service.initiate(order))
            .isInstanceOf(InvalidPaymentException.class)
            .hasMessageContaining("validation failed");
        
        verify(validationPort).validate(order);
        verify(repository, never()).save(any());
    }
    
    @Test
    @DisplayName("Should generate unique payment order reference")
    void shouldGenerateUniqueReference() {
        // Given
        PaymentOrder order1 = PaymentOrderMother.valid();
        PaymentOrder order2 = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenAnswer(inv -> inv.getArgument(0));
        
        // When
        PaymentOrder result1 = service.initiate(order1);
        PaymentOrder result2 = service.initiate(order2);
        
        // Then
        assertThat(result1.getPaymentOrderReference())
            .isNotEqualTo(result2.getPaymentOrderReference());
    }
}
```

#### Integration Tests with WebTestClient (Recommended for Spring MVC)
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class PaymentInitiationIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        repository.deleteAll();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 201 Created")
    void shouldInitiatePaymentOrderSuccessfully() {
        // Given
        InitiatePaymentOrderRequest request = InitiatePaymentOrderRequest.builder()
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1500.50)
                .currency("USD")
                .build())
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .build();
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .exchange()
            .expectStatus().isCreated()
            .expectHeader().exists("Location")
            .expectBody(InitiatePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getPaymentOrderReference()).startsWith("PO-");
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getPayeeReference()).isEqualTo("CUST-67890");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
                assertThat(response.getCreatedAt()).isNotNull();
            });
        
        // Verify database
        assertThat(repository.count()).isEqualTo(1);
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 200 OK")
    void shouldRetrievePaymentOrderSuccessfully() {
        // Given - Create a payment order first
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(RetrievePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id}/status - Should return 200 OK")
    void shouldRetrievePaymentOrderStatusSuccessfully() {
        // Given
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}/status", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(PaymentOrderStatusResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getLastUpdated()).isNotNull();
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 404 Not Found")
    void shouldReturn404WhenPaymentOrderNotFound() {
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", "NON-EXISTENT")
            .exchange()
            .expectStatus().isNotFound()
            .expectBody()
            .jsonPath("$.title").isEqualTo("Payment Order Not Found")
            .jsonPath("$.status").isEqualTo(404)
            .jsonPath("$.detail").exists();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 400 Bad Request for invalid data")
    void shouldReturn400ForInvalidRequest() {
        // Given - Invalid request (missing required fields)
        String invalidRequest = """
            {
                "payerReference": "CUST-123"
            }
            """;
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(invalidRequest)
            .exchange()
            .expectStatus().isBadRequest()
            .expectBody()
            .jsonPath("$.title").exists()
            .jsonPath("$.status").isEqualTo(400);
    }
    
    @Test
    @DisplayName("Should handle concurrent payment order creation")
    void shouldHandleConcurrentCreation() throws Exception {
        // Given
        int numberOfThreads = 5;
        ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);
        CountDownLatch latch = new CountDownLatch(numberOfThreads);
        
        // When
        for (int i = 0; i < numberOfThreads; i++) {
            final int index = i;
            executorService.submit(() -> {
                try {
                    InitiatePaymentOrderRequest request = createRequest("PAYER-" + index);
                    webTestClient.post()
                        .uri("/payment-initiation/payment-orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(request)
                        .exchange()
                        .expectStatus().isCreated();
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(10, TimeUnit.SECONDS);
        executorService.shutdown();
        
        // Then
        assertThat(repository.count()).isEqualTo(numberOfThreads);
    }
    
    // Helper methods
    private PaymentOrderEntity createSampleEntity() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-TEST-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Test payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
    
    private InitiatePaymentOrderRequest createRequest(String payerRef) {
        return InitiatePaymentOrderRequest.builder()
            .payerReference(payerRef)
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1000.0)
                .currency("USD")
                .build())
            .paymentPurpose("Concurrent test")
            .build();
    }
}
```

#### Alternative: REST Assured for Integration Tests
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class PaymentInitiationRestAssuredTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        RestAssured.basePath = "/payment-initiation";
        repository.deleteAll();
    }
    
    @Test
    void shouldInitiatePaymentOrder() {
        given()
            .contentType(ContentType.JSON)
            .body(createValidRequest())
        .when()
            .post("/payment-orders")
        .then()
            .statusCode(201)
            .body("paymentOrderReference", notNullValue())
            .body("paymentOrderStatus", equalTo("INITIATED"))
            .body("amount.value", equalTo(1500.50f))
            .body("amount.currency", equalTo("USD"));
    }
    
    @Test
    void shouldRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity saved = repository.save(createSampleEntity());
        
        // When & Then
        given()
            .pathParam("id", saved.getPaymentOrderReference())
        .when()
            .get("/payment-orders/{id}")
        .then()
            .statusCode(200)
            .body("paymentOrderReference", equalTo(saved.getPaymentOrderReference()))
            .body("paymentOrderStatus", equalTo("INITIATED"));
    }
}
```

#### Test Data Builders (Object Mother Pattern)
```java
public class PaymentOrderMother {
    
    public static PaymentOrder valid() {
        return PaymentOrder.builder()
            .id(PaymentOrderId.generate())
            .payerReference(PayerReference.of("CUST-12345"))
            .payeeReference(PayeeReference.of("CUST-67890"))
            .amount(PaymentAmount.of(1500.50, Currency.USD))
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatus.INITIATED)
            .createdAt(LocalDateTime.now())
            .build();
    }
    
    public static PaymentOrder withInvalidAmount() {
        return valid().toBuilder()
            .amount(PaymentAmount.of(-100.00, Currency.USD))
            .build();
    }
    
    public static PaymentOrder withStatus(PaymentStatus status) {
        return valid().toBuilder()
            .status(status)
            .build();
    }
    
    public static PaymentOrder pending() {
        return withStatus(PaymentStatus.PENDING);
    }
    
    public static PaymentOrder completed() {
        return withStatus(PaymentStatus.COMPLETED);
    }
}

public class PaymentOrderEntityMother {
    
    public static PaymentOrderEntity valid() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
}
```

#### Repository Tests
```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class PaymentOrderJpaRepositoryTest {
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    @DisplayName("Should save and retrieve payment order")
    void shouldSaveAndRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity entity = PaymentOrderEntityMother.valid();
        
        // When
        PaymentOrderEntity saved = repository.save(entity);
        entityManager.flush();
        entityManager.clear();
        
        // Then
        Optional<PaymentOrderEntity> found = repository.findByPaymentOrderReference(
            saved.getPaymentOrderReference()
        );
        
        assertThat(found).isPresent();
        assertThat(found.get().getPayerReference()).isEqualTo("CUST-12345");
        assertThat(found.get().getAmount()).isEqualByComparingTo("1500.50");
    }
    
    @Test
    @DisplayName("Should find payment orders by status")
    void shouldFindByStatus() {
        // Given
        repository.save(PaymentOrderEntityMother.valid());
        repository.save(PaymentOrderEntityMother.valid().toBuilder()
            .paymentOrderReference("PO-2024-002")
            .status(PaymentStatusEntity.COMPLETED)
            .build());
        entityManager.flush();
        
        // When
        List<PaymentOrderEntity> initiated = repository.findByStatus(PaymentStatusEntity.INITIATED);
        List<PaymentOrderEntity> completed = repository.findByStatus(PaymentStatusEntity.COMPLETED);
        
        // Then
        assertThat(initiated).hasSize(1);
        assertThat(completed).hasSize(1);
    }
}
```

### 8. Quality Gates (Mandatory - Gradle)

#### JaCoCo Configuration (Gradle)
```groovy
// build.gradle
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                '**/dto/**',
                '**/entity/**',
                '**/config/**',
                '**/*Application.class',
                '**/*MapperImpl.class'  // Exclude MapStruct generated classes
            ])
        }))
    }
}

jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
        
        rule {
            element = 'CLASS'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.70
            }
            excludes = [
                '*.dto.*',
                '*.entity.*',
                '*.config.*',
                '*Application',
                '*MapperImpl'
            ]
        }
    }
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

check.dependsOn jacocoTestCoverageVerification
```

#### Checkstyle Configuration (Gradle)
```groovy
// build.gradle
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
    configProperties = [
        'checkstyle.suppressions.file': "${project.rootDir}/config/checkstyle/suppressions.xml"
    ]
}

checkstyleMain {
    source = 'src/main/java'
    exclude '**/dto/**', '**/entity/**'  // Exclude generated code
}

checkstyleTest {
    source = 'src/test/java'
}

tasks.withType(Checkstyle) {
    reports {
        xml.required = true
        html.required = true
    }
}
```

#### config/checkstyle/checkstyle.xml
```xml
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
    "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
    "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <property name="charset" value="UTF-8"/>
    <property name="severity" value="error"/>
    <property name="fileExtensions" value="java"/>
    
    <module name="SuppressionFilter">
        <property name="file" value="${checkstyle.suppressions.file}"/>
    </module>
    
    <module name="TreeWalker">
        <!-- Naming Conventions -->
        <module name="TypeName">
            <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="MethodName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="ConstantName">
            <property name="format" value="^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"/>
        </module>
        
        <module name="LocalVariableName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <!-- Code Style -->
        <module name="LeftCurly"/>
        <module name="RightCurly"/>
        <module name="NeedBraces"/>
        
        <module name="WhitespaceAround"/>
        <module name="NoWhitespaceBefore"/>
        
        <!-- Imports -->
        <module name="AvoidStarImport"/>
        <module name="UnusedImports"/>
        <module name="RedundantImport"/>
        
        <!-- Size Violations -->
        <module name="LineLength">
            <property name="max" value="120"/>
        </module>
        
        <module name="MethodLength">
            <property name="max" value="150"/>
        </module>
        
        <!-- Complexity -->
        <module name="CyclomaticComplexity">
            <property name="max" value="15"/>
        </module>
        
        <!-- Best Practices -->
        <module name="EmptyBlock"/>
        <module name="EqualsHashCode"/>
        <module name="SimplifyBooleanExpression"/>
        <module name="SimplifyBooleanReturn"/>
        
        <!-- Annotations -->
        <module name="MissingOverride"/>
    </module>
</module>
```

#### SpotBugs Configuration (Gradle)
```groovy
// build.gradle
spotbugs {
    effort = 'max'
    reportLevel = 'high'
    excludeFilter = file("${project.rootDir}/config/spotbugs/spotbugs-exclude.xml")
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/main/spotbugs.html")
        }
        xml {
            required = false
        }
    }
}

tasks.named('spotbugsTest') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/test/spotbugs.html")
        }
    }
}
```

#### config/spotbugs/spotbugs-exclude.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<FindBugsFilter>
    <!-- Exclude generated code -->
    <Match>
        <Package name="~.*\.dto.*"/>
    </Match>
    
    <Match>
        <Package name="~.*\.entity.*"/>
    </Match>
    
    <Match>
        <Class name="~.*MapperImpl"/>
    </Match>
    
    <!-- Exclude specific bugs for Lombok -->
    <Match>
        <Bug pattern="EI_EXPOSE_REP,EI_EXPOSE_REP2"/>
        <Or>
            <Class name="~.*\.domain\.model\..*"/>
        </Or>
    </Match>
</FindBugsFilter>
```

#### Gradle Verification Tasks
```groovy
// Create custom task to run all quality checks
tasks.register('qualityCheck') {
    dependsOn 'checkstyleMain', 'checkstyleTest', 'spotbugsMain', 'jacocoTestCoverageVerification'
    description = 'Run all quality checks: Checkstyle, SpotBugs, and JaCoCo'
    group = 'verification'
}

// Make 'check' depend on quality checks
check {
    dependsOn 'qualityCheck'
}

// Gradle wrapper
wrapper {
    gradleVersion = '8.5'
    distributionType = Wrapper.DistributionType.ALL
}
```

#### Run Quality Checks
```bash
# Run all quality checks
./gradlew check

# Run individual checks
./gradlew checkstyleMain
./gradlew spotbugsMain
./gradlew test jacocoTestReport
./gradlew jacocoTestCoverageVerification

# Build with quality checks
./gradlew clean build

# Generate reports
./gradlew jacocoTestReport
# Report: build/reports/jacoco/test/html/index.html

./gradlew checkstyleMain
# Report: build/reports/checkstyle/main.html

./gradlew spotbugsMain
# Report: build/reports/spotbugs/main/spotbugs.html
```

### 8. Domain Modeling Best Practices

#### Value Objects
```java
@Value
@Builder
public class PaymentAmount {
    BigDecimal value;
    Currency currency;
    
    public static PaymentAmount of(double value, Currency currency) {
        if (value <= 0) {
            throw new InvalidPaymentException("Amount must be positive");
        }
        return new PaymentAmount(BigDecimal.valueOf(value), currency);
    }
}
```

#### Aggregates
```java
@Builder(toBuilder = true)
@Value
public class PaymentOrder {
    PaymentOrderId id;
    PayerReference payerReference;
    PayeeReference payeeReference;
    PaymentAmount amount;
    PaymentStatus status;
    LocalDateTime createdAt;
    
    // Business invariants
    public PaymentOrder validate() {
        if (status == PaymentStatus.CANCELLED && amount.getValue().compareTo(BigDecimal.ZERO) > 0) {
            throw new InvalidPaymentException("Cancelled orders cannot have positive amount");
        }
        return this;
    }
    
    public PaymentOrder markAsProcessed() {
        if (status != PaymentStatus.INITIATED) {
            throw new InvalidPaymentException("Only initiated orders can be processed");
        }
        return this.toBuilder().status(PaymentStatus.PROCESSED).build();
    }
}
```

#### Domain Events (if needed)
```java
@Value
public class PaymentOrderInitiatedEvent {
    String paymentOrderReference;
    PaymentAmount amount;
    LocalDateTime occurredOn;
}
```

### 9. Error Handling (RFC 7807)

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(PaymentOrderNotFoundException.class)
    public ResponseEntity<ProblemDetail> handleNotFound(PaymentOrderNotFoundException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, 
            ex.getMessage()
        );
        problem.setTitle("Payment Order Not Found");
        problem.setProperty("paymentOrderReference", ex.getPaymentOrderReference());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem);
    }
    
    @ExceptionHandler(InvalidPaymentException.class)
    public ResponseEntity<ProblemDetail> handleInvalidPayment(InvalidPaymentException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST,
            ex.getMessage()
        );
        problem.setTitle("Invalid Payment Order");
        problem.setProperty("validationErrors", ex.getErrors());
        return ResponseEntity.badRequest().body(problem);
    }
}
```

### 10. Docker Configuration with H2

#### Multi-stage Dockerfile (Gradle)
```dockerfile
# Build stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

# Copy Gradle files
COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .

# Copy source code
COPY src src
COPY config config

# Build application (skip tests for faster builds, tests run in CI/CD)
RUN ./gradlew clean build -x test --no-daemon

# Runtime stage
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Create non-root user for security
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# Copy JAR from builder
COPY --from=builder /app/build/libs/*.jar app.jar

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# JVM options
ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC -XX:+UseContainerSupport"

# Run application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

#### docker-compose.yml (H2 in-memory)
```yaml
version: '3.8'

services:
  payment-initiation-service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: payment-initiation-service
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - JAVA_OPTS=-Xms256m -Xmx512m
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - payment-network
    restart: unless-stopped

networks:
  payment-network:
    driver: bridge

# Optional: Add volumes for H2 file-based persistence
# volumes:
#   h2-data:
#     driver: local
```

#### application-docker.yml (For containerized H2)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 with file persistence in Docker (optional)
  datasource:
    url: jdbc:h2:file:/app/data/paymentdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: true  # Allow access from outside container
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: false

server:
  port: 8080

logging:
  level:
    com.hiberus.banking: INFO
    org.springframework.web: WARN
```

#### Docker Commands
```bash
# Build image
docker build -t payment-initiation-service:latest .

# Run with docker-compose
docker-compose up -d

# View logs
docker-compose logs -f payment-initiation-service

# Stop services
docker-compose down

# Rebuild and restart
docker-compose up -d --build

# Access H2 Console (if enabled)
# URL: http://localhost:8080/h2-console
# JDBC URL: jdbc:h2:mem:paymentdb
# Username: sa
# Password: (empty)

# Health check
curl http://localhost:8080/actuator/health

# Test API
curl -X POST http://localhost:8080/payment-initiation/payment-orders \
  -H "Content-Type: application/json" \
  -d '{
    "payerReference": "CUST-123",
    "payeeReference": "CUST-456",
    "amount": {
      "value": 1500.50,
      "currency": "USD"
    },
    "paymentPurpose": "Invoice payment"
  }'
```

#### .dockerignore
```
.git
.gitignore
.gradle
build/
!build/libs/*.jar
*.md
.idea
*.iml
.vscode
target/
*.log
```

#### Alternative: Dockerfile with tests included
```dockerfile
# Build and test stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .
COPY config config
COPY src src

# Run tests and build
RUN ./gradlew clean build --no-daemon

# Runtime stage (same as before)
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

COPY --from=builder /app/build/libs/*.jar app.jar

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 11. AI-Assisted Development Documentation (Required)

#### Structure for ai/ folder
```
ai/
├── prompts.md                 # All prompts used with AI responses
├── decisions.md              # Architectural decisions and rationale
└── generations/              # Generated code samples with annotations
    ├── 01-wsdl-analysis.md
    ├── 02-openapi-draft.yaml
    ├── 03-domain-model.java
    ├── 04-mappers-generation.java
    ├── 05-controller-skeleton.java
    └── 06-test-generation.java
```

#### Example prompts.md format (SOAP Migration Context)
```markdown
# AI Prompts and Generations Log

## Context
This document tracks all AI interactions used during the SOAP to REST migration project.
Each entry includes the prompt, AI response summary, generated artifacts, and manual corrections.

---

## Prompt 1: WSDL Analysis and BIAN Mapping

**Date**: 2025-10-30
**AI Tool**: Claude 3.5 Sonnet / ChatGPT-4 / Cursor AI

**Prompt**:
```
I have a legacy SOAP service defined in PaymentOrderService.wsdl. 
Analyze this WSDL and map it to the BIAN Payment Initiation Service Domain (PaymentOrder BQ).

Identify:
1. SOAP operations and their BIAN equivalents
2. Data structures and field mappings
3. Business rules implied by the schema
4. Status flows and lifecycle states
5. Suggest REST endpoint structure aligned with BIAN

WSDL Content:
[paste PaymentOrderService.wsdl content]
```

**AI Response Summary**:
The AI identified two main SOAP operations:

1. **SubmitPaymentOrder** → Maps to BIAN **Initiate** operation
   - SOAP: `externalId, debtorIban, creditorIban, amount, currency, remittanceInfo, requestedExecutionDate`
   - REST: POST `/payment-initiation/payment-orders`
   - Status returned: ACCEPTED (maps to BIAN INITIATED)

2. **GetPaymentOrderStatus** → Maps to BIAN **Retrieve Status**
   - SOAP: `paymentOrderId` → returns `status, lastUpdate`
   - REST: GET `/payment-initiation/payment-orders/{id}/status`

**Generated Artifacts**:
- Field mapping table (SOAP → BIAN)
- Status mapping (ACCEPTED → INITIATED, SETTLED → COMPLETED, etc.)
- Suggested OpenAPI paths structure

**Manual Corrections Made**:
1. ✅ Changed generic `paymentOrderId` to BIAN-compliant `paymentOrderReference`
2. ✅ Added missing `externalReference` field (from SOAP `externalId`)
3. ✅ Wrapped IBAN fields into `Account` objects for better structure
4. ✅ Combined `amount + currency` into `InstructedAmount` object (ISO 20022)
5. ✅ Added missing BIAN operation: GET `/payment-orders/{id}` (full retrieve)
6. ✅ Normalized status values to BIAN lifecycle (6 states)
7. ✅ Added audit fields: `createdAt`, `updatedAt` (not in SOAP)

**Validation**:
- ✅ Confirmed with BIAN Payment Initiation SD documentation
- ✅ Validated against Postman collection examples
- ✅ Verified ISO 20022 compliance for amount structure

---

## Prompt 2: OpenAPI Specification Generation

**Date**: 2025-10-30

**Prompt**:
```
Based on the SOAP to BIAN mapping from Prompt 1, generate a complete OpenAPI 3.0 specification.

Requirements:
- Follow BIAN Service Domain: Payment Initiation (PaymentOrder BQ)
- Include all three endpoints: POST initiate, GET retrieve, GET status
- Use proper HTTP status codes (201, 200, 400, 404, 409, 500)
- Include RFC 7807 error responses (application/problem+json)
- Add request/response examples based on the Postman collection
- Include field validations (patterns, min/max, required)
- Document SOAP to REST field mappings in descriptions

Postman collection example:
[paste postman_collection.json relevant parts]
```

**AI Response Summary**:
Generated complete OpenAPI 3.0 spec with:
- 3 endpoints with proper operationIds
- Request/response schemas with BIAN naming
- Validation rules (IBAN pattern, amount min, currency enum)
- RFC 7807 ProblemDetail schema
- Examples from Postman collection

**Generated Artifacts**:
- `openapi.yaml` (initial draft)
- Component schemas: Account, InstructedAmount, PaymentStatus enum
- Example payloads matching Postman tests

**Manual Corrections Made**:
1. ✅ Fixed IBAN regex pattern to match Ecuador format (EC prefix)
2. ✅ Added `pattern` for `paymentOrderReference` (^PO-[0-9]{4,}$)
3. ✅ Changed currency enum to include only supported currencies
4. ✅ Added 409 Conflict response for duplicate `externalReference`
5. ✅ Enhanced descriptions with SOAP field references
6. ✅ Added Location header for 201 Created response

**Validation**:
- ✅ Validated with openapi-generator (no errors)
- ✅ Imported into Swagger UI successfully
- ✅ All Postman examples map correctly to OpenAPI schemas

---

## Prompt 3: Hexagonal Architecture Package Structure

**Date**: 2025-10-30

**Prompt**:
```
Generate the complete hexagonal architecture package structure for this BIAN Payment Initiation microservice.

Requirements:
- Java 17+, Spring Boot 3, Spring MVC (no reactive)
- Three layers: domain, application, adapter
- Domain must be framework-independent
- Include all necessary value objects based on OpenAPI
- Use ports and adapters pattern
- Add MapStruct mappers in appropriate layers

Context:
- Migrating from SOAP (PaymentOrderService.wsdl)
- Need: Account, InstructedAmount, PaymentOrderReference, ExternalReference value objects
- Status mapping service for SOAP ↔ BIAN conversion
- Three endpoints: Initiate, Retrieve, RetrieveStatus
```

**AI Response Summary**:
Generated complete package structure with:
- Domain layer: 4 value objects, 1 aggregate, 3 use case interfaces
- Application layer: 3 service implementations, 1 mapper interface
- Adapter layer: REST (controller + DTOs), Persistence (JPA + entities)
- Proper dependency direction (inward)

**Generated Artifacts**:
```
com.hiberus.banking.payment/
├── domain/
│   ├── model/ (PaymentOrder, Account, InstructedAmount, etc.)
│   ├── port/in/ (Use case interfaces)
│   ├── port/out/ (Repository interfaces)
│   └── service/ (StatusMappingService)
├── application/
│   ├── service/ (Use case implementations)
│   └── mapper/ (MapStruct interfaces)
└── adapter/
    ├── in/rest/ (Controller, DTOs)
    └── out/persistence/ (JPA adapters)
```

**Manual Corrections Made**:
1. ✅ Added `StatusMappingService` in domain layer (wasn't suggested)
2. ✅ Split mapper into 3 types: REST, Persistence, Application
3. ✅ Added `DuplicateExternalReferenceException` for 409 Conflict
4. ✅ Created separate package for legacy SOAP adapter (future hybrid mode)
5. ✅ Added `@PrePersist` and `@PreUpdate` in JPA entity

---

## Prompt 4: Domain Model Implementation

**Date**: 2025-10-30

**Prompt**:
```
Implement the complete domain model for PaymentOrder aggregate.

Requirements:
- Use Lombok @Value and @Builder
- Include all value objects: Account, InstructedAmount, PaymentOrderReference, ExternalReference
- PaymentStatus enum with BIAN lifecycle (6 states)
- Business invariants validation
- State transition methods (markAsPending, markAsCompleted, etc.)
- Include SOAP status mapping in PaymentStatus enum

Reference:
- OpenAPI schemas from openapi.yaml
- SOAP status mapping: ACCEPTED→INITIATED, SETTLED→COMPLETED
```

**AI Response Summary**:
Generated complete domain model with:
- PaymentOrder aggregate with 10 fields
- 4 value objects with factory methods and validation
- PaymentStatus enum with 6 states + SOAP mapping
- 5 state transition methods with business rules
- Comprehensive validation in value object constructors

**Generated Artifacts**:
- `PaymentOrder.java` (aggregate root)
- `Account.java`, `InstructedAmount.java`, `PaymentOrderReference.java`, `ExternalReference.java`
- `PaymentStatus.java` (enum with SOAP mapping)
- `StatusMappingService.java`

**Manual Corrections Made**:
1. ✅ Added `equals` check to prevent same debtor/creditor
2. ✅ Enhanced IBAN validation regex
3. ✅ Added `AtomicInteger` for payment order reference generation
4. ✅ Included `soapStatus` field in PaymentStatus enum for backward compatibility
5. ✅ Added `fromSoapStatus()` static method for legacy integration
6. ✅ Improved error messages with specific field references

**Validation**:
- ✅ Unit tests pass for all value objects
- ✅ State transitions enforce business rules correctly
- ✅ SOAP status mapping bidirectional and accurate

---

## Prompt 5: MapStruct Mappers Generation

**Date**: 2025-10-30

**Prompt**:
```
Generate three MapStruct mappers for the payment service:

1. PaymentOrderRestMapper (DTO ↔ Domain)
   - InitiatePaymentOrderRequest → PaymentOrder
   - PaymentOrder → InitiatePaymentOrderResponse
   - PaymentOrder → RetrievePaymentOrderResponse
   - PaymentOrder → PaymentOrderStatusResponse

2. PaymentOrderPersistenceMapper (Domain ↔ Entity)
   - PaymentOrder → PaymentOrderEntity
   - PaymentOrderEntity → PaymentOrder

3. Include proper Lombok + MapStruct configuration

Requirements:
- componentModel = "spring"
- unmappedTargetPolicy = ReportingPolicy.ERROR
- Handle value object mapping (Account.iban, InstructedAmount.amount/currency)
- Map PaymentStatus enum ↔ PaymentStatusEntity
```

**AI Response Summary**:
Generated three complete MapStruct interfaces with:
- All necessary @Mapping annotations
- Proper value object unwrapping/wrapping
- Custom methods for complex transformations
- Lombok + MapStruct compatibility configuration

**Generated Artifacts**:
- `PaymentOrderRestMapper.java`
- `PaymentOrderPersistenceMapper.java`
- `PaymentOrderApplicationMapper.java`
- `build.gradle` MapStruct configuration

**Manual Corrections Made**:
1. ✅ Added `expression` for `createdAt` (java.time.LocalDateTime.now())
2. ✅ Fixed nested mapping for `instructedAmount.amount` and `.currency`
3. ✅ Added `lombok-mapstruct-binding` dependency for compatibility
4. ✅ Created custom method for PaymentStatus ↔ PaymentStatusEntity
5. ✅ Added `@Mapping(target = "id", ignore = true)` for JPA entity ID

**Validation**:
- ✅ MapStruct generates implementation classes successfully
- ✅ Spring beans properly injected
- ✅ No compilation warnings about unmapped fields

---

## Prompt 6: Controller Implementation

**Date**: 2025-10-30

**Prompt**:
```
Implement PaymentInitiationController with Spring MVC.

Requirements:
- Implement OpenAPI-generated interface (PaymentInitiationApi)
- Three operations: initiatePaymentOrder, retrievePaymentOrder, retrievePaymentOrderStatus
- Proper HTTP status codes: 201 Created (with Location header), 200 OK
- Use MapStruct mapper for DTO ↔ Domain
- Structured logging with paymentOrderReference
- Inject use cases via constructor (Lombok @RequiredArgsConstructor)

Context:
- Spring MVC (not reactive)
- OpenAPI interface already generated
- Use cases already implemented in application layer
```

**AI Response Summary**:
Generated complete controller implementation with:
- Implementation of generated API interface
- Proper HTTP status handling
- Location header for POST responses
- Structured logging at info level
- Clean separation of concerns

**Generated Artifacts**:
- `PaymentInitiationController.java`

**Manual Corrections Made**:
1. ✅ Added `@Slf4j` for logging
2. ✅ Enhanced log messages with structured fields
3. ✅ Added `ResponseEntity.created()` with URI for Location header
4. ✅ Added try-catch for better error context (later moved to @ControllerAdvice)
5. ✅ Validated all operations return correct HTTP status

**Validation**:
- ✅ All Postman tests pass
- ✅ Location header present in 201 responses
- ✅ Proper content negotiation (application/json)

---

## Prompt 7: Unit Test Generation

**Date**: 2025-10-30

**Prompt**:
```
Generate comprehensive unit tests for:
1. InitiatePaymentOrderService (application layer)
2. PaymentOrder domain model (value objects, state transitions)
3. MapStruct mappers

Requirements:
- JUnit 5, Mockito, AssertJ
- @ExtendWith(MockitoExtension.class)
- Use Object Mother pattern for test data
- Test all business rules and validations
- Cover happy paths and edge cases
- Target: 80%+ coverage

Context:
- Spring MVC (not reactive, no StepVerifier)
- Domain layer is framework-independent
```

**AI Response Summary**:
Generated complete test suite with:
- 15 unit tests for InitiatePaymentOrderService
- 20 tests for PaymentOrder and value objects
- 8 tests for MapStruct mappers
- Object Mother pattern classes (PaymentOrderMother, etc.)
- Comprehensive edge case coverage

**Generated Artifacts**:
- `InitiatePaymentOrderServiceTest.java`
- `PaymentOrderTest.java`
- `PaymentOrderRestMapperTest.java`
- `PaymentOrderMother.java` (test data builder)

**Manual Corrections Made**:
1. ✅ Removed `StepVerifier` (was suggesting reactive tests)
2. ✅ Changed to standard JUnit assertions (no Mono/Flux)
3. ✅ Added `@DisplayName` annotations for better test reports
4. ✅ Enhanced Object Mother with more builder methods
5. ✅ Added parameterized tests for status transitions

**Validation**:
- ✅ All tests pass
- ✅ JaCoCo coverage: 87% (exceeds 80% requirement)
- ✅ No flaky tests

---

## Prompt 8: Integration Tests with WebTestClient

**Date**: 2025-10-30

**Prompt**:
```
Generate end-to-end integration tests for all three endpoints.

Requirements:
- @SpringBootTest with RANDOM_PORT
- Use WebTestClient (works with Spring MVC)
- Test all Postman collection scenarios
- Verify HTTP status codes: 201, 200, 404, 400
- Validate response payloads
- Test H2 database persistence
- Use @BeforeEach to clean database

Postman scenarios:
1. POST /payment-orders → 201 Created
2. GET /payment-orders/{id} → 200 OK
3. GET /payment-orders/{id}/status → 200 OK
4. GET /payment-orders/NON-EXISTENT → 404 Not Found
```

**AI Response Summary**:
Generated complete integration test class with:
- 6 E2E test methods
- WebTestClient configuration
- Database cleanup in @BeforeEach
- Payload validation with AssertJ
- Repository verification

**Generated Artifacts**:
- `PaymentInitiationIntegrationTest.java`

**Manual Corrections Made**:
1. ✅ Added `@AutoConfigureWebTestClient` annotation
2. ✅ Removed Testcontainers (using H2 in-memory)
3. ✅ Added concurrent request test (5 threads)
4. ✅ Enhanced assertions to validate nested objects
5. ✅ Added test for duplicate externalReference (409 Conflict)

**Validation**:
- ✅ All integration tests pass
- ✅ Database state verified after each test
- ✅ Matches Postman collection behavior exactly

---

## Summary Statistics

| Category | AI Generated | Manual Corrections | Final Status |
|----------|--------------|-------------------|--------------|
| OpenAPI Schema | 90% | 10% | ✅ Complete |
| Domain Model | 85% | 15% | ✅ Complete |
| Mappers | 80% | 20% | ✅ Complete |
| Controllers | 90% | 10% | ✅ Complete |
| Unit Tests | 75% | 25% | ✅ Complete |
| Integration Tests | 80% | 20% | ✅ Complete |
| **Overall** | **83%** | **17%** | ✅ Complete |

## Key Learnings

### What AI Did Well:
1. ✅ WSDL analysis and BIAN mapping (excellent structure identification)
2. ✅ OpenAPI generation (90% correct, needed minor tweaks)
3. ✅ Boilerplate code (controllers, entities, DTOs)
4. ✅ Test skeletons (good coverage of scenarios)
5. ✅ Hexagonal architecture structure (proper layering)

### What Required Manual Correction:
1. ⚠️ Reactive vs. non-reactive confusion (suggested Mono/Flux initially)
2. ⚠️ BIAN-specific naming conventions (needed domain expertise)
3. ⚠️ Business rule edge cases (domain knowledge required)
4. ⚠️ MapStruct complex mappings (nested objects, expressions)
5. ⚠️ SOAP-specific status mapping logic (legacy integration)

### Recommendations for Future Projects:
1. 📋 Provide complete context upfront (tech stack, constraints, examples)
2. 📋 Validate each generation step before proceeding
3. 📋 Use AI for repetitive code, manual review for business logic
4. 📋 Document ALL corrections (this file serves as audit trail)
5. 📋 Test generated code immediately (don't accumulate untested code)

---

## AI Tools Used

| Tool | Version | Use Case | Effectiveness |
|------|---------|----------|---------------|
| Claude 3.5 Sonnet | Latest | Architecture, domain modeling | ⭐⭐⭐⭐⭐ |
| ChatGPT-4 | GPT-4 | OpenAPI generation, tests | ⭐⭐⭐⭐ |
| Cursor AI | Latest | Code completion, refactoring | ⭐⭐⭐⭐⭐ |
| GitHub Copilot | Latest | Test data builders | ⭐⭐⭐ |

## References
- BIAN Service Domain: Payment Initiation v12.0
- ISO 20022 Payment Initiation Messages
- RFC 7807: Problem Details for HTTP APIs
- OpenAPI Specification 3.0.3
```

This comprehensive documentation provides:
- ✅ Complete audit trail of AI usage
- ✅ Transparency in what was generated vs. corrected
- ✅ Context for future maintainers
- ✅ Validation that requirements were met
- ✅ Lessons learned for process improvement

### 12. Code Style & Conventions

#### Naming Conventions
- **Classes**: PascalCase (e.g., `PaymentOrder`, `InitiatePaymentOrderService`)
- **Methods**: camelCase, verb-based (e.g., `initiatePayment`, `retrieveOrderStatus`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_PAYMENT_AMOUNT`)
- **Packages**: lowercase, domain-driven (e.g., `domain.model`, `adapter.in.rest`)

#### BIAN-Specific Conventions
- Prefix interfaces with use case: `InitiatePaymentOrderUseCase`
- Use "Reference" suffix for IDs: `paymentOrderReference`, `payerReference`
- Status naming: Use BIAN lifecycle terms (INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED)

#### Lombok Usage
```java
@Value                    // For immutable value objects
@Builder(toBuilder=true) // For entities with many fields
@RequiredArgsConstructor // For dependency injection
@Slf4j                   // For logging
```

### 13. Observability & Production Readiness

#### Actuator Configuration
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    tags:
      application: payment-initiation-service
      service-domain: payment-initiation
```

#### Custom Metrics
```java
@Component
@RequiredArgsConstructor
public class PaymentMetrics {
    
    private final MeterRegistry registry;
    
    public void recordPaymentInitiated(PaymentAmount amount) {
        registry.counter("payment.initiated", 
            "currency", amount.getCurrency().toString())
            .increment();
        
        registry.summary("payment.amount")
            .record(amount.getValue().doubleValue());
    }
}
```

#### Logging Best Practices
```java
// Structured logging
log.info("Payment order initiated", 
    kv("paymentOrderReference", order.getId()),
    kv("amount", order.getAmount().getValue()),
    kv("status", order.getStatus()));

// Never log sensitive data (PII)
// Use correlation IDs for tracing
```

### 14. Security Considerations

- Validate all inputs at adapter layer
- Use Bean Validation annotations in DTOs
- Implement idempotency using `Idempotency-Key` header
- Add rate limiting for endpoints
- Sanitize error messages (don't expose internal details)

### 15. Documentation Requirements

#### README.md Must Include
1. **Project Overview**: BIAN SD, migration context
2. **Architecture Decision Records (ADRs)**: Why hexagonal, why reactive
3. **Setup Instructions**: Prerequisites, local run, Docker
4. **API Documentation**: Link to Swagger UI, example requests
5. **Testing**: How to run tests, coverage reports
6. **AI Usage**: Summary of prompts and generated code
7. **Quality Gates**: Checkstyle, SpotBugs, JaCoCo results


- [ ] IBAN validation enforced
- [ ] Currency codes validated (ISO 4217)
- [ ] Amount always positive
- [ ] Date formats: ISO 8601
- [ ] Status lifecycle enforced (state transitions)

## Pre-Commit Commands

```bash
# 1. Generate OpenAPI code
./gradlew openApiGenerate

# 2. Run all tests
./gradlew test

# 3. Check coverage
./gradlew jacocoTestReport
# Open: build/reports/jacoco/test/html/index.html
# Verify: ≥80% coverage

# 4. Run quality checks
./gradlew checkstyleMain checkstyleTest
./gradlew spotbugsMain

# 5. Full build with checks
./gradlew clean build check

# 6. Test Docker build
docker build -t payment-initiation-service:latest .

# 7. Test docker-compose
docker-compose up -d
curl http://localhost:8080/actuator/health
docker-compose down

# 8. Validate Postman collection
# Import postman_collection.json and run all requests
```

## Final Validation

**Before submitting:**
1. ✅ All checklist items above are checked
2. ✅ `./gradlew clean build check` passes with **zero violations**
3. ✅ JaCoCo report shows **≥80% coverage**
4. ✅ Docker image builds and runs successfully
5. ✅ All Postman tests pass against running service
6. ✅ AI usage fully documented in `ai/` folder
7. ✅ README.md is complete and accurate
8. ✅ No TODOs or FIXMEs in production code
9. ✅ Git commit messages follow convention
10. ✅ Code reviewed (self-review checklist completed)

## Additional Gradle Commands

```bash
# Clean build
./gradlew clean build

# Run with quality checks
./gradlew clean build check

# Run only tests
./gradlew test

# Generate coverage report
./gradlew test jacocoTestReport
# Open: build/reports/jacoco/test/html/index.html

# Run checkstyle only
./gradlew checkstyleMain checkstyleTest

# Run spotbugs only
./gradlew spotbugsMain spotbugsTest

# Build without tests (faster for development)
./gradlew clean build -x test

# Run application locally
./gradlew bootRun

# Generate OpenAPI code
./gradlew openApiGenerate

# View project dependencies
./gradlew dependencies

# View available tasks
./gradlew tasks
```

## Remember
- **BIAN alignment is non-negotiable**: Always validate against BIAN standards
- **Domain purity**: Keep domain layer framework-agnostic
- **Test-first mindset**: Write tests before implementation
- **Document AI usage**: Every AI-generated code must be reviewed and documented
- **Quality over speed**: Meet all quality gates before considering "done"

---

When in doubt, ask yourself: "Does this align with BIAN Payment Initiation Service Domain standards?" and "Is this following hexagonal architecture principles?"
        example: "PO-0001"
  
  schemas:
    # Request Schema (mapped from SOAP SubmitPaymentOrderRequest)
    InitiatePaymentOrderRequest:
      type: object
      required: 
        - externalReference
        - debtorAccount
        - creditorAccount
        - instructedAmount
        - requestedExecutionDate
      properties:
        externalReference:
          type: string
          description: External reference from client system (SOAP externalId)
          minLength: 1
          maxLength: 50
          example: "EXT-1"
        debtorAccount:
          $ref: '#/components/schemas/Account'
        creditorAccount:
          $ref: '#/components/schemas/Account'
        instructedAmount:
          $ref: '#/components/schemas/InstructedAmount'
        remittanceInformation:
          type: string
          description: Payment purpose or description (SOAP remittanceInfo)
          maxLength: 255
          example: "Factura 001-123"
        requestedExecutionDate:
          type: string
          format: date
          description: Requested payment execution date (ISO 8601)
          example: "2025-10-31"
    
    # Response Schema (mapped from SOAP SubmitPaymentOrderResponse + enriched)
    InitiatePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
          description: BIAN-compliant payment order reference (SOAP paymentOrderId)
          pattern: '^PO-[0-9]{4,}
```yaml
# openapi.yaml structure
openapi: 3.0.3
info:
  title: BIAN Payment Initiation API
  version: 1.0.0
  description: Payment Order management aligned with BIAN Service Domain

servers:
  - url: http://localhost:8080
    description: Local development server

paths:
  /payment-initiation/payment-orders:
    post:
      operationId: initiatePaymentOrder
      tags: [Payment Initiation]
      summary: Initiate a new payment order
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InitiatePaymentOrderRequest'
      responses:
        '201':
          description: Payment order successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InitiatePaymentOrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '500':
          $ref: '#/components/responses/InternalServerError'
  
  /payment-initiation/payment-orders/{id}:
    get:
      operationId: retrievePaymentOrder
      tags: [Payment Initiation]
      summary: Retrieve payment order details
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RetrievePaymentOrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /payment-initiation/payment-orders/{id}/status:
    get:
      operationId: retrievePaymentOrderStatus
      tags: [Payment Initiation]
      summary: Retrieve payment order status
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order status retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentOrderStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    InitiatePaymentOrderRequest:
      type: object
      required: 
        - payerReference
        - payeeReference
        - amount
      properties:
        payerReference:
          type: string
          description: Reference to the payer (customer ID)
          example: "CUST-12345"
        payeeReference:
          type: string
          description: Reference to the payee (beneficiary ID)
          example: "CUST-67890"
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
          description: Purpose of the payment
          example: "Invoice payment"
        paymentDate:
          type: string
          format: date
          description: Requested payment date
          example: "2024-11-20"
    
    InitiatePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
          description: BIAN-compliant payment order reference
          example: "PO-2024-001234"
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        createdAt:
          type: string
          format: date-time
    
    RetrievePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
        paymentDate:
          type: string
          format: date
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    PaymentOrderStatusResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        statusReason:
          type: string
          description: Reason for current status
        lastUpdated:
          type: string
          format: date-time
    
    PaymentAmount:
      type: object
      required:
        - value
        - currency
      properties:
        value:
          type: number
          format: double
          minimum: 0.01
          example: 1500.50
        currency:
          type: string
          enum: [USD, EUR, GBP, JPY]
          example: "USD"
    
    ProblemDetail:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request - validation errors
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    NotFound:
      description: Resource not found
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    InternalServerError:
      description: Internal server error
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
```

#### Gradle Configuration (build.gradle)
```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'org.openapi.generator' version '7.0.1'
    id 'checkstyle'
    id 'com.github.spotbugs' version '6.0.0'
    id 'jacoco'
}

group = 'com.hiberus.banking'
version = '1.0.0'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

ext {
    mapstructVersion = '1.5.5.Final'
    lombokVersion = '1.18.30'
    openApiVersion = '2.2.0'
}

dependencies {
    // Spring Boot Starters
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    
    // H2 Database
    runtimeOnly 'com.h2database:h2'
    
    // OpenAPI
    implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${openApiVersion}"
    
    // MapStruct
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
    
    // Lombok
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    
    // Lombok + MapStruct compatibility
    annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"
    
    // Testing
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-webflux'  // For WebTestClient
    testImplementation 'io.rest-assured:rest-assured:5.4.0'
    testImplementation 'org.assertj:assertj-core'
    
    // Test Lombok
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
}

// OpenAPI Generator Task
openApiGenerate {
    generatorName = 'spring'
    inputSpec = "$projectDir/src/main/resources/openapi.yaml"
    outputDir = "$buildDir/generated"
    apiPackage = 'com.hiberus.banking.payment.adapter.in.rest.api'
    modelPackage = 'com.hiberus.banking.payment.adapter.in.rest.dto'
    invokerPackage = 'com.hiberus.banking.payment.adapter.in.rest.invoker'
    configOptions = [
        interfaceOnly: 'true',
        useSpringBoot3: 'true',
        useTags: 'true',
        dateLibrary: 'java8',
        serializationLibrary: 'jackson',
        hideGenerationTimestamp: 'true'
    ]
}

// Add generated sources to source sets
sourceSets {
    main {
        java {
            srcDirs += "$buildDir/generated/src/main/java"
        }
    }
}

// Compile depends on generation
compileJava.dependsOn tasks.openApiGenerate

// JaCoCo Configuration
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
    }
}

// Checkstyle Configuration
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
}

// SpotBugs Configuration
spotbugs {
    effort = 'max'
    reportLevel = 'high'
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
        }
        xml {
            required = false
        }
    }
}

// Test Configuration
test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

// Build task order
check.dependsOn jacocoTestCoverageVerification
```

#### Controller Implementation (Spring MVC)
```java
@RestController
@RequiredArgsConstructor
@Slf4j
public class PaymentInitiationController implements PaymentInitiationApi {
    
    private final InitiatePaymentOrderUseCase initiateUseCase;
    private final RetrievePaymentOrderUseCase retrieveUseCase;
    private final RetrievePaymentOrderStatusUseCase retrieveStatusUseCase;
    private final PaymentOrderRestMapper mapper;
    
    @Override
    public ResponseEntity<InitiatePaymentOrderResponse> initiatePaymentOrder(
            InitiatePaymentOrderRequest request) {
        
        log.info("Initiating payment order for payer: {}", request.getPayerReference());
        
        PaymentOrder domainOrder = mapper.toDomain(request);
        PaymentOrder initiatedOrder = initiateUseCase.initiate(domainOrder);
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(initiatedOrder);
        
        log.info("Payment order initiated successfully: {}", response.getPaymentOrderReference());
        
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(response);
    }
    
    @Override
    public ResponseEntity<RetrievePaymentOrderResponse> retrievePaymentOrder(String id) {
        
        log.info("Retrieving payment order: {}", id);
        
        PaymentOrder paymentOrder = retrieveUseCase.retrieve(id);
        RetrievePaymentOrderResponse response = mapper.toRetrieveResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
    
    @Override
    public ResponseEntity<PaymentOrderStatusResponse> retrievePaymentOrderStatus(String id) {
        
        log.info("Retrieving payment order status: {}", id);
        
        PaymentOrder paymentOrder = retrieveStatusUseCase.retrieveStatus(id);
        PaymentOrderStatusResponse response = mapper.toStatusResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
}
```

### 5. Spring MVC with H2 Database

#### Application Configuration (application.yml)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 Database Configuration
  datasource:
    url: jdbc:h2:mem:paymentdb
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: false
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
  
  # Jackson Configuration
  jackson:
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

# Server Configuration
server:
  port: 8080
  servlet:
    context-path: /
  error:
    include-message: always
    include-binding-errors: always
    include-exception: false
    include-stacktrace: never

# Management / Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    tags:
      application: ${spring.application.name}
      service-domain: payment-initiation

# Logging
logging:
  level:
    com.hiberus.banking: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

#### JPA Entity Example
```java
@Entity
@Table(name = "payment_orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PaymentOrderEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(name = "payment_order_reference", nullable = false, unique = true, length = 50)
    private String paymentOrderReference;
    
    @Column(name = "payer_reference", nullable = false, length = 50)
    private String payerReference;
    
    @Column(name = "payee_reference", nullable = false, length = 50)
    private String payeeReference;
    
    @Column(name = "amount", nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "currency", nullable = false, length = 3)
    private String currency;
    
    @Column(name = "payment_purpose", length = 255)
    private String paymentPurpose;
    
    @Column(name = "payment_date")
    private LocalDate paymentDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PaymentStatusEntity status;
    
    @Column(name = "status_reason", length = 500)
    private String statusReason;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        if (status == null) {
            status = PaymentStatusEntity.INITIATED;
        }
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

@Getter
@RequiredArgsConstructor
enum PaymentStatusEntity {
    INITIATED("Payment order has been initiated"),
    PENDING("Payment order is pending processing"),
    PROCESSED("Payment order has been processed"),
    COMPLETED("Payment order completed successfully"),
    FAILED("Payment order failed"),
    CANCELLED("Payment order has been cancelled");
    
    private final String description;
}
```

#### Spring Data JPA Repository
```java
@Repository
public interface PaymentOrderJpaRepository extends JpaRepository<PaymentOrderEntity, UUID> {
    
    Optional<PaymentOrderEntity> findByPaymentOrderReference(String paymentOrderReference);
    
    List<PaymentOrderEntity> findByPayerReference(String payerReference);
    
    List<PaymentOrderEntity> findByStatus(PaymentStatusEntity status);
    
    @Query("SELECT p FROM PaymentOrderEntity p WHERE p.createdAt BETWEEN :startDate AND :endDate")
    List<PaymentOrderEntity> findByDateRange(
        @Param("startDate") LocalDateTime startDate, 
        @Param("endDate") LocalDateTime endDate
    );
    
    boolean existsByPaymentOrderReference(String paymentOrderReference);
}
```

#### Repository Adapter Implementation
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PaymentOrderRepositoryAdapter implements PaymentOrderRepository {
    
    private final PaymentOrderJpaRepository jpaRepository;
    private final PaymentOrderPersistenceMapper persistenceMapper;
    
    @Override
    public PaymentOrder save(PaymentOrder paymentOrder) {
        log.debug("Saving payment order: {}", paymentOrder.getPaymentOrderReference());
        
        PaymentOrderEntity entity = persistenceMapper.toEntity(paymentOrder);
        PaymentOrderEntity savedEntity = jpaRepository.save(entity);
        
        log.debug("Payment order saved with ID: {}", savedEntity.getId());
        return persistenceMapper.toDomain(savedEntity);
    }
    
    @Override
    public Optional<PaymentOrder> findByReference(String paymentOrderReference) {
        log.debug("Finding payment order by reference: {}", paymentOrderReference);
        
        return jpaRepository.findByPaymentOrderReference(paymentOrderReference)
            .map(persistenceMapper::toDomain);
    }
    
    @Override
    public boolean existsByReference(String paymentOrderReference) {
        return jpaRepository.existsByPaymentOrderReference(paymentOrderReference);
    }
    
    @Override
    public List<PaymentOrder> findAll() {
        return jpaRepository.findAll().stream()
            .map(persistenceMapper::toDomain)
            .collect(Collectors.toList());
    }
}
```

#### H2 Console Configuration
```java
@Configuration
public class H2ConsoleConfig {
    
    @Bean
    public ServletRegistrationBean<WebServlet> h2Console() {
        ServletRegistrationBean<WebServlet> registration = 
            new ServletRegistrationBean<>(new WebServlet());
        registration.addUrlMappings("/h2-console/*");
        return registration;
    }
}
```

#### Data Initialization (Optional - for testing)
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class DataInitializer {
    
    private final PaymentOrderJpaRepository repository;
    
    @EventListener(ApplicationReadyEvent.class)
    public void loadSampleData() {
        if (repository.count() == 0) {
            log.info("Loading sample payment orders...");
            
            PaymentOrderEntity order1 = PaymentOrderEntity.builder()
                .paymentOrderReference("PO-2024-001")
                .payerReference("CUST-12345")
                .payeeReference("CUST-67890")
                .amount(new BigDecimal("1500.50"))
                .currency("USD")
                .paymentPurpose("Invoice payment")
                .paymentDate(LocalDate.now())
                .status(PaymentStatusEntity.INITIATED)
                .build();
            
            repository.save(order1);
            log.info("Sample data loaded successfully");
        }
    }
}
```

### 6. MapStruct Mappers (Three Layers)

MapStruct is used for clean transformation between layers. There are THREE types of mappers:

#### 1. REST Mapper (Adapter Layer: DTO ↔ Domain)
```java
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR)
public interface PaymentOrderRestMapper {
    
    // Request DTO → Domain
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "paymentOrderReference", ignore = true)
    @Mapping(target = "status", constant = "INITIATED")
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    @Mapping(target = "updatedAt", ignore = true)
    PaymentOrder toDomain(InitiatePaymentOrderRequest request);
    
    // Domain → Response DTO (Initiate)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    InitiatePaymentOrderResponse toInitiateResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Retrieve)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    RetrievePaymentOrderResponse toRetrieveResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Status)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    @Mapping(source = "updatedAt", target = "lastUpdated")
    PaymentOrderStatusResponse toStatusResponse(PaymentOrder paymentOrder);
    
    // Value Object mappings
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    PaymentAmount toPaymentAmount(com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount dtoAmount);
    
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount toPaymentAmountDto(PaymentAmount domainAmount);
}
```

#### 2. Persistence Mapper (Adapter Layer: Domain ↔ Entity)
```java
@Mapper(componentModel = "spring", 
        unmappedTargetPolicy = ReportingPolicy.ERROR,
        uses = {PaymentStatusMapper.class})
public interface PaymentOrderPersistenceMapper {
    
    // Domain → Entity
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "payerReference.value", target = "payerReference")
    @Mapping(source = "payeeReference.value", target = "payeeReference")
    @Mapping(source = "amount.value", target = "amount")
    @Mapping(source = "amount.currency", target = "currency")
    @Mapping(source = "status", target = "status")
    @Mapping(target = "id", ignore = true)  // Let JPA generate
    PaymentOrderEntity toEntity(PaymentOrder domain);
    
    // Entity → Domain
    @Mapping(source = "paymentOrderReference", target = "id.value")
    @Mapping(source = "payerReference", target = "payerReference.value")
    @Mapping(source = "payeeReference", target = "payeeReference.value")
    @Mapping(source = "amount", target = "amount.value")
    @Mapping(source = "currency", target = "amount.currency")
    PaymentOrder toDomain(PaymentOrderEntity entity);
    
    // Custom mapping for status
    default PaymentStatus mapStatus(PaymentStatusEntity entityStatus) {
        return PaymentStatus.valueOf(entityStatus.name());
    }
    
    default PaymentStatusEntity mapStatus(PaymentStatus domainStatus) {
        return PaymentStatusEntity.valueOf(domainStatus.name());
    }
}
```

#### 3. Application Mapper (Optional: Complex transformations)
```java
@Mapper(componentModel = "spring")
public interface PaymentOrderApplicationMapper {
    
    // For complex business logic transformations
    @Mapping(target = "enrichedData", expression = "java(enrichData(source))")
    PaymentOrder enrichForProcessing(PaymentOrder source);
    
    default String enrichData(PaymentOrder order) {
        // Complex business logic here
        return "ENRICHED-" + order.getPaymentOrderReference();
    }
}
```

#### MapStruct Configuration Best Practices
```java
@MapperConfig(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.ERROR,  // Fail on unmapped fields
    unmappedSourcePolicy = ReportingPolicy.WARN,    // Warn on unmapped sources
    mappingInheritanceStrategy = MappingInheritanceStrategy.AUTO_INHERIT_FROM_CONFIG
)
public interface CentralMapperConfig {
}

// Then use it in mappers
@Mapper(config = CentralMapperConfig.class)
public interface PaymentOrderRestMapper {
    // ... mappings
}
```

#### Testing MapStruct Mappers
```java
@SpringBootTest
class PaymentOrderRestMapperTest {
    
    @Autowired
    private PaymentOrderRestMapper mapper;
    
    @Test
    @DisplayName("Should map InitiatePaymentOrderRequest to PaymentOrder domain")
    void shouldMapRequestToDomain() {
        // Given
        InitiatePaymentOrderRequest request = new InitiatePaymentOrderRequest()
            .payerReference("CUST-123")
            .payeeReference("CUST-456")
            .amount(new com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount()
                .value(1000.0)
                .currency("USD"))
            .paymentPurpose("Test payment");
        
        // When
        PaymentOrder domain = mapper.toDomain(request);
        
        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getPayerReference().getValue()).isEqualTo("CUST-123");
        assertThat(domain.getPayeeReference().getValue()).isEqualTo("CUST-456");
        assertThat(domain.getAmount().getValue()).isEqualByComparingTo("1000.0");
        assertThat(domain.getAmount().getCurrency()).isEqualTo(Currency.USD);
        assertThat(domain.getStatus()).isEqualTo(PaymentStatus.INITIATED);
    }
    
    @Test
    @DisplayName("Should map PaymentOrder domain to InitiatePaymentOrderResponse")
    void shouldMapDomainToResponse() {
        // Given
        PaymentOrder domain = PaymentOrderMother.valid();
        
        // When
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(domain);
        
        // Then
        assertThat(response).isNotNull();
        assertThat(response.getPaymentOrderReference()).isEqualTo(domain.getId().getValue());
        assertThat(response.getPaymentOrderStatus()).isEqualTo(domain.getStatus().name());
    }
}
```

### 7. Testing Strategy with Spring MVC and WebTestClient

#### Unit Tests (Domain & Application Layer)
```java
@ExtendWith(MockitoExtension.class)
class InitiatePaymentOrderServiceTest {
    
    @Mock
    private PaymentOrderRepository repository;
    
    @Mock
    private PaymentValidationPort validationPort;
    
    @InjectMocks
    private InitiatePaymentOrderService service;
    
    @Test
    @DisplayName("Should initiate payment order when valid")
    void shouldInitiatePaymentOrderWhenValid() {
        // Given
        PaymentOrder order = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenReturn(order);
        
        // When
        PaymentOrder result = service.initiate(order);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getStatus()).isEqualTo(PaymentStatus.INITIATED);
        assertThat(result.getPaymentOrderReference()).isNotNull();
        
        verify(validationPort).validate(order);
        verify(repository).save(any(PaymentOrder.class));
    }
    
    @Test
    @DisplayName("Should throw InvalidPaymentException when validation fails")
    void shouldThrowExceptionWhenValidationFails() {
        // Given
        PaymentOrder order = PaymentOrderMother.withInvalidAmount();
        when(validationPort.validate(any())).thenReturn(false);
        
        // When & Then
        assertThatThrownBy(() -> service.initiate(order))
            .isInstanceOf(InvalidPaymentException.class)
            .hasMessageContaining("validation failed");
        
        verify(validationPort).validate(order);
        verify(repository, never()).save(any());
    }
    
    @Test
    @DisplayName("Should generate unique payment order reference")
    void shouldGenerateUniqueReference() {
        // Given
        PaymentOrder order1 = PaymentOrderMother.valid();
        PaymentOrder order2 = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenAnswer(inv -> inv.getArgument(0));
        
        // When
        PaymentOrder result1 = service.initiate(order1);
        PaymentOrder result2 = service.initiate(order2);
        
        // Then
        assertThat(result1.getPaymentOrderReference())
            .isNotEqualTo(result2.getPaymentOrderReference());
    }
}
```

#### Integration Tests with WebTestClient (Recommended for Spring MVC)
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class PaymentInitiationIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        repository.deleteAll();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 201 Created")
    void shouldInitiatePaymentOrderSuccessfully() {
        // Given
        InitiatePaymentOrderRequest request = InitiatePaymentOrderRequest.builder()
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1500.50)
                .currency("USD")
                .build())
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .build();
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .exchange()
            .expectStatus().isCreated()
            .expectHeader().exists("Location")
            .expectBody(InitiatePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getPaymentOrderReference()).startsWith("PO-");
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getPayeeReference()).isEqualTo("CUST-67890");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
                assertThat(response.getCreatedAt()).isNotNull();
            });
        
        // Verify database
        assertThat(repository.count()).isEqualTo(1);
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 200 OK")
    void shouldRetrievePaymentOrderSuccessfully() {
        // Given - Create a payment order first
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(RetrievePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id}/status - Should return 200 OK")
    void shouldRetrievePaymentOrderStatusSuccessfully() {
        // Given
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}/status", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(PaymentOrderStatusResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getLastUpdated()).isNotNull();
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 404 Not Found")
    void shouldReturn404WhenPaymentOrderNotFound() {
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", "NON-EXISTENT")
            .exchange()
            .expectStatus().isNotFound()
            .expectBody()
            .jsonPath("$.title").isEqualTo("Payment Order Not Found")
            .jsonPath("$.status").isEqualTo(404)
            .jsonPath("$.detail").exists();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 400 Bad Request for invalid data")
    void shouldReturn400ForInvalidRequest() {
        // Given - Invalid request (missing required fields)
        String invalidRequest = """
            {
                "payerReference": "CUST-123"
            }
            """;
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(invalidRequest)
            .exchange()
            .expectStatus().isBadRequest()
            .expectBody()
            .jsonPath("$.title").exists()
            .jsonPath("$.status").isEqualTo(400);
    }
    
    @Test
    @DisplayName("Should handle concurrent payment order creation")
    void shouldHandleConcurrentCreation() throws Exception {
        // Given
        int numberOfThreads = 5;
        ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);
        CountDownLatch latch = new CountDownLatch(numberOfThreads);
        
        // When
        for (int i = 0; i < numberOfThreads; i++) {
            final int index = i;
            executorService.submit(() -> {
                try {
                    InitiatePaymentOrderRequest request = createRequest("PAYER-" + index);
                    webTestClient.post()
                        .uri("/payment-initiation/payment-orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(request)
                        .exchange()
                        .expectStatus().isCreated();
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(10, TimeUnit.SECONDS);
        executorService.shutdown();
        
        // Then
        assertThat(repository.count()).isEqualTo(numberOfThreads);
    }
    
    // Helper methods
    private PaymentOrderEntity createSampleEntity() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-TEST-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Test payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
    
    private InitiatePaymentOrderRequest createRequest(String payerRef) {
        return InitiatePaymentOrderRequest.builder()
            .payerReference(payerRef)
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1000.0)
                .currency("USD")
                .build())
            .paymentPurpose("Concurrent test")
            .build();
    }
}
```

#### Alternative: REST Assured for Integration Tests
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class PaymentInitiationRestAssuredTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        RestAssured.basePath = "/payment-initiation";
        repository.deleteAll();
    }
    
    @Test
    void shouldInitiatePaymentOrder() {
        given()
            .contentType(ContentType.JSON)
            .body(createValidRequest())
        .when()
            .post("/payment-orders")
        .then()
            .statusCode(201)
            .body("paymentOrderReference", notNullValue())
            .body("paymentOrderStatus", equalTo("INITIATED"))
            .body("amount.value", equalTo(1500.50f))
            .body("amount.currency", equalTo("USD"));
    }
    
    @Test
    void shouldRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity saved = repository.save(createSampleEntity());
        
        // When & Then
        given()
            .pathParam("id", saved.getPaymentOrderReference())
        .when()
            .get("/payment-orders/{id}")
        .then()
            .statusCode(200)
            .body("paymentOrderReference", equalTo(saved.getPaymentOrderReference()))
            .body("paymentOrderStatus", equalTo("INITIATED"));
    }
}
```

#### Test Data Builders (Object Mother Pattern)
```java
public class PaymentOrderMother {
    
    public static PaymentOrder valid() {
        return PaymentOrder.builder()
            .id(PaymentOrderId.generate())
            .payerReference(PayerReference.of("CUST-12345"))
            .payeeReference(PayeeReference.of("CUST-67890"))
            .amount(PaymentAmount.of(1500.50, Currency.USD))
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatus.INITIATED)
            .createdAt(LocalDateTime.now())
            .build();
    }
    
    public static PaymentOrder withInvalidAmount() {
        return valid().toBuilder()
            .amount(PaymentAmount.of(-100.00, Currency.USD))
            .build();
    }
    
    public static PaymentOrder withStatus(PaymentStatus status) {
        return valid().toBuilder()
            .status(status)
            .build();
    }
    
    public static PaymentOrder pending() {
        return withStatus(PaymentStatus.PENDING);
    }
    
    public static PaymentOrder completed() {
        return withStatus(PaymentStatus.COMPLETED);
    }
}

public class PaymentOrderEntityMother {
    
    public static PaymentOrderEntity valid() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
}
```

#### Repository Tests
```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class PaymentOrderJpaRepositoryTest {
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    @DisplayName("Should save and retrieve payment order")
    void shouldSaveAndRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity entity = PaymentOrderEntityMother.valid();
        
        // When
        PaymentOrderEntity saved = repository.save(entity);
        entityManager.flush();
        entityManager.clear();
        
        // Then
        Optional<PaymentOrderEntity> found = repository.findByPaymentOrderReference(
            saved.getPaymentOrderReference()
        );
        
        assertThat(found).isPresent();
        assertThat(found.get().getPayerReference()).isEqualTo("CUST-12345");
        assertThat(found.get().getAmount()).isEqualByComparingTo("1500.50");
    }
    
    @Test
    @DisplayName("Should find payment orders by status")
    void shouldFindByStatus() {
        // Given
        repository.save(PaymentOrderEntityMother.valid());
        repository.save(PaymentOrderEntityMother.valid().toBuilder()
            .paymentOrderReference("PO-2024-002")
            .status(PaymentStatusEntity.COMPLETED)
            .build());
        entityManager.flush();
        
        // When
        List<PaymentOrderEntity> initiated = repository.findByStatus(PaymentStatusEntity.INITIATED);
        List<PaymentOrderEntity> completed = repository.findByStatus(PaymentStatusEntity.COMPLETED);
        
        // Then
        assertThat(initiated).hasSize(1);
        assertThat(completed).hasSize(1);
    }
}
```

### 8. Quality Gates (Mandatory - Gradle)

#### JaCoCo Configuration (Gradle)
```groovy
// build.gradle
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                '**/dto/**',
                '**/entity/**',
                '**/config/**',
                '**/*Application.class',
                '**/*MapperImpl.class'  // Exclude MapStruct generated classes
            ])
        }))
    }
}

jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
        
        rule {
            element = 'CLASS'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.70
            }
            excludes = [
                '*.dto.*',
                '*.entity.*',
                '*.config.*',
                '*Application',
                '*MapperImpl'
            ]
        }
    }
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

check.dependsOn jacocoTestCoverageVerification
```

#### Checkstyle Configuration (Gradle)
```groovy
// build.gradle
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
    configProperties = [
        'checkstyle.suppressions.file': "${project.rootDir}/config/checkstyle/suppressions.xml"
    ]
}

checkstyleMain {
    source = 'src/main/java'
    exclude '**/dto/**', '**/entity/**'  // Exclude generated code
}

checkstyleTest {
    source = 'src/test/java'
}

tasks.withType(Checkstyle) {
    reports {
        xml.required = true
        html.required = true
    }
}
```

#### config/checkstyle/checkstyle.xml
```xml
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
    "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
    "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <property name="charset" value="UTF-8"/>
    <property name="severity" value="error"/>
    <property name="fileExtensions" value="java"/>
    
    <module name="SuppressionFilter">
        <property name="file" value="${checkstyle.suppressions.file}"/>
    </module>
    
    <module name="TreeWalker">
        <!-- Naming Conventions -->
        <module name="TypeName">
            <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="MethodName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="ConstantName">
            <property name="format" value="^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"/>
        </module>
        
        <module name="LocalVariableName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <!-- Code Style -->
        <module name="LeftCurly"/>
        <module name="RightCurly"/>
        <module name="NeedBraces"/>
        
        <module name="WhitespaceAround"/>
        <module name="NoWhitespaceBefore"/>
        
        <!-- Imports -->
        <module name="AvoidStarImport"/>
        <module name="UnusedImports"/>
        <module name="RedundantImport"/>
        
        <!-- Size Violations -->
        <module name="LineLength">
            <property name="max" value="120"/>
        </module>
        
        <module name="MethodLength">
            <property name="max" value="150"/>
        </module>
        
        <!-- Complexity -->
        <module name="CyclomaticComplexity">
            <property name="max" value="15"/>
        </module>
        
        <!-- Best Practices -->
        <module name="EmptyBlock"/>
        <module name="EqualsHashCode"/>
        <module name="SimplifyBooleanExpression"/>
        <module name="SimplifyBooleanReturn"/>
        
        <!-- Annotations -->
        <module name="MissingOverride"/>
    </module>
</module>
```

#### SpotBugs Configuration (Gradle)
```groovy
// build.gradle
spotbugs {
    effort = 'max'
    reportLevel = 'high'
    excludeFilter = file("${project.rootDir}/config/spotbugs/spotbugs-exclude.xml")
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/main/spotbugs.html")
        }
        xml {
            required = false
        }
    }
}

tasks.named('spotbugsTest') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/test/spotbugs.html")
        }
    }
}
```

#### config/spotbugs/spotbugs-exclude.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<FindBugsFilter>
    <!-- Exclude generated code -->
    <Match>
        <Package name="~.*\.dto.*"/>
    </Match>
    
    <Match>
        <Package name="~.*\.entity.*"/>
    </Match>
    
    <Match>
        <Class name="~.*MapperImpl"/>
    </Match>
    
    <!-- Exclude specific bugs for Lombok -->
    <Match>
        <Bug pattern="EI_EXPOSE_REP,EI_EXPOSE_REP2"/>
        <Or>
            <Class name="~.*\.domain\.model\..*"/>
        </Or>
    </Match>
</FindBugsFilter>
```

#### Gradle Verification Tasks
```groovy
// Create custom task to run all quality checks
tasks.register('qualityCheck') {
    dependsOn 'checkstyleMain', 'checkstyleTest', 'spotbugsMain', 'jacocoTestCoverageVerification'
    description = 'Run all quality checks: Checkstyle, SpotBugs, and JaCoCo'
    group = 'verification'
}

// Make 'check' depend on quality checks
check {
    dependsOn 'qualityCheck'
}

// Gradle wrapper
wrapper {
    gradleVersion = '8.5'
    distributionType = Wrapper.DistributionType.ALL
}
```

#### Run Quality Checks
```bash
# Run all quality checks
./gradlew check

# Run individual checks
./gradlew checkstyleMain
./gradlew spotbugsMain
./gradlew test jacocoTestReport
./gradlew jacocoTestCoverageVerification

# Build with quality checks
./gradlew clean build

# Generate reports
./gradlew jacocoTestReport
# Report: build/reports/jacoco/test/html/index.html

./gradlew checkstyleMain
# Report: build/reports/checkstyle/main.html

./gradlew spotbugsMain
# Report: build/reports/spotbugs/main/spotbugs.html
```

### 8. Domain Modeling Best Practices

#### Value Objects
```java
@Value
@Builder
public class PaymentAmount {
    BigDecimal value;
    Currency currency;
    
    public static PaymentAmount of(double value, Currency currency) {
        if (value <= 0) {
            throw new InvalidPaymentException("Amount must be positive");
        }
        return new PaymentAmount(BigDecimal.valueOf(value), currency);
    }
}
```

#### Aggregates
```java
@Builder(toBuilder = true)
@Value
public class PaymentOrder {
    PaymentOrderId id;
    PayerReference payerReference;
    PayeeReference payeeReference;
    PaymentAmount amount;
    PaymentStatus status;
    LocalDateTime createdAt;
    
    // Business invariants
    public PaymentOrder validate() {
        if (status == PaymentStatus.CANCELLED && amount.getValue().compareTo(BigDecimal.ZERO) > 0) {
            throw new InvalidPaymentException("Cancelled orders cannot have positive amount");
        }
        return this;
    }
    
    public PaymentOrder markAsProcessed() {
        if (status != PaymentStatus.INITIATED) {
            throw new InvalidPaymentException("Only initiated orders can be processed");
        }
        return this.toBuilder().status(PaymentStatus.PROCESSED).build();
    }
}
```

#### Domain Events (if needed)
```java
@Value
public class PaymentOrderInitiatedEvent {
    String paymentOrderReference;
    PaymentAmount amount;
    LocalDateTime occurredOn;
}
```

### 9. Error Handling (RFC 7807)

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(PaymentOrderNotFoundException.class)
    public ResponseEntity<ProblemDetail> handleNotFound(PaymentOrderNotFoundException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, 
            ex.getMessage()
        );
        problem.setTitle("Payment Order Not Found");
        problem.setProperty("paymentOrderReference", ex.getPaymentOrderReference());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem);
    }
    
    @ExceptionHandler(InvalidPaymentException.class)
    public ResponseEntity<ProblemDetail> handleInvalidPayment(InvalidPaymentException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST,
            ex.getMessage()
        );
        problem.setTitle("Invalid Payment Order");
        problem.setProperty("validationErrors", ex.getErrors());
        return ResponseEntity.badRequest().body(problem);
    }
}
```

### 10. Docker Configuration with H2

#### Multi-stage Dockerfile (Gradle)
```dockerfile
# Build stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

# Copy Gradle files
COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .

# Copy source code
COPY src src
COPY config config

# Build application (skip tests for faster builds, tests run in CI/CD)
RUN ./gradlew clean build -x test --no-daemon

# Runtime stage
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Create non-root user for security
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# Copy JAR from builder
COPY --from=builder /app/build/libs/*.jar app.jar

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# JVM options
ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC -XX:+UseContainerSupport"

# Run application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

#### docker-compose.yml (H2 in-memory)
```yaml
version: '3.8'

services:
  payment-initiation-service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: payment-initiation-service
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - JAVA_OPTS=-Xms256m -Xmx512m
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - payment-network
    restart: unless-stopped

networks:
  payment-network:
    driver: bridge

# Optional: Add volumes for H2 file-based persistence
# volumes:
#   h2-data:
#     driver: local
```

#### application-docker.yml (For containerized H2)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 with file persistence in Docker (optional)
  datasource:
    url: jdbc:h2:file:/app/data/paymentdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: true  # Allow access from outside container
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: false

server:
  port: 8080

logging:
  level:
    com.hiberus.banking: INFO
    org.springframework.web: WARN
```

#### Docker Commands
```bash
# Build image
docker build -t payment-initiation-service:latest .

# Run with docker-compose
docker-compose up -d

# View logs
docker-compose logs -f payment-initiation-service

# Stop services
docker-compose down

# Rebuild and restart
docker-compose up -d --build

# Access H2 Console (if enabled)
# URL: http://localhost:8080/h2-console
# JDBC URL: jdbc:h2:mem:paymentdb
# Username: sa
# Password: (empty)

# Health check
curl http://localhost:8080/actuator/health

# Test API
curl -X POST http://localhost:8080/payment-initiation/payment-orders \
  -H "Content-Type: application/json" \
  -d '{
    "payerReference": "CUST-123",
    "payeeReference": "CUST-456",
    "amount": {
      "value": 1500.50,
      "currency": "USD"
    },
    "paymentPurpose": "Invoice payment"
  }'
```

#### .dockerignore
```
.git
.gitignore
.gradle
build/
!build/libs/*.jar
*.md
.idea
*.iml
.vscode
target/
*.log
```

#### Alternative: Dockerfile with tests included
```dockerfile
# Build and test stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .
COPY config config
COPY src src

# Run tests and build
RUN ./gradlew clean build --no-daemon

# Runtime stage (same as before)
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

COPY --from=builder /app/build/libs/*.jar app.jar

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 11. AI-Assisted Development Documentation

#### Structure for ai/ folder
```
ai/
├── prompts.md                 # All prompts used
├── decisions.md              # Architectural decisions and rationale
└── generations/              # Generated code samples
    ├── openapi-draft.yaml
    ├── domain-skeleton.java
    └── test-generation.java
```

#### Example prompts.md format
```markdown
## Prompt 1: WSDL Analysis
**Prompt**: "Analyze this WSDL for PaymentOrderService and map to BIAN Payment Initiation Service Domain. Identify: operations, data structures, business rules, and status flows."

**Response Summary**: 
- SOAP operations: createPaymentOrder, getPaymentOrder, updateOrderStatus
- Mapped to BIAN: Initiate, Retrieve, Execute
- Key fields: orderId → paymentOrderReference, amount, payer/payee, status

**Manual Corrections**:
- Changed generic "orderId" to BIAN-compliant "paymentOrderReference"
- Added currency field (was missing in WSDL)
- Refined status enum to align with BIAN lifecycle

## Prompt 2: OpenAPI Generation
[...]
```

### 12. Code Style & Conventions

#### Naming Conventions
- **Classes**: PascalCase (e.g., `PaymentOrder`, `InitiatePaymentOrderService`)
- **Methods**: camelCase, verb-based (e.g., `initiatePayment`, `retrieveOrderStatus`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_PAYMENT_AMOUNT`)
- **Packages**: lowercase, domain-driven (e.g., `domain.model`, `adapter.in.rest`)

#### BIAN-Specific Conventions
- Prefix interfaces with use case: `InitiatePaymentOrderUseCase`
- Use "Reference" suffix for IDs: `paymentOrderReference`, `payerReference`
- Status naming: Use BIAN lifecycle terms (INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED)

#### Lombok Usage
```java
@Value                    // For immutable value objects
@Builder(toBuilder=true) // For entities with many fields
@RequiredArgsConstructor // For dependency injection
@Slf4j                   // For logging
```

### 13. Observability & Production Readiness

#### Actuator Configuration
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    tags:
      application: payment-initiation-service
      service-domain: payment-initiation
```

#### Custom Metrics
```java
@Component
@RequiredArgsConstructor
public class PaymentMetrics {
    
    private final MeterRegistry registry;
    
    public void recordPaymentInitiated(PaymentAmount amount) {
        registry.counter("payment.initiated", 
            "currency", amount.getCurrency().toString())
            .increment();
        
        registry.summary("payment.amount")
            .record(amount.getValue().doubleValue());
    }
}
```

#### Logging Best Practices
```java
// Structured logging
log.info("Payment order initiated", 
    kv("paymentOrderReference", order.getId()),
    kv("amount", order.getAmount().getValue()),
    kv("status", order.getStatus()));

// Never log sensitive data (PII)
// Use correlation IDs for tracing
```

### 14. Security Considerations

- Validate all inputs at adapter layer
- Use Bean Validation annotations in DTOs
- Implement idempotency using `Idempotency-Key` header
- Add rate limiting for endpoints
- Sanitize error messages (don't expose internal details)

### 15. Documentation Requirements

#### README.md Must Include
1. **Project Overview**: BIAN SD, migration context
2. **Architecture Decision Records (ADRs)**: Why hexagonal, why reactive
3. **Setup Instructions**: Prerequisites, local run, Docker
4. **API Documentation**: Link to Swagger UI, example requests
5. **Testing**: How to run tests, coverage reports
6. **AI Usage**: Summary of prompts and generated code
7. **Quality Gates**: Checkstyle, SpotBugs, JaCoCo results

## Validation Checklist

Before committing code, ensure:
- [ ] Follows hexagonal architecture (no Spring in domain)
- [ ] OpenAPI contract-first approach used (interfaces generated)
- [ ] All BIAN naming conventions followed (payment-initiation, PaymentOrder BQ)
- [ ] MapStruct mappers configured correctly (3 layers: REST, Persistence, Application)
- [ ] Unit tests written for domain and application layers (80%+ coverage)
- [ ] Integration tests with WebTestClient for all endpoints
- [ ] Repository tests for JPA layer
- [ ] `./gradlew check` passes (Checkstyle, SpotBugs, JaCoCo)
- [ ] H2 database configured correctly (in-memory or file-based)
- [ ] Dockerfile builds successfully (`docker build -t payment-service .`)
- [ ] docker-compose up works (`docker-compose up -d`)
- [ ] All endpoints return correct HTTP status codes (201, 200, 404, 400, 500)
- [ ] RFC 7807 error handling implemented (application/problem+json)
- [ ] AI usage documented in ai/ folder (prompts.md, decisions.md, generations/)
- [ ] README updated with setup instructions and API documentation
- [ ] Actuator endpoints exposed for health checks
- [ ] Logging configured appropriately (no sensitive data)
- [ ] Value objects are immutable (Lombok @Value)
- [ ] No framework dependencies in domain layer
- [ ] All exceptions properly handled in GlobalExceptionHandler

## Additional Gradle Commands

```bash
# Clean build
./gradlew clean build

# Run with quality checks
./gradlew clean build check

# Run only tests
./gradlew test

# Generate coverage report
./gradlew test jacocoTestReport
# Open: build/reports/jacoco/test/html/index.html

# Run checkstyle only
./gradlew checkstyleMain checkstyleTest

# Run spotbugs only
./gradlew spotbugsMain spotbugsTest

# Build without tests (faster for development)
./gradlew clean build -x test

# Run application locally
./gradlew bootRun

# Generate OpenAPI code
./gradlew openApiGenerate

# View project dependencies
./gradlew dependencies

# View available tasks
./gradlew tasks
```

## Remember
- **BIAN alignment is non-negotiable**: Always validate against BIAN standards
- **Domain purity**: Keep domain layer framework-agnostic
- **Test-first mindset**: Write tests before implementation
- **Document AI usage**: Every AI-generated code must be reviewed and documented
- **Quality over speed**: Meet all quality gates before considering "done"

---

When in doubt, ask yourself: "Does this align with BIAN Payment Initiation Service Domain standards?" and "Is this following hexagonal architecture principles?"
          example: "PO-0001"
        paymentOrderStatus:
          $ref: '#/components/schemas/PaymentStatus'
        externalReference:
          type: string
        debtorAccount:
          $ref: '#/components/schemas/Account'
        creditorAccount:
          $ref: '#/components/schemas/Account'
        instructedAmount:
          $ref: '#/components/schemas/InstructedAmount'
        remittanceInformation:
          type: string
        requestedExecutionDate:
          type: string
          format: date
        createdAt:
          type: string
          format: date-time
          description: Timestamp when order was created
    
    # Full Retrieve Response (superset of initiate response)
    RetrievePaymentOrderResponse:
      allOf:
        - $ref: '#/components/schemas/InitiatePaymentOrderResponse'
        - type: object
          properties:
            updatedAt:
              type: string
              format: date-time
              description: Timestamp of last update
            statusReason:
              type: string
              description: Detailed reason for current status
    
    # Status Response (mapped from SOAP GetPaymentOrderStatusResponse)
    PaymentOrderStatusResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
          pattern: '^PO-[0-9]{4,}
```yaml
# openapi.yaml structure
openapi: 3.0.3
info:
  title: BIAN Payment Initiation API
  version: 1.0.0
  description: Payment Order management aligned with BIAN Service Domain

servers:
  - url: http://localhost:8080
    description: Local development server

paths:
  /payment-initiation/payment-orders:
    post:
      operationId: initiatePaymentOrder
      tags: [Payment Initiation]
      summary: Initiate a new payment order
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InitiatePaymentOrderRequest'
      responses:
        '201':
          description: Payment order successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InitiatePaymentOrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '500':
          $ref: '#/components/responses/InternalServerError'
  
  /payment-initiation/payment-orders/{id}:
    get:
      operationId: retrievePaymentOrder
      tags: [Payment Initiation]
      summary: Retrieve payment order details
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RetrievePaymentOrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /payment-initiation/payment-orders/{id}/status:
    get:
      operationId: retrievePaymentOrderStatus
      tags: [Payment Initiation]
      summary: Retrieve payment order status
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order status retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentOrderStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    InitiatePaymentOrderRequest:
      type: object
      required: 
        - payerReference
        - payeeReference
        - amount
      properties:
        payerReference:
          type: string
          description: Reference to the payer (customer ID)
          example: "CUST-12345"
        payeeReference:
          type: string
          description: Reference to the payee (beneficiary ID)
          example: "CUST-67890"
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
          description: Purpose of the payment
          example: "Invoice payment"
        paymentDate:
          type: string
          format: date
          description: Requested payment date
          example: "2024-11-20"
    
    InitiatePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
          description: BIAN-compliant payment order reference
          example: "PO-2024-001234"
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        createdAt:
          type: string
          format: date-time
    
    RetrievePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
        paymentDate:
          type: string
          format: date
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    PaymentOrderStatusResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        statusReason:
          type: string
          description: Reason for current status
        lastUpdated:
          type: string
          format: date-time
    
    PaymentAmount:
      type: object
      required:
        - value
        - currency
      properties:
        value:
          type: number
          format: double
          minimum: 0.01
          example: 1500.50
        currency:
          type: string
          enum: [USD, EUR, GBP, JPY]
          example: "USD"
    
    ProblemDetail:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request - validation errors
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    NotFound:
      description: Resource not found
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    InternalServerError:
      description: Internal server error
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
```

#### Gradle Configuration (build.gradle)
```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'org.openapi.generator' version '7.0.1'
    id 'checkstyle'
    id 'com.github.spotbugs' version '6.0.0'
    id 'jacoco'
}

group = 'com.hiberus.banking'
version = '1.0.0'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

ext {
    mapstructVersion = '1.5.5.Final'
    lombokVersion = '1.18.30'
    openApiVersion = '2.2.0'
}

dependencies {
    // Spring Boot Starters
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    
    // H2 Database
    runtimeOnly 'com.h2database:h2'
    
    // OpenAPI
    implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${openApiVersion}"
    
    // MapStruct
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
    
    // Lombok
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    
    // Lombok + MapStruct compatibility
    annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"
    
    // Testing
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-webflux'  // For WebTestClient
    testImplementation 'io.rest-assured:rest-assured:5.4.0'
    testImplementation 'org.assertj:assertj-core'
    
    // Test Lombok
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
}

// OpenAPI Generator Task
openApiGenerate {
    generatorName = 'spring'
    inputSpec = "$projectDir/src/main/resources/openapi.yaml"
    outputDir = "$buildDir/generated"
    apiPackage = 'com.hiberus.banking.payment.adapter.in.rest.api'
    modelPackage = 'com.hiberus.banking.payment.adapter.in.rest.dto'
    invokerPackage = 'com.hiberus.banking.payment.adapter.in.rest.invoker'
    configOptions = [
        interfaceOnly: 'true',
        useSpringBoot3: 'true',
        useTags: 'true',
        dateLibrary: 'java8',
        serializationLibrary: 'jackson',
        hideGenerationTimestamp: 'true'
    ]
}

// Add generated sources to source sets
sourceSets {
    main {
        java {
            srcDirs += "$buildDir/generated/src/main/java"
        }
    }
}

// Compile depends on generation
compileJava.dependsOn tasks.openApiGenerate

// JaCoCo Configuration
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
    }
}

// Checkstyle Configuration
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
}

// SpotBugs Configuration
spotbugs {
    effort = 'max'
    reportLevel = 'high'
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
        }
        xml {
            required = false
        }
    }
}

// Test Configuration
test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

// Build task order
check.dependsOn jacocoTestCoverageVerification
```

#### Controller Implementation (Spring MVC)
```java
@RestController
@RequiredArgsConstructor
@Slf4j
public class PaymentInitiationController implements PaymentInitiationApi {
    
    private final InitiatePaymentOrderUseCase initiateUseCase;
    private final RetrievePaymentOrderUseCase retrieveUseCase;
    private final RetrievePaymentOrderStatusUseCase retrieveStatusUseCase;
    private final PaymentOrderRestMapper mapper;
    
    @Override
    public ResponseEntity<InitiatePaymentOrderResponse> initiatePaymentOrder(
            InitiatePaymentOrderRequest request) {
        
        log.info("Initiating payment order for payer: {}", request.getPayerReference());
        
        PaymentOrder domainOrder = mapper.toDomain(request);
        PaymentOrder initiatedOrder = initiateUseCase.initiate(domainOrder);
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(initiatedOrder);
        
        log.info("Payment order initiated successfully: {}", response.getPaymentOrderReference());
        
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(response);
    }
    
    @Override
    public ResponseEntity<RetrievePaymentOrderResponse> retrievePaymentOrder(String id) {
        
        log.info("Retrieving payment order: {}", id);
        
        PaymentOrder paymentOrder = retrieveUseCase.retrieve(id);
        RetrievePaymentOrderResponse response = mapper.toRetrieveResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
    
    @Override
    public ResponseEntity<PaymentOrderStatusResponse> retrievePaymentOrderStatus(String id) {
        
        log.info("Retrieving payment order status: {}", id);
        
        PaymentOrder paymentOrder = retrieveStatusUseCase.retrieveStatus(id);
        PaymentOrderStatusResponse response = mapper.toStatusResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
}
```

### 5. Spring MVC with H2 Database

#### Application Configuration (application.yml)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 Database Configuration
  datasource:
    url: jdbc:h2:mem:paymentdb
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: false
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
  
  # Jackson Configuration
  jackson:
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

# Server Configuration
server:
  port: 8080
  servlet:
    context-path: /
  error:
    include-message: always
    include-binding-errors: always
    include-exception: false
    include-stacktrace: never

# Management / Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    tags:
      application: ${spring.application.name}
      service-domain: payment-initiation

# Logging
logging:
  level:
    com.hiberus.banking: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

#### JPA Entity Example
```java
@Entity
@Table(name = "payment_orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PaymentOrderEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(name = "payment_order_reference", nullable = false, unique = true, length = 50)
    private String paymentOrderReference;
    
    @Column(name = "payer_reference", nullable = false, length = 50)
    private String payerReference;
    
    @Column(name = "payee_reference", nullable = false, length = 50)
    private String payeeReference;
    
    @Column(name = "amount", nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "currency", nullable = false, length = 3)
    private String currency;
    
    @Column(name = "payment_purpose", length = 255)
    private String paymentPurpose;
    
    @Column(name = "payment_date")
    private LocalDate paymentDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PaymentStatusEntity status;
    
    @Column(name = "status_reason", length = 500)
    private String statusReason;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        if (status == null) {
            status = PaymentStatusEntity.INITIATED;
        }
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

@Getter
@RequiredArgsConstructor
enum PaymentStatusEntity {
    INITIATED("Payment order has been initiated"),
    PENDING("Payment order is pending processing"),
    PROCESSED("Payment order has been processed"),
    COMPLETED("Payment order completed successfully"),
    FAILED("Payment order failed"),
    CANCELLED("Payment order has been cancelled");
    
    private final String description;
}
```

#### Spring Data JPA Repository
```java
@Repository
public interface PaymentOrderJpaRepository extends JpaRepository<PaymentOrderEntity, UUID> {
    
    Optional<PaymentOrderEntity> findByPaymentOrderReference(String paymentOrderReference);
    
    List<PaymentOrderEntity> findByPayerReference(String payerReference);
    
    List<PaymentOrderEntity> findByStatus(PaymentStatusEntity status);
    
    @Query("SELECT p FROM PaymentOrderEntity p WHERE p.createdAt BETWEEN :startDate AND :endDate")
    List<PaymentOrderEntity> findByDateRange(
        @Param("startDate") LocalDateTime startDate, 
        @Param("endDate") LocalDateTime endDate
    );
    
    boolean existsByPaymentOrderReference(String paymentOrderReference);
}
```

#### Repository Adapter Implementation
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PaymentOrderRepositoryAdapter implements PaymentOrderRepository {
    
    private final PaymentOrderJpaRepository jpaRepository;
    private final PaymentOrderPersistenceMapper persistenceMapper;
    
    @Override
    public PaymentOrder save(PaymentOrder paymentOrder) {
        log.debug("Saving payment order: {}", paymentOrder.getPaymentOrderReference());
        
        PaymentOrderEntity entity = persistenceMapper.toEntity(paymentOrder);
        PaymentOrderEntity savedEntity = jpaRepository.save(entity);
        
        log.debug("Payment order saved with ID: {}", savedEntity.getId());
        return persistenceMapper.toDomain(savedEntity);
    }
    
    @Override
    public Optional<PaymentOrder> findByReference(String paymentOrderReference) {
        log.debug("Finding payment order by reference: {}", paymentOrderReference);
        
        return jpaRepository.findByPaymentOrderReference(paymentOrderReference)
            .map(persistenceMapper::toDomain);
    }
    
    @Override
    public boolean existsByReference(String paymentOrderReference) {
        return jpaRepository.existsByPaymentOrderReference(paymentOrderReference);
    }
    
    @Override
    public List<PaymentOrder> findAll() {
        return jpaRepository.findAll().stream()
            .map(persistenceMapper::toDomain)
            .collect(Collectors.toList());
    }
}
```

#### H2 Console Configuration
```java
@Configuration
public class H2ConsoleConfig {
    
    @Bean
    public ServletRegistrationBean<WebServlet> h2Console() {
        ServletRegistrationBean<WebServlet> registration = 
            new ServletRegistrationBean<>(new WebServlet());
        registration.addUrlMappings("/h2-console/*");
        return registration;
    }
}
```

#### Data Initialization (Optional - for testing)
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class DataInitializer {
    
    private final PaymentOrderJpaRepository repository;
    
    @EventListener(ApplicationReadyEvent.class)
    public void loadSampleData() {
        if (repository.count() == 0) {
            log.info("Loading sample payment orders...");
            
            PaymentOrderEntity order1 = PaymentOrderEntity.builder()
                .paymentOrderReference("PO-2024-001")
                .payerReference("CUST-12345")
                .payeeReference("CUST-67890")
                .amount(new BigDecimal("1500.50"))
                .currency("USD")
                .paymentPurpose("Invoice payment")
                .paymentDate(LocalDate.now())
                .status(PaymentStatusEntity.INITIATED)
                .build();
            
            repository.save(order1);
            log.info("Sample data loaded successfully");
        }
    }
}
```

### 6. MapStruct Mappers (Three Layers)

MapStruct is used for clean transformation between layers. There are THREE types of mappers:

#### 1. REST Mapper (Adapter Layer: DTO ↔ Domain)
```java
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR)
public interface PaymentOrderRestMapper {
    
    // Request DTO → Domain
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "paymentOrderReference", ignore = true)
    @Mapping(target = "status", constant = "INITIATED")
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    @Mapping(target = "updatedAt", ignore = true)
    PaymentOrder toDomain(InitiatePaymentOrderRequest request);
    
    // Domain → Response DTO (Initiate)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    InitiatePaymentOrderResponse toInitiateResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Retrieve)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    RetrievePaymentOrderResponse toRetrieveResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Status)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    @Mapping(source = "updatedAt", target = "lastUpdated")
    PaymentOrderStatusResponse toStatusResponse(PaymentOrder paymentOrder);
    
    // Value Object mappings
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    PaymentAmount toPaymentAmount(com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount dtoAmount);
    
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount toPaymentAmountDto(PaymentAmount domainAmount);
}
```

#### 2. Persistence Mapper (Adapter Layer: Domain ↔ Entity)
```java
@Mapper(componentModel = "spring", 
        unmappedTargetPolicy = ReportingPolicy.ERROR,
        uses = {PaymentStatusMapper.class})
public interface PaymentOrderPersistenceMapper {
    
    // Domain → Entity
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "payerReference.value", target = "payerReference")
    @Mapping(source = "payeeReference.value", target = "payeeReference")
    @Mapping(source = "amount.value", target = "amount")
    @Mapping(source = "amount.currency", target = "currency")
    @Mapping(source = "status", target = "status")
    @Mapping(target = "id", ignore = true)  // Let JPA generate
    PaymentOrderEntity toEntity(PaymentOrder domain);
    
    // Entity → Domain
    @Mapping(source = "paymentOrderReference", target = "id.value")
    @Mapping(source = "payerReference", target = "payerReference.value")
    @Mapping(source = "payeeReference", target = "payeeReference.value")
    @Mapping(source = "amount", target = "amount.value")
    @Mapping(source = "currency", target = "amount.currency")
    PaymentOrder toDomain(PaymentOrderEntity entity);
    
    // Custom mapping for status
    default PaymentStatus mapStatus(PaymentStatusEntity entityStatus) {
        return PaymentStatus.valueOf(entityStatus.name());
    }
    
    default PaymentStatusEntity mapStatus(PaymentStatus domainStatus) {
        return PaymentStatusEntity.valueOf(domainStatus.name());
    }
}
```

#### 3. Application Mapper (Optional: Complex transformations)
```java
@Mapper(componentModel = "spring")
public interface PaymentOrderApplicationMapper {
    
    // For complex business logic transformations
    @Mapping(target = "enrichedData", expression = "java(enrichData(source))")
    PaymentOrder enrichForProcessing(PaymentOrder source);
    
    default String enrichData(PaymentOrder order) {
        // Complex business logic here
        return "ENRICHED-" + order.getPaymentOrderReference();
    }
}
```

#### MapStruct Configuration Best Practices
```java
@MapperConfig(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.ERROR,  // Fail on unmapped fields
    unmappedSourcePolicy = ReportingPolicy.WARN,    // Warn on unmapped sources
    mappingInheritanceStrategy = MappingInheritanceStrategy.AUTO_INHERIT_FROM_CONFIG
)
public interface CentralMapperConfig {
}

// Then use it in mappers
@Mapper(config = CentralMapperConfig.class)
public interface PaymentOrderRestMapper {
    // ... mappings
}
```

#### Testing MapStruct Mappers
```java
@SpringBootTest
class PaymentOrderRestMapperTest {
    
    @Autowired
    private PaymentOrderRestMapper mapper;
    
    @Test
    @DisplayName("Should map InitiatePaymentOrderRequest to PaymentOrder domain")
    void shouldMapRequestToDomain() {
        // Given
        InitiatePaymentOrderRequest request = new InitiatePaymentOrderRequest()
            .payerReference("CUST-123")
            .payeeReference("CUST-456")
            .amount(new com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount()
                .value(1000.0)
                .currency("USD"))
            .paymentPurpose("Test payment");
        
        // When
        PaymentOrder domain = mapper.toDomain(request);
        
        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getPayerReference().getValue()).isEqualTo("CUST-123");
        assertThat(domain.getPayeeReference().getValue()).isEqualTo("CUST-456");
        assertThat(domain.getAmount().getValue()).isEqualByComparingTo("1000.0");
        assertThat(domain.getAmount().getCurrency()).isEqualTo(Currency.USD);
        assertThat(domain.getStatus()).isEqualTo(PaymentStatus.INITIATED);
    }
    
    @Test
    @DisplayName("Should map PaymentOrder domain to InitiatePaymentOrderResponse")
    void shouldMapDomainToResponse() {
        // Given
        PaymentOrder domain = PaymentOrderMother.valid();
        
        // When
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(domain);
        
        // Then
        assertThat(response).isNotNull();
        assertThat(response.getPaymentOrderReference()).isEqualTo(domain.getId().getValue());
        assertThat(response.getPaymentOrderStatus()).isEqualTo(domain.getStatus().name());
    }
}
```

### 7. Testing Strategy with Spring MVC and WebTestClient

#### Unit Tests (Domain & Application Layer)
```java
@ExtendWith(MockitoExtension.class)
class InitiatePaymentOrderServiceTest {
    
    @Mock
    private PaymentOrderRepository repository;
    
    @Mock
    private PaymentValidationPort validationPort;
    
    @InjectMocks
    private InitiatePaymentOrderService service;
    
    @Test
    @DisplayName("Should initiate payment order when valid")
    void shouldInitiatePaymentOrderWhenValid() {
        // Given
        PaymentOrder order = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenReturn(order);
        
        // When
        PaymentOrder result = service.initiate(order);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getStatus()).isEqualTo(PaymentStatus.INITIATED);
        assertThat(result.getPaymentOrderReference()).isNotNull();
        
        verify(validationPort).validate(order);
        verify(repository).save(any(PaymentOrder.class));
    }
    
    @Test
    @DisplayName("Should throw InvalidPaymentException when validation fails")
    void shouldThrowExceptionWhenValidationFails() {
        // Given
        PaymentOrder order = PaymentOrderMother.withInvalidAmount();
        when(validationPort.validate(any())).thenReturn(false);
        
        // When & Then
        assertThatThrownBy(() -> service.initiate(order))
            .isInstanceOf(InvalidPaymentException.class)
            .hasMessageContaining("validation failed");
        
        verify(validationPort).validate(order);
        verify(repository, never()).save(any());
    }
    
    @Test
    @DisplayName("Should generate unique payment order reference")
    void shouldGenerateUniqueReference() {
        // Given
        PaymentOrder order1 = PaymentOrderMother.valid();
        PaymentOrder order2 = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenAnswer(inv -> inv.getArgument(0));
        
        // When
        PaymentOrder result1 = service.initiate(order1);
        PaymentOrder result2 = service.initiate(order2);
        
        // Then
        assertThat(result1.getPaymentOrderReference())
            .isNotEqualTo(result2.getPaymentOrderReference());
    }
}
```

#### Integration Tests with WebTestClient (Recommended for Spring MVC)
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class PaymentInitiationIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        repository.deleteAll();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 201 Created")
    void shouldInitiatePaymentOrderSuccessfully() {
        // Given
        InitiatePaymentOrderRequest request = InitiatePaymentOrderRequest.builder()
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1500.50)
                .currency("USD")
                .build())
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .build();
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .exchange()
            .expectStatus().isCreated()
            .expectHeader().exists("Location")
            .expectBody(InitiatePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getPaymentOrderReference()).startsWith("PO-");
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getPayeeReference()).isEqualTo("CUST-67890");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
                assertThat(response.getCreatedAt()).isNotNull();
            });
        
        // Verify database
        assertThat(repository.count()).isEqualTo(1);
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 200 OK")
    void shouldRetrievePaymentOrderSuccessfully() {
        // Given - Create a payment order first
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(RetrievePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id}/status - Should return 200 OK")
    void shouldRetrievePaymentOrderStatusSuccessfully() {
        // Given
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}/status", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(PaymentOrderStatusResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getLastUpdated()).isNotNull();
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 404 Not Found")
    void shouldReturn404WhenPaymentOrderNotFound() {
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", "NON-EXISTENT")
            .exchange()
            .expectStatus().isNotFound()
            .expectBody()
            .jsonPath("$.title").isEqualTo("Payment Order Not Found")
            .jsonPath("$.status").isEqualTo(404)
            .jsonPath("$.detail").exists();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 400 Bad Request for invalid data")
    void shouldReturn400ForInvalidRequest() {
        // Given - Invalid request (missing required fields)
        String invalidRequest = """
            {
                "payerReference": "CUST-123"
            }
            """;
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(invalidRequest)
            .exchange()
            .expectStatus().isBadRequest()
            .expectBody()
            .jsonPath("$.title").exists()
            .jsonPath("$.status").isEqualTo(400);
    }
    
    @Test
    @DisplayName("Should handle concurrent payment order creation")
    void shouldHandleConcurrentCreation() throws Exception {
        // Given
        int numberOfThreads = 5;
        ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);
        CountDownLatch latch = new CountDownLatch(numberOfThreads);
        
        // When
        for (int i = 0; i < numberOfThreads; i++) {
            final int index = i;
            executorService.submit(() -> {
                try {
                    InitiatePaymentOrderRequest request = createRequest("PAYER-" + index);
                    webTestClient.post()
                        .uri("/payment-initiation/payment-orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(request)
                        .exchange()
                        .expectStatus().isCreated();
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(10, TimeUnit.SECONDS);
        executorService.shutdown();
        
        // Then
        assertThat(repository.count()).isEqualTo(numberOfThreads);
    }
    
    // Helper methods
    private PaymentOrderEntity createSampleEntity() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-TEST-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Test payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
    
    private InitiatePaymentOrderRequest createRequest(String payerRef) {
        return InitiatePaymentOrderRequest.builder()
            .payerReference(payerRef)
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1000.0)
                .currency("USD")
                .build())
            .paymentPurpose("Concurrent test")
            .build();
    }
}
```

#### Alternative: REST Assured for Integration Tests
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class PaymentInitiationRestAssuredTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        RestAssured.basePath = "/payment-initiation";
        repository.deleteAll();
    }
    
    @Test
    void shouldInitiatePaymentOrder() {
        given()
            .contentType(ContentType.JSON)
            .body(createValidRequest())
        .when()
            .post("/payment-orders")
        .then()
            .statusCode(201)
            .body("paymentOrderReference", notNullValue())
            .body("paymentOrderStatus", equalTo("INITIATED"))
            .body("amount.value", equalTo(1500.50f))
            .body("amount.currency", equalTo("USD"));
    }
    
    @Test
    void shouldRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity saved = repository.save(createSampleEntity());
        
        // When & Then
        given()
            .pathParam("id", saved.getPaymentOrderReference())
        .when()
            .get("/payment-orders/{id}")
        .then()
            .statusCode(200)
            .body("paymentOrderReference", equalTo(saved.getPaymentOrderReference()))
            .body("paymentOrderStatus", equalTo("INITIATED"));
    }
}
```

#### Test Data Builders (Object Mother Pattern)
```java
public class PaymentOrderMother {
    
    public static PaymentOrder valid() {
        return PaymentOrder.builder()
            .id(PaymentOrderId.generate())
            .payerReference(PayerReference.of("CUST-12345"))
            .payeeReference(PayeeReference.of("CUST-67890"))
            .amount(PaymentAmount.of(1500.50, Currency.USD))
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatus.INITIATED)
            .createdAt(LocalDateTime.now())
            .build();
    }
    
    public static PaymentOrder withInvalidAmount() {
        return valid().toBuilder()
            .amount(PaymentAmount.of(-100.00, Currency.USD))
            .build();
    }
    
    public static PaymentOrder withStatus(PaymentStatus status) {
        return valid().toBuilder()
            .status(status)
            .build();
    }
    
    public static PaymentOrder pending() {
        return withStatus(PaymentStatus.PENDING);
    }
    
    public static PaymentOrder completed() {
        return withStatus(PaymentStatus.COMPLETED);
    }
}

public class PaymentOrderEntityMother {
    
    public static PaymentOrderEntity valid() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
}
```

#### Repository Tests
```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class PaymentOrderJpaRepositoryTest {
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    @DisplayName("Should save and retrieve payment order")
    void shouldSaveAndRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity entity = PaymentOrderEntityMother.valid();
        
        // When
        PaymentOrderEntity saved = repository.save(entity);
        entityManager.flush();
        entityManager.clear();
        
        // Then
        Optional<PaymentOrderEntity> found = repository.findByPaymentOrderReference(
            saved.getPaymentOrderReference()
        );
        
        assertThat(found).isPresent();
        assertThat(found.get().getPayerReference()).isEqualTo("CUST-12345");
        assertThat(found.get().getAmount()).isEqualByComparingTo("1500.50");
    }
    
    @Test
    @DisplayName("Should find payment orders by status")
    void shouldFindByStatus() {
        // Given
        repository.save(PaymentOrderEntityMother.valid());
        repository.save(PaymentOrderEntityMother.valid().toBuilder()
            .paymentOrderReference("PO-2024-002")
            .status(PaymentStatusEntity.COMPLETED)
            .build());
        entityManager.flush();
        
        // When
        List<PaymentOrderEntity> initiated = repository.findByStatus(PaymentStatusEntity.INITIATED);
        List<PaymentOrderEntity> completed = repository.findByStatus(PaymentStatusEntity.COMPLETED);
        
        // Then
        assertThat(initiated).hasSize(1);
        assertThat(completed).hasSize(1);
    }
}
```

### 8. Quality Gates (Mandatory - Gradle)

#### JaCoCo Configuration (Gradle)
```groovy
// build.gradle
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                '**/dto/**',
                '**/entity/**',
                '**/config/**',
                '**/*Application.class',
                '**/*MapperImpl.class'  // Exclude MapStruct generated classes
            ])
        }))
    }
}

jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
        
        rule {
            element = 'CLASS'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.70
            }
            excludes = [
                '*.dto.*',
                '*.entity.*',
                '*.config.*',
                '*Application',
                '*MapperImpl'
            ]
        }
    }
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

check.dependsOn jacocoTestCoverageVerification
```

#### Checkstyle Configuration (Gradle)
```groovy
// build.gradle
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
    configProperties = [
        'checkstyle.suppressions.file': "${project.rootDir}/config/checkstyle/suppressions.xml"
    ]
}

checkstyleMain {
    source = 'src/main/java'
    exclude '**/dto/**', '**/entity/**'  // Exclude generated code
}

checkstyleTest {
    source = 'src/test/java'
}

tasks.withType(Checkstyle) {
    reports {
        xml.required = true
        html.required = true
    }
}
```

#### config/checkstyle/checkstyle.xml
```xml
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
    "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
    "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <property name="charset" value="UTF-8"/>
    <property name="severity" value="error"/>
    <property name="fileExtensions" value="java"/>
    
    <module name="SuppressionFilter">
        <property name="file" value="${checkstyle.suppressions.file}"/>
    </module>
    
    <module name="TreeWalker">
        <!-- Naming Conventions -->
        <module name="TypeName">
            <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="MethodName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="ConstantName">
            <property name="format" value="^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"/>
        </module>
        
        <module name="LocalVariableName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <!-- Code Style -->
        <module name="LeftCurly"/>
        <module name="RightCurly"/>
        <module name="NeedBraces"/>
        
        <module name="WhitespaceAround"/>
        <module name="NoWhitespaceBefore"/>
        
        <!-- Imports -->
        <module name="AvoidStarImport"/>
        <module name="UnusedImports"/>
        <module name="RedundantImport"/>
        
        <!-- Size Violations -->
        <module name="LineLength">
            <property name="max" value="120"/>
        </module>
        
        <module name="MethodLength">
            <property name="max" value="150"/>
        </module>
        
        <!-- Complexity -->
        <module name="CyclomaticComplexity">
            <property name="max" value="15"/>
        </module>
        
        <!-- Best Practices -->
        <module name="EmptyBlock"/>
        <module name="EqualsHashCode"/>
        <module name="SimplifyBooleanExpression"/>
        <module name="SimplifyBooleanReturn"/>
        
        <!-- Annotations -->
        <module name="MissingOverride"/>
    </module>
</module>
```

#### SpotBugs Configuration (Gradle)
```groovy
// build.gradle
spotbugs {
    effort = 'max'
    reportLevel = 'high'
    excludeFilter = file("${project.rootDir}/config/spotbugs/spotbugs-exclude.xml")
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/main/spotbugs.html")
        }
        xml {
            required = false
        }
    }
}

tasks.named('spotbugsTest') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/test/spotbugs.html")
        }
    }
}
```

#### config/spotbugs/spotbugs-exclude.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<FindBugsFilter>
    <!-- Exclude generated code -->
    <Match>
        <Package name="~.*\.dto.*"/>
    </Match>
    
    <Match>
        <Package name="~.*\.entity.*"/>
    </Match>
    
    <Match>
        <Class name="~.*MapperImpl"/>
    </Match>
    
    <!-- Exclude specific bugs for Lombok -->
    <Match>
        <Bug pattern="EI_EXPOSE_REP,EI_EXPOSE_REP2"/>
        <Or>
            <Class name="~.*\.domain\.model\..*"/>
        </Or>
    </Match>
</FindBugsFilter>
```

#### Gradle Verification Tasks
```groovy
// Create custom task to run all quality checks
tasks.register('qualityCheck') {
    dependsOn 'checkstyleMain', 'checkstyleTest', 'spotbugsMain', 'jacocoTestCoverageVerification'
    description = 'Run all quality checks: Checkstyle, SpotBugs, and JaCoCo'
    group = 'verification'
}

// Make 'check' depend on quality checks
check {
    dependsOn 'qualityCheck'
}

// Gradle wrapper
wrapper {
    gradleVersion = '8.5'
    distributionType = Wrapper.DistributionType.ALL
}
```

#### Run Quality Checks
```bash
# Run all quality checks
./gradlew check

# Run individual checks
./gradlew checkstyleMain
./gradlew spotbugsMain
./gradlew test jacocoTestReport
./gradlew jacocoTestCoverageVerification

# Build with quality checks
./gradlew clean build

# Generate reports
./gradlew jacocoTestReport
# Report: build/reports/jacoco/test/html/index.html

./gradlew checkstyleMain
# Report: build/reports/checkstyle/main.html

./gradlew spotbugsMain
# Report: build/reports/spotbugs/main/spotbugs.html
```

### 8. Domain Modeling Best Practices

#### Value Objects
```java
@Value
@Builder
public class PaymentAmount {
    BigDecimal value;
    Currency currency;
    
    public static PaymentAmount of(double value, Currency currency) {
        if (value <= 0) {
            throw new InvalidPaymentException("Amount must be positive");
        }
        return new PaymentAmount(BigDecimal.valueOf(value), currency);
    }
}
```

#### Aggregates
```java
@Builder(toBuilder = true)
@Value
public class PaymentOrder {
    PaymentOrderId id;
    PayerReference payerReference;
    PayeeReference payeeReference;
    PaymentAmount amount;
    PaymentStatus status;
    LocalDateTime createdAt;
    
    // Business invariants
    public PaymentOrder validate() {
        if (status == PaymentStatus.CANCELLED && amount.getValue().compareTo(BigDecimal.ZERO) > 0) {
            throw new InvalidPaymentException("Cancelled orders cannot have positive amount");
        }
        return this;
    }
    
    public PaymentOrder markAsProcessed() {
        if (status != PaymentStatus.INITIATED) {
            throw new InvalidPaymentException("Only initiated orders can be processed");
        }
        return this.toBuilder().status(PaymentStatus.PROCESSED).build();
    }
}
```

#### Domain Events (if needed)
```java
@Value
public class PaymentOrderInitiatedEvent {
    String paymentOrderReference;
    PaymentAmount amount;
    LocalDateTime occurredOn;
}
```

### 9. Error Handling (RFC 7807)

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(PaymentOrderNotFoundException.class)
    public ResponseEntity<ProblemDetail> handleNotFound(PaymentOrderNotFoundException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, 
            ex.getMessage()
        );
        problem.setTitle("Payment Order Not Found");
        problem.setProperty("paymentOrderReference", ex.getPaymentOrderReference());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem);
    }
    
    @ExceptionHandler(InvalidPaymentException.class)
    public ResponseEntity<ProblemDetail> handleInvalidPayment(InvalidPaymentException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST,
            ex.getMessage()
        );
        problem.setTitle("Invalid Payment Order");
        problem.setProperty("validationErrors", ex.getErrors());
        return ResponseEntity.badRequest().body(problem);
    }
}
```

### 10. Docker Configuration with H2

#### Multi-stage Dockerfile (Gradle)
```dockerfile
# Build stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

# Copy Gradle files
COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .

# Copy source code
COPY src src
COPY config config

# Build application (skip tests for faster builds, tests run in CI/CD)
RUN ./gradlew clean build -x test --no-daemon

# Runtime stage
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Create non-root user for security
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# Copy JAR from builder
COPY --from=builder /app/build/libs/*.jar app.jar

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# JVM options
ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC -XX:+UseContainerSupport"

# Run application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

#### docker-compose.yml (H2 in-memory)
```yaml
version: '3.8'

services:
  payment-initiation-service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: payment-initiation-service
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - JAVA_OPTS=-Xms256m -Xmx512m
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - payment-network
    restart: unless-stopped

networks:
  payment-network:
    driver: bridge

# Optional: Add volumes for H2 file-based persistence
# volumes:
#   h2-data:
#     driver: local
```

#### application-docker.yml (For containerized H2)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 with file persistence in Docker (optional)
  datasource:
    url: jdbc:h2:file:/app/data/paymentdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: true  # Allow access from outside container
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: false

server:
  port: 8080

logging:
  level:
    com.hiberus.banking: INFO
    org.springframework.web: WARN
```

#### Docker Commands
```bash
# Build image
docker build -t payment-initiation-service:latest .

# Run with docker-compose
docker-compose up -d

# View logs
docker-compose logs -f payment-initiation-service

# Stop services
docker-compose down

# Rebuild and restart
docker-compose up -d --build

# Access H2 Console (if enabled)
# URL: http://localhost:8080/h2-console
# JDBC URL: jdbc:h2:mem:paymentdb
# Username: sa
# Password: (empty)

# Health check
curl http://localhost:8080/actuator/health

# Test API
curl -X POST http://localhost:8080/payment-initiation/payment-orders \
  -H "Content-Type: application/json" \
  -d '{
    "payerReference": "CUST-123",
    "payeeReference": "CUST-456",
    "amount": {
      "value": 1500.50,
      "currency": "USD"
    },
    "paymentPurpose": "Invoice payment"
  }'
```

#### .dockerignore
```
.git
.gitignore
.gradle
build/
!build/libs/*.jar
*.md
.idea
*.iml
.vscode
target/
*.log
```

#### Alternative: Dockerfile with tests included
```dockerfile
# Build and test stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .
COPY config config
COPY src src

# Run tests and build
RUN ./gradlew clean build --no-daemon

# Runtime stage (same as before)
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

COPY --from=builder /app/build/libs/*.jar app.jar

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 11. AI-Assisted Development Documentation

#### Structure for ai/ folder
```
ai/
├── prompts.md                 # All prompts used
├── decisions.md              # Architectural decisions and rationale
└── generations/              # Generated code samples
    ├── openapi-draft.yaml
    ├── domain-skeleton.java
    └── test-generation.java
```

#### Example prompts.md format
```markdown
## Prompt 1: WSDL Analysis
**Prompt**: "Analyze this WSDL for PaymentOrderService and map to BIAN Payment Initiation Service Domain. Identify: operations, data structures, business rules, and status flows."

**Response Summary**: 
- SOAP operations: createPaymentOrder, getPaymentOrder, updateOrderStatus
- Mapped to BIAN: Initiate, Retrieve, Execute
- Key fields: orderId → paymentOrderReference, amount, payer/payee, status

**Manual Corrections**:
- Changed generic "orderId" to BIAN-compliant "paymentOrderReference"
- Added currency field (was missing in WSDL)
- Refined status enum to align with BIAN lifecycle

## Prompt 2: OpenAPI Generation
[...]
```

### 12. Code Style & Conventions

#### Naming Conventions
- **Classes**: PascalCase (e.g., `PaymentOrder`, `InitiatePaymentOrderService`)
- **Methods**: camelCase, verb-based (e.g., `initiatePayment`, `retrieveOrderStatus`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_PAYMENT_AMOUNT`)
- **Packages**: lowercase, domain-driven (e.g., `domain.model`, `adapter.in.rest`)

#### BIAN-Specific Conventions
- Prefix interfaces with use case: `InitiatePaymentOrderUseCase`
- Use "Reference" suffix for IDs: `paymentOrderReference`, `payerReference`
- Status naming: Use BIAN lifecycle terms (INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED)

#### Lombok Usage
```java
@Value                    // For immutable value objects
@Builder(toBuilder=true) // For entities with many fields
@RequiredArgsConstructor // For dependency injection
@Slf4j                   // For logging
```

### 13. Observability & Production Readiness

#### Actuator Configuration
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    tags:
      application: payment-initiation-service
      service-domain: payment-initiation
```

#### Custom Metrics
```java
@Component
@RequiredArgsConstructor
public class PaymentMetrics {
    
    private final MeterRegistry registry;
    
    public void recordPaymentInitiated(PaymentAmount amount) {
        registry.counter("payment.initiated", 
            "currency", amount.getCurrency().toString())
            .increment();
        
        registry.summary("payment.amount")
            .record(amount.getValue().doubleValue());
    }
}
```

#### Logging Best Practices
```java
// Structured logging
log.info("Payment order initiated", 
    kv("paymentOrderReference", order.getId()),
    kv("amount", order.getAmount().getValue()),
    kv("status", order.getStatus()));

// Never log sensitive data (PII)
// Use correlation IDs for tracing
```

### 14. Security Considerations

- Validate all inputs at adapter layer
- Use Bean Validation annotations in DTOs
- Implement idempotency using `Idempotency-Key` header
- Add rate limiting for endpoints
- Sanitize error messages (don't expose internal details)

### 15. Documentation Requirements

#### README.md Must Include
1. **Project Overview**: BIAN SD, migration context
2. **Architecture Decision Records (ADRs)**: Why hexagonal, why reactive
3. **Setup Instructions**: Prerequisites, local run, Docker
4. **API Documentation**: Link to Swagger UI, example requests
5. **Testing**: How to run tests, coverage reports
6. **AI Usage**: Summary of prompts and generated code
7. **Quality Gates**: Checkstyle, SpotBugs, JaCoCo results

## Validation Checklist

Before committing code, ensure:
- [ ] Follows hexagonal architecture (no Spring in domain)
- [ ] OpenAPI contract-first approach used (interfaces generated)
- [ ] All BIAN naming conventions followed (payment-initiation, PaymentOrder BQ)
- [ ] MapStruct mappers configured correctly (3 layers: REST, Persistence, Application)
- [ ] Unit tests written for domain and application layers (80%+ coverage)
- [ ] Integration tests with WebTestClient for all endpoints
- [ ] Repository tests for JPA layer
- [ ] `./gradlew check` passes (Checkstyle, SpotBugs, JaCoCo)
- [ ] H2 database configured correctly (in-memory or file-based)
- [ ] Dockerfile builds successfully (`docker build -t payment-service .`)
- [ ] docker-compose up works (`docker-compose up -d`)
- [ ] All endpoints return correct HTTP status codes (201, 200, 404, 400, 500)
- [ ] RFC 7807 error handling implemented (application/problem+json)
- [ ] AI usage documented in ai/ folder (prompts.md, decisions.md, generations/)
- [ ] README updated with setup instructions and API documentation
- [ ] Actuator endpoints exposed for health checks
- [ ] Logging configured appropriately (no sensitive data)
- [ ] Value objects are immutable (Lombok @Value)
- [ ] No framework dependencies in domain layer
- [ ] All exceptions properly handled in GlobalExceptionHandler

## Additional Gradle Commands

```bash
# Clean build
./gradlew clean build

# Run with quality checks
./gradlew clean build check

# Run only tests
./gradlew test

# Generate coverage report
./gradlew test jacocoTestReport
# Open: build/reports/jacoco/test/html/index.html

# Run checkstyle only
./gradlew checkstyleMain checkstyleTest

# Run spotbugs only
./gradlew spotbugsMain spotbugsTest

# Build without tests (faster for development)
./gradlew clean build -x test

# Run application locally
./gradlew bootRun

# Generate OpenAPI code
./gradlew openApiGenerate

# View project dependencies
./gradlew dependencies

# View available tasks
./gradlew tasks
```

## Remember
- **BIAN alignment is non-negotiable**: Always validate against BIAN standards
- **Domain purity**: Keep domain layer framework-agnostic
- **Test-first mindset**: Write tests before implementation
- **Document AI usage**: Every AI-generated code must be reviewed and documented
- **Quality over speed**: Meet all quality gates before considering "done"

---

When in doubt, ask yourself: "Does this align with BIAN Payment Initiation Service Domain standards?" and "Is this following hexagonal architecture principles?"
          example: "PO-0001"
        paymentOrderStatus:
          $ref: '#/components/schemas/PaymentStatus'
        statusReason:
          type: string
          description: Reason for current status
          example: "Payment successfully completed"
        lastUpdated:
          type: string
          format: date-time
          description: Last status update timestamp (SOAP lastUpdate)
          example: "2025-10-30T16:25:30Z"
    
    # Account Schema (replaces SOAP separate IBAN fields)
    Account:
      type: object
      required:
        - iban
      properties:
        iban:
          type: string
          description: International Bank Account Number
          pattern: '^[A-Z]{2}[0-9]{2}[A-Z0-9]+
```yaml
# openapi.yaml structure
openapi: 3.0.3
info:
  title: BIAN Payment Initiation API
  version: 1.0.0
  description: Payment Order management aligned with BIAN Service Domain

servers:
  - url: http://localhost:8080
    description: Local development server

paths:
  /payment-initiation/payment-orders:
    post:
      operationId: initiatePaymentOrder
      tags: [Payment Initiation]
      summary: Initiate a new payment order
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InitiatePaymentOrderRequest'
      responses:
        '201':
          description: Payment order successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InitiatePaymentOrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '500':
          $ref: '#/components/responses/InternalServerError'
  
  /payment-initiation/payment-orders/{id}:
    get:
      operationId: retrievePaymentOrder
      tags: [Payment Initiation]
      summary: Retrieve payment order details
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RetrievePaymentOrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /payment-initiation/payment-orders/{id}/status:
    get:
      operationId: retrievePaymentOrderStatus
      tags: [Payment Initiation]
      summary: Retrieve payment order status
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order status retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentOrderStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    InitiatePaymentOrderRequest:
      type: object
      required: 
        - payerReference
        - payeeReference
        - amount
      properties:
        payerReference:
          type: string
          description: Reference to the payer (customer ID)
          example: "CUST-12345"
        payeeReference:
          type: string
          description: Reference to the payee (beneficiary ID)
          example: "CUST-67890"
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
          description: Purpose of the payment
          example: "Invoice payment"
        paymentDate:
          type: string
          format: date
          description: Requested payment date
          example: "2024-11-20"
    
    InitiatePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
          description: BIAN-compliant payment order reference
          example: "PO-2024-001234"
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        createdAt:
          type: string
          format: date-time
    
    RetrievePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
        paymentDate:
          type: string
          format: date
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    PaymentOrderStatusResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        statusReason:
          type: string
          description: Reason for current status
        lastUpdated:
          type: string
          format: date-time
    
    PaymentAmount:
      type: object
      required:
        - value
        - currency
      properties:
        value:
          type: number
          format: double
          minimum: 0.01
          example: 1500.50
        currency:
          type: string
          enum: [USD, EUR, GBP, JPY]
          example: "USD"
    
    ProblemDetail:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request - validation errors
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    NotFound:
      description: Resource not found
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    InternalServerError:
      description: Internal server error
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
```

#### Gradle Configuration (build.gradle)
```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'org.openapi.generator' version '7.0.1'
    id 'checkstyle'
    id 'com.github.spotbugs' version '6.0.0'
    id 'jacoco'
}

group = 'com.hiberus.banking'
version = '1.0.0'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

ext {
    mapstructVersion = '1.5.5.Final'
    lombokVersion = '1.18.30'
    openApiVersion = '2.2.0'
}

dependencies {
    // Spring Boot Starters
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    
    // H2 Database
    runtimeOnly 'com.h2database:h2'
    
    // OpenAPI
    implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${openApiVersion}"
    
    // MapStruct
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
    
    // Lombok
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    
    // Lombok + MapStruct compatibility
    annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"
    
    // Testing
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-webflux'  // For WebTestClient
    testImplementation 'io.rest-assured:rest-assured:5.4.0'
    testImplementation 'org.assertj:assertj-core'
    
    // Test Lombok
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
}

// OpenAPI Generator Task
openApiGenerate {
    generatorName = 'spring'
    inputSpec = "$projectDir/src/main/resources/openapi.yaml"
    outputDir = "$buildDir/generated"
    apiPackage = 'com.hiberus.banking.payment.adapter.in.rest.api'
    modelPackage = 'com.hiberus.banking.payment.adapter.in.rest.dto'
    invokerPackage = 'com.hiberus.banking.payment.adapter.in.rest.invoker'
    configOptions = [
        interfaceOnly: 'true',
        useSpringBoot3: 'true',
        useTags: 'true',
        dateLibrary: 'java8',
        serializationLibrary: 'jackson',
        hideGenerationTimestamp: 'true'
    ]
}

// Add generated sources to source sets
sourceSets {
    main {
        java {
            srcDirs += "$buildDir/generated/src/main/java"
        }
    }
}

// Compile depends on generation
compileJava.dependsOn tasks.openApiGenerate

// JaCoCo Configuration
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
    }
}

// Checkstyle Configuration
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
}

// SpotBugs Configuration
spotbugs {
    effort = 'max'
    reportLevel = 'high'
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
        }
        xml {
            required = false
        }
    }
}

// Test Configuration
test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

// Build task order
check.dependsOn jacocoTestCoverageVerification
```

#### Controller Implementation (Spring MVC)
```java
@RestController
@RequiredArgsConstructor
@Slf4j
public class PaymentInitiationController implements PaymentInitiationApi {
    
    private final InitiatePaymentOrderUseCase initiateUseCase;
    private final RetrievePaymentOrderUseCase retrieveUseCase;
    private final RetrievePaymentOrderStatusUseCase retrieveStatusUseCase;
    private final PaymentOrderRestMapper mapper;
    
    @Override
    public ResponseEntity<InitiatePaymentOrderResponse> initiatePaymentOrder(
            InitiatePaymentOrderRequest request) {
        
        log.info("Initiating payment order for payer: {}", request.getPayerReference());
        
        PaymentOrder domainOrder = mapper.toDomain(request);
        PaymentOrder initiatedOrder = initiateUseCase.initiate(domainOrder);
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(initiatedOrder);
        
        log.info("Payment order initiated successfully: {}", response.getPaymentOrderReference());
        
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(response);
    }
    
    @Override
    public ResponseEntity<RetrievePaymentOrderResponse> retrievePaymentOrder(String id) {
        
        log.info("Retrieving payment order: {}", id);
        
        PaymentOrder paymentOrder = retrieveUseCase.retrieve(id);
        RetrievePaymentOrderResponse response = mapper.toRetrieveResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
    
    @Override
    public ResponseEntity<PaymentOrderStatusResponse> retrievePaymentOrderStatus(String id) {
        
        log.info("Retrieving payment order status: {}", id);
        
        PaymentOrder paymentOrder = retrieveStatusUseCase.retrieveStatus(id);
        PaymentOrderStatusResponse response = mapper.toStatusResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
}
```

### 5. Spring MVC with H2 Database

#### Application Configuration (application.yml)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 Database Configuration
  datasource:
    url: jdbc:h2:mem:paymentdb
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: false
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
  
  # Jackson Configuration
  jackson:
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

# Server Configuration
server:
  port: 8080
  servlet:
    context-path: /
  error:
    include-message: always
    include-binding-errors: always
    include-exception: false
    include-stacktrace: never

# Management / Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    tags:
      application: ${spring.application.name}
      service-domain: payment-initiation

# Logging
logging:
  level:
    com.hiberus.banking: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

#### JPA Entity Example
```java
@Entity
@Table(name = "payment_orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PaymentOrderEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(name = "payment_order_reference", nullable = false, unique = true, length = 50)
    private String paymentOrderReference;
    
    @Column(name = "payer_reference", nullable = false, length = 50)
    private String payerReference;
    
    @Column(name = "payee_reference", nullable = false, length = 50)
    private String payeeReference;
    
    @Column(name = "amount", nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "currency", nullable = false, length = 3)
    private String currency;
    
    @Column(name = "payment_purpose", length = 255)
    private String paymentPurpose;
    
    @Column(name = "payment_date")
    private LocalDate paymentDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PaymentStatusEntity status;
    
    @Column(name = "status_reason", length = 500)
    private String statusReason;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        if (status == null) {
            status = PaymentStatusEntity.INITIATED;
        }
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

@Getter
@RequiredArgsConstructor
enum PaymentStatusEntity {
    INITIATED("Payment order has been initiated"),
    PENDING("Payment order is pending processing"),
    PROCESSED("Payment order has been processed"),
    COMPLETED("Payment order completed successfully"),
    FAILED("Payment order failed"),
    CANCELLED("Payment order has been cancelled");
    
    private final String description;
}
```

#### Spring Data JPA Repository
```java
@Repository
public interface PaymentOrderJpaRepository extends JpaRepository<PaymentOrderEntity, UUID> {
    
    Optional<PaymentOrderEntity> findByPaymentOrderReference(String paymentOrderReference);
    
    List<PaymentOrderEntity> findByPayerReference(String payerReference);
    
    List<PaymentOrderEntity> findByStatus(PaymentStatusEntity status);
    
    @Query("SELECT p FROM PaymentOrderEntity p WHERE p.createdAt BETWEEN :startDate AND :endDate")
    List<PaymentOrderEntity> findByDateRange(
        @Param("startDate") LocalDateTime startDate, 
        @Param("endDate") LocalDateTime endDate
    );
    
    boolean existsByPaymentOrderReference(String paymentOrderReference);
}
```

#### Repository Adapter Implementation
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PaymentOrderRepositoryAdapter implements PaymentOrderRepository {
    
    private final PaymentOrderJpaRepository jpaRepository;
    private final PaymentOrderPersistenceMapper persistenceMapper;
    
    @Override
    public PaymentOrder save(PaymentOrder paymentOrder) {
        log.debug("Saving payment order: {}", paymentOrder.getPaymentOrderReference());
        
        PaymentOrderEntity entity = persistenceMapper.toEntity(paymentOrder);
        PaymentOrderEntity savedEntity = jpaRepository.save(entity);
        
        log.debug("Payment order saved with ID: {}", savedEntity.getId());
        return persistenceMapper.toDomain(savedEntity);
    }
    
    @Override
    public Optional<PaymentOrder> findByReference(String paymentOrderReference) {
        log.debug("Finding payment order by reference: {}", paymentOrderReference);
        
        return jpaRepository.findByPaymentOrderReference(paymentOrderReference)
            .map(persistenceMapper::toDomain);
    }
    
    @Override
    public boolean existsByReference(String paymentOrderReference) {
        return jpaRepository.existsByPaymentOrderReference(paymentOrderReference);
    }
    
    @Override
    public List<PaymentOrder> findAll() {
        return jpaRepository.findAll().stream()
            .map(persistenceMapper::toDomain)
            .collect(Collectors.toList());
    }
}
```

#### H2 Console Configuration
```java
@Configuration
public class H2ConsoleConfig {
    
    @Bean
    public ServletRegistrationBean<WebServlet> h2Console() {
        ServletRegistrationBean<WebServlet> registration = 
            new ServletRegistrationBean<>(new WebServlet());
        registration.addUrlMappings("/h2-console/*");
        return registration;
    }
}
```

#### Data Initialization (Optional - for testing)
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class DataInitializer {
    
    private final PaymentOrderJpaRepository repository;
    
    @EventListener(ApplicationReadyEvent.class)
    public void loadSampleData() {
        if (repository.count() == 0) {
            log.info("Loading sample payment orders...");
            
            PaymentOrderEntity order1 = PaymentOrderEntity.builder()
                .paymentOrderReference("PO-2024-001")
                .payerReference("CUST-12345")
                .payeeReference("CUST-67890")
                .amount(new BigDecimal("1500.50"))
                .currency("USD")
                .paymentPurpose("Invoice payment")
                .paymentDate(LocalDate.now())
                .status(PaymentStatusEntity.INITIATED)
                .build();
            
            repository.save(order1);
            log.info("Sample data loaded successfully");
        }
    }
}
```

### 6. MapStruct Mappers (Three Layers)

MapStruct is used for clean transformation between layers. There are THREE types of mappers:

#### 1. REST Mapper (Adapter Layer: DTO ↔ Domain)
```java
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR)
public interface PaymentOrderRestMapper {
    
    // Request DTO → Domain
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "paymentOrderReference", ignore = true)
    @Mapping(target = "status", constant = "INITIATED")
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    @Mapping(target = "updatedAt", ignore = true)
    PaymentOrder toDomain(InitiatePaymentOrderRequest request);
    
    // Domain → Response DTO (Initiate)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    InitiatePaymentOrderResponse toInitiateResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Retrieve)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    RetrievePaymentOrderResponse toRetrieveResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Status)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    @Mapping(source = "updatedAt", target = "lastUpdated")
    PaymentOrderStatusResponse toStatusResponse(PaymentOrder paymentOrder);
    
    // Value Object mappings
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    PaymentAmount toPaymentAmount(com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount dtoAmount);
    
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount toPaymentAmountDto(PaymentAmount domainAmount);
}
```

#### 2. Persistence Mapper (Adapter Layer: Domain ↔ Entity)
```java
@Mapper(componentModel = "spring", 
        unmappedTargetPolicy = ReportingPolicy.ERROR,
        uses = {PaymentStatusMapper.class})
public interface PaymentOrderPersistenceMapper {
    
    // Domain → Entity
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "payerReference.value", target = "payerReference")
    @Mapping(source = "payeeReference.value", target = "payeeReference")
    @Mapping(source = "amount.value", target = "amount")
    @Mapping(source = "amount.currency", target = "currency")
    @Mapping(source = "status", target = "status")
    @Mapping(target = "id", ignore = true)  // Let JPA generate
    PaymentOrderEntity toEntity(PaymentOrder domain);
    
    // Entity → Domain
    @Mapping(source = "paymentOrderReference", target = "id.value")
    @Mapping(source = "payerReference", target = "payerReference.value")
    @Mapping(source = "payeeReference", target = "payeeReference.value")
    @Mapping(source = "amount", target = "amount.value")
    @Mapping(source = "currency", target = "amount.currency")
    PaymentOrder toDomain(PaymentOrderEntity entity);
    
    // Custom mapping for status
    default PaymentStatus mapStatus(PaymentStatusEntity entityStatus) {
        return PaymentStatus.valueOf(entityStatus.name());
    }
    
    default PaymentStatusEntity mapStatus(PaymentStatus domainStatus) {
        return PaymentStatusEntity.valueOf(domainStatus.name());
    }
}
```

#### 3. Application Mapper (Optional: Complex transformations)
```java
@Mapper(componentModel = "spring")
public interface PaymentOrderApplicationMapper {
    
    // For complex business logic transformations
    @Mapping(target = "enrichedData", expression = "java(enrichData(source))")
    PaymentOrder enrichForProcessing(PaymentOrder source);
    
    default String enrichData(PaymentOrder order) {
        // Complex business logic here
        return "ENRICHED-" + order.getPaymentOrderReference();
    }
}
```

#### MapStruct Configuration Best Practices
```java
@MapperConfig(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.ERROR,  // Fail on unmapped fields
    unmappedSourcePolicy = ReportingPolicy.WARN,    // Warn on unmapped sources
    mappingInheritanceStrategy = MappingInheritanceStrategy.AUTO_INHERIT_FROM_CONFIG
)
public interface CentralMapperConfig {
}

// Then use it in mappers
@Mapper(config = CentralMapperConfig.class)
public interface PaymentOrderRestMapper {
    // ... mappings
}
```

#### Testing MapStruct Mappers
```java
@SpringBootTest
class PaymentOrderRestMapperTest {
    
    @Autowired
    private PaymentOrderRestMapper mapper;
    
    @Test
    @DisplayName("Should map InitiatePaymentOrderRequest to PaymentOrder domain")
    void shouldMapRequestToDomain() {
        // Given
        InitiatePaymentOrderRequest request = new InitiatePaymentOrderRequest()
            .payerReference("CUST-123")
            .payeeReference("CUST-456")
            .amount(new com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount()
                .value(1000.0)
                .currency("USD"))
            .paymentPurpose("Test payment");
        
        // When
        PaymentOrder domain = mapper.toDomain(request);
        
        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getPayerReference().getValue()).isEqualTo("CUST-123");
        assertThat(domain.getPayeeReference().getValue()).isEqualTo("CUST-456");
        assertThat(domain.getAmount().getValue()).isEqualByComparingTo("1000.0");
        assertThat(domain.getAmount().getCurrency()).isEqualTo(Currency.USD);
        assertThat(domain.getStatus()).isEqualTo(PaymentStatus.INITIATED);
    }
    
    @Test
    @DisplayName("Should map PaymentOrder domain to InitiatePaymentOrderResponse")
    void shouldMapDomainToResponse() {
        // Given
        PaymentOrder domain = PaymentOrderMother.valid();
        
        // When
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(domain);
        
        // Then
        assertThat(response).isNotNull();
        assertThat(response.getPaymentOrderReference()).isEqualTo(domain.getId().getValue());
        assertThat(response.getPaymentOrderStatus()).isEqualTo(domain.getStatus().name());
    }
}
```

### 7. Testing Strategy with Spring MVC and WebTestClient

#### Unit Tests (Domain & Application Layer)
```java
@ExtendWith(MockitoExtension.class)
class InitiatePaymentOrderServiceTest {
    
    @Mock
    private PaymentOrderRepository repository;
    
    @Mock
    private PaymentValidationPort validationPort;
    
    @InjectMocks
    private InitiatePaymentOrderService service;
    
    @Test
    @DisplayName("Should initiate payment order when valid")
    void shouldInitiatePaymentOrderWhenValid() {
        // Given
        PaymentOrder order = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenReturn(order);
        
        // When
        PaymentOrder result = service.initiate(order);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getStatus()).isEqualTo(PaymentStatus.INITIATED);
        assertThat(result.getPaymentOrderReference()).isNotNull();
        
        verify(validationPort).validate(order);
        verify(repository).save(any(PaymentOrder.class));
    }
    
    @Test
    @DisplayName("Should throw InvalidPaymentException when validation fails")
    void shouldThrowExceptionWhenValidationFails() {
        // Given
        PaymentOrder order = PaymentOrderMother.withInvalidAmount();
        when(validationPort.validate(any())).thenReturn(false);
        
        // When & Then
        assertThatThrownBy(() -> service.initiate(order))
            .isInstanceOf(InvalidPaymentException.class)
            .hasMessageContaining("validation failed");
        
        verify(validationPort).validate(order);
        verify(repository, never()).save(any());
    }
    
    @Test
    @DisplayName("Should generate unique payment order reference")
    void shouldGenerateUniqueReference() {
        // Given
        PaymentOrder order1 = PaymentOrderMother.valid();
        PaymentOrder order2 = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenAnswer(inv -> inv.getArgument(0));
        
        // When
        PaymentOrder result1 = service.initiate(order1);
        PaymentOrder result2 = service.initiate(order2);
        
        // Then
        assertThat(result1.getPaymentOrderReference())
            .isNotEqualTo(result2.getPaymentOrderReference());
    }
}
```

#### Integration Tests with WebTestClient (Recommended for Spring MVC)
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class PaymentInitiationIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        repository.deleteAll();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 201 Created")
    void shouldInitiatePaymentOrderSuccessfully() {
        // Given
        InitiatePaymentOrderRequest request = InitiatePaymentOrderRequest.builder()
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1500.50)
                .currency("USD")
                .build())
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .build();
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .exchange()
            .expectStatus().isCreated()
            .expectHeader().exists("Location")
            .expectBody(InitiatePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getPaymentOrderReference()).startsWith("PO-");
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getPayeeReference()).isEqualTo("CUST-67890");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
                assertThat(response.getCreatedAt()).isNotNull();
            });
        
        // Verify database
        assertThat(repository.count()).isEqualTo(1);
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 200 OK")
    void shouldRetrievePaymentOrderSuccessfully() {
        // Given - Create a payment order first
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(RetrievePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id}/status - Should return 200 OK")
    void shouldRetrievePaymentOrderStatusSuccessfully() {
        // Given
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}/status", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(PaymentOrderStatusResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getLastUpdated()).isNotNull();
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 404 Not Found")
    void shouldReturn404WhenPaymentOrderNotFound() {
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", "NON-EXISTENT")
            .exchange()
            .expectStatus().isNotFound()
            .expectBody()
            .jsonPath("$.title").isEqualTo("Payment Order Not Found")
            .jsonPath("$.status").isEqualTo(404)
            .jsonPath("$.detail").exists();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 400 Bad Request for invalid data")
    void shouldReturn400ForInvalidRequest() {
        // Given - Invalid request (missing required fields)
        String invalidRequest = """
            {
                "payerReference": "CUST-123"
            }
            """;
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(invalidRequest)
            .exchange()
            .expectStatus().isBadRequest()
            .expectBody()
            .jsonPath("$.title").exists()
            .jsonPath("$.status").isEqualTo(400);
    }
    
    @Test
    @DisplayName("Should handle concurrent payment order creation")
    void shouldHandleConcurrentCreation() throws Exception {
        // Given
        int numberOfThreads = 5;
        ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);
        CountDownLatch latch = new CountDownLatch(numberOfThreads);
        
        // When
        for (int i = 0; i < numberOfThreads; i++) {
            final int index = i;
            executorService.submit(() -> {
                try {
                    InitiatePaymentOrderRequest request = createRequest("PAYER-" + index);
                    webTestClient.post()
                        .uri("/payment-initiation/payment-orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(request)
                        .exchange()
                        .expectStatus().isCreated();
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(10, TimeUnit.SECONDS);
        executorService.shutdown();
        
        // Then
        assertThat(repository.count()).isEqualTo(numberOfThreads);
    }
    
    // Helper methods
    private PaymentOrderEntity createSampleEntity() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-TEST-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Test payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
    
    private InitiatePaymentOrderRequest createRequest(String payerRef) {
        return InitiatePaymentOrderRequest.builder()
            .payerReference(payerRef)
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1000.0)
                .currency("USD")
                .build())
            .paymentPurpose("Concurrent test")
            .build();
    }
}
```

#### Alternative: REST Assured for Integration Tests
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class PaymentInitiationRestAssuredTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        RestAssured.basePath = "/payment-initiation";
        repository.deleteAll();
    }
    
    @Test
    void shouldInitiatePaymentOrder() {
        given()
            .contentType(ContentType.JSON)
            .body(createValidRequest())
        .when()
            .post("/payment-orders")
        .then()
            .statusCode(201)
            .body("paymentOrderReference", notNullValue())
            .body("paymentOrderStatus", equalTo("INITIATED"))
            .body("amount.value", equalTo(1500.50f))
            .body("amount.currency", equalTo("USD"));
    }
    
    @Test
    void shouldRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity saved = repository.save(createSampleEntity());
        
        // When & Then
        given()
            .pathParam("id", saved.getPaymentOrderReference())
        .when()
            .get("/payment-orders/{id}")
        .then()
            .statusCode(200)
            .body("paymentOrderReference", equalTo(saved.getPaymentOrderReference()))
            .body("paymentOrderStatus", equalTo("INITIATED"));
    }
}
```

#### Test Data Builders (Object Mother Pattern)
```java
public class PaymentOrderMother {
    
    public static PaymentOrder valid() {
        return PaymentOrder.builder()
            .id(PaymentOrderId.generate())
            .payerReference(PayerReference.of("CUST-12345"))
            .payeeReference(PayeeReference.of("CUST-67890"))
            .amount(PaymentAmount.of(1500.50, Currency.USD))
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatus.INITIATED)
            .createdAt(LocalDateTime.now())
            .build();
    }
    
    public static PaymentOrder withInvalidAmount() {
        return valid().toBuilder()
            .amount(PaymentAmount.of(-100.00, Currency.USD))
            .build();
    }
    
    public static PaymentOrder withStatus(PaymentStatus status) {
        return valid().toBuilder()
            .status(status)
            .build();
    }
    
    public static PaymentOrder pending() {
        return withStatus(PaymentStatus.PENDING);
    }
    
    public static PaymentOrder completed() {
        return withStatus(PaymentStatus.COMPLETED);
    }
}

public class PaymentOrderEntityMother {
    
    public static PaymentOrderEntity valid() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
}
```

#### Repository Tests
```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class PaymentOrderJpaRepositoryTest {
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    @DisplayName("Should save and retrieve payment order")
    void shouldSaveAndRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity entity = PaymentOrderEntityMother.valid();
        
        // When
        PaymentOrderEntity saved = repository.save(entity);
        entityManager.flush();
        entityManager.clear();
        
        // Then
        Optional<PaymentOrderEntity> found = repository.findByPaymentOrderReference(
            saved.getPaymentOrderReference()
        );
        
        assertThat(found).isPresent();
        assertThat(found.get().getPayerReference()).isEqualTo("CUST-12345");
        assertThat(found.get().getAmount()).isEqualByComparingTo("1500.50");
    }
    
    @Test
    @DisplayName("Should find payment orders by status")
    void shouldFindByStatus() {
        // Given
        repository.save(PaymentOrderEntityMother.valid());
        repository.save(PaymentOrderEntityMother.valid().toBuilder()
            .paymentOrderReference("PO-2024-002")
            .status(PaymentStatusEntity.COMPLETED)
            .build());
        entityManager.flush();
        
        // When
        List<PaymentOrderEntity> initiated = repository.findByStatus(PaymentStatusEntity.INITIATED);
        List<PaymentOrderEntity> completed = repository.findByStatus(PaymentStatusEntity.COMPLETED);
        
        // Then
        assertThat(initiated).hasSize(1);
        assertThat(completed).hasSize(1);
    }
}
```

### 8. Quality Gates (Mandatory - Gradle)

#### JaCoCo Configuration (Gradle)
```groovy
// build.gradle
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                '**/dto/**',
                '**/entity/**',
                '**/config/**',
                '**/*Application.class',
                '**/*MapperImpl.class'  // Exclude MapStruct generated classes
            ])
        }))
    }
}

jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
        
        rule {
            element = 'CLASS'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.70
            }
            excludes = [
                '*.dto.*',
                '*.entity.*',
                '*.config.*',
                '*Application',
                '*MapperImpl'
            ]
        }
    }
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

check.dependsOn jacocoTestCoverageVerification
```

#### Checkstyle Configuration (Gradle)
```groovy
// build.gradle
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
    configProperties = [
        'checkstyle.suppressions.file': "${project.rootDir}/config/checkstyle/suppressions.xml"
    ]
}

checkstyleMain {
    source = 'src/main/java'
    exclude '**/dto/**', '**/entity/**'  // Exclude generated code
}

checkstyleTest {
    source = 'src/test/java'
}

tasks.withType(Checkstyle) {
    reports {
        xml.required = true
        html.required = true
    }
}
```

#### config/checkstyle/checkstyle.xml
```xml
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
    "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
    "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <property name="charset" value="UTF-8"/>
    <property name="severity" value="error"/>
    <property name="fileExtensions" value="java"/>
    
    <module name="SuppressionFilter">
        <property name="file" value="${checkstyle.suppressions.file}"/>
    </module>
    
    <module name="TreeWalker">
        <!-- Naming Conventions -->
        <module name="TypeName">
            <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="MethodName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="ConstantName">
            <property name="format" value="^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"/>
        </module>
        
        <module name="LocalVariableName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <!-- Code Style -->
        <module name="LeftCurly"/>
        <module name="RightCurly"/>
        <module name="NeedBraces"/>
        
        <module name="WhitespaceAround"/>
        <module name="NoWhitespaceBefore"/>
        
        <!-- Imports -->
        <module name="AvoidStarImport"/>
        <module name="UnusedImports"/>
        <module name="RedundantImport"/>
        
        <!-- Size Violations -->
        <module name="LineLength">
            <property name="max" value="120"/>
        </module>
        
        <module name="MethodLength">
            <property name="max" value="150"/>
        </module>
        
        <!-- Complexity -->
        <module name="CyclomaticComplexity">
            <property name="max" value="15"/>
        </module>
        
        <!-- Best Practices -->
        <module name="EmptyBlock"/>
        <module name="EqualsHashCode"/>
        <module name="SimplifyBooleanExpression"/>
        <module name="SimplifyBooleanReturn"/>
        
        <!-- Annotations -->
        <module name="MissingOverride"/>
    </module>
</module>
```

#### SpotBugs Configuration (Gradle)
```groovy
// build.gradle
spotbugs {
    effort = 'max'
    reportLevel = 'high'
    excludeFilter = file("${project.rootDir}/config/spotbugs/spotbugs-exclude.xml")
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/main/spotbugs.html")
        }
        xml {
            required = false
        }
    }
}

tasks.named('spotbugsTest') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/test/spotbugs.html")
        }
    }
}
```

#### config/spotbugs/spotbugs-exclude.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<FindBugsFilter>
    <!-- Exclude generated code -->
    <Match>
        <Package name="~.*\.dto.*"/>
    </Match>
    
    <Match>
        <Package name="~.*\.entity.*"/>
    </Match>
    
    <Match>
        <Class name="~.*MapperImpl"/>
    </Match>
    
    <!-- Exclude specific bugs for Lombok -->
    <Match>
        <Bug pattern="EI_EXPOSE_REP,EI_EXPOSE_REP2"/>
        <Or>
            <Class name="~.*\.domain\.model\..*"/>
        </Or>
    </Match>
</FindBugsFilter>
```

#### Gradle Verification Tasks
```groovy
// Create custom task to run all quality checks
tasks.register('qualityCheck') {
    dependsOn 'checkstyleMain', 'checkstyleTest', 'spotbugsMain', 'jacocoTestCoverageVerification'
    description = 'Run all quality checks: Checkstyle, SpotBugs, and JaCoCo'
    group = 'verification'
}

// Make 'check' depend on quality checks
check {
    dependsOn 'qualityCheck'
}

// Gradle wrapper
wrapper {
    gradleVersion = '8.5'
    distributionType = Wrapper.DistributionType.ALL
}
```

#### Run Quality Checks
```bash
# Run all quality checks
./gradlew check

# Run individual checks
./gradlew checkstyleMain
./gradlew spotbugsMain
./gradlew test jacocoTestReport
./gradlew jacocoTestCoverageVerification

# Build with quality checks
./gradlew clean build

# Generate reports
./gradlew jacocoTestReport
# Report: build/reports/jacoco/test/html/index.html

./gradlew checkstyleMain
# Report: build/reports/checkstyle/main.html

./gradlew spotbugsMain
# Report: build/reports/spotbugs/main/spotbugs.html
```

### 8. Domain Modeling Best Practices

#### Value Objects
```java
@Value
@Builder
public class PaymentAmount {
    BigDecimal value;
    Currency currency;
    
    public static PaymentAmount of(double value, Currency currency) {
        if (value <= 0) {
            throw new InvalidPaymentException("Amount must be positive");
        }
        return new PaymentAmount(BigDecimal.valueOf(value), currency);
    }
}
```

#### Aggregates
```java
@Builder(toBuilder = true)
@Value
public class PaymentOrder {
    PaymentOrderId id;
    PayerReference payerReference;
    PayeeReference payeeReference;
    PaymentAmount amount;
    PaymentStatus status;
    LocalDateTime createdAt;
    
    // Business invariants
    public PaymentOrder validate() {
        if (status == PaymentStatus.CANCELLED && amount.getValue().compareTo(BigDecimal.ZERO) > 0) {
            throw new InvalidPaymentException("Cancelled orders cannot have positive amount");
        }
        return this;
    }
    
    public PaymentOrder markAsProcessed() {
        if (status != PaymentStatus.INITIATED) {
            throw new InvalidPaymentException("Only initiated orders can be processed");
        }
        return this.toBuilder().status(PaymentStatus.PROCESSED).build();
    }
}
```

#### Domain Events (if needed)
```java
@Value
public class PaymentOrderInitiatedEvent {
    String paymentOrderReference;
    PaymentAmount amount;
    LocalDateTime occurredOn;
}
```

### 9. Error Handling (RFC 7807)

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(PaymentOrderNotFoundException.class)
    public ResponseEntity<ProblemDetail> handleNotFound(PaymentOrderNotFoundException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, 
            ex.getMessage()
        );
        problem.setTitle("Payment Order Not Found");
        problem.setProperty("paymentOrderReference", ex.getPaymentOrderReference());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem);
    }
    
    @ExceptionHandler(InvalidPaymentException.class)
    public ResponseEntity<ProblemDetail> handleInvalidPayment(InvalidPaymentException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST,
            ex.getMessage()
        );
        problem.setTitle("Invalid Payment Order");
        problem.setProperty("validationErrors", ex.getErrors());
        return ResponseEntity.badRequest().body(problem);
    }
}
```

### 10. Docker Configuration with H2

#### Multi-stage Dockerfile (Gradle)
```dockerfile
# Build stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

# Copy Gradle files
COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .

# Copy source code
COPY src src
COPY config config

# Build application (skip tests for faster builds, tests run in CI/CD)
RUN ./gradlew clean build -x test --no-daemon

# Runtime stage
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Create non-root user for security
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# Copy JAR from builder
COPY --from=builder /app/build/libs/*.jar app.jar

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# JVM options
ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC -XX:+UseContainerSupport"

# Run application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

#### docker-compose.yml (H2 in-memory)
```yaml
version: '3.8'

services:
  payment-initiation-service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: payment-initiation-service
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - JAVA_OPTS=-Xms256m -Xmx512m
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - payment-network
    restart: unless-stopped

networks:
  payment-network:
    driver: bridge

# Optional: Add volumes for H2 file-based persistence
# volumes:
#   h2-data:
#     driver: local
```

#### application-docker.yml (For containerized H2)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 with file persistence in Docker (optional)
  datasource:
    url: jdbc:h2:file:/app/data/paymentdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: true  # Allow access from outside container
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: false

server:
  port: 8080

logging:
  level:
    com.hiberus.banking: INFO
    org.springframework.web: WARN
```

#### Docker Commands
```bash
# Build image
docker build -t payment-initiation-service:latest .

# Run with docker-compose
docker-compose up -d

# View logs
docker-compose logs -f payment-initiation-service

# Stop services
docker-compose down

# Rebuild and restart
docker-compose up -d --build

# Access H2 Console (if enabled)
# URL: http://localhost:8080/h2-console
# JDBC URL: jdbc:h2:mem:paymentdb
# Username: sa
# Password: (empty)

# Health check
curl http://localhost:8080/actuator/health

# Test API
curl -X POST http://localhost:8080/payment-initiation/payment-orders \
  -H "Content-Type: application/json" \
  -d '{
    "payerReference": "CUST-123",
    "payeeReference": "CUST-456",
    "amount": {
      "value": 1500.50,
      "currency": "USD"
    },
    "paymentPurpose": "Invoice payment"
  }'
```

#### .dockerignore
```
.git
.gitignore
.gradle
build/
!build/libs/*.jar
*.md
.idea
*.iml
.vscode
target/
*.log
```

#### Alternative: Dockerfile with tests included
```dockerfile
# Build and test stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .
COPY config config
COPY src src

# Run tests and build
RUN ./gradlew clean build --no-daemon

# Runtime stage (same as before)
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

COPY --from=builder /app/build/libs/*.jar app.jar

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 11. AI-Assisted Development Documentation

#### Structure for ai/ folder
```
ai/
├── prompts.md                 # All prompts used
├── decisions.md              # Architectural decisions and rationale
└── generations/              # Generated code samples
    ├── openapi-draft.yaml
    ├── domain-skeleton.java
    └── test-generation.java
```

#### Example prompts.md format
```markdown
## Prompt 1: WSDL Analysis
**Prompt**: "Analyze this WSDL for PaymentOrderService and map to BIAN Payment Initiation Service Domain. Identify: operations, data structures, business rules, and status flows."

**Response Summary**: 
- SOAP operations: createPaymentOrder, getPaymentOrder, updateOrderStatus
- Mapped to BIAN: Initiate, Retrieve, Execute
- Key fields: orderId → paymentOrderReference, amount, payer/payee, status

**Manual Corrections**:
- Changed generic "orderId" to BIAN-compliant "paymentOrderReference"
- Added currency field (was missing in WSDL)
- Refined status enum to align with BIAN lifecycle

## Prompt 2: OpenAPI Generation
[...]
```

### 12. Code Style & Conventions

#### Naming Conventions
- **Classes**: PascalCase (e.g., `PaymentOrder`, `InitiatePaymentOrderService`)
- **Methods**: camelCase, verb-based (e.g., `initiatePayment`, `retrieveOrderStatus`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_PAYMENT_AMOUNT`)
- **Packages**: lowercase, domain-driven (e.g., `domain.model`, `adapter.in.rest`)

#### BIAN-Specific Conventions
- Prefix interfaces with use case: `InitiatePaymentOrderUseCase`
- Use "Reference" suffix for IDs: `paymentOrderReference`, `payerReference`
- Status naming: Use BIAN lifecycle terms (INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED)

#### Lombok Usage
```java
@Value                    // For immutable value objects
@Builder(toBuilder=true) // For entities with many fields
@RequiredArgsConstructor // For dependency injection
@Slf4j                   // For logging
```

### 13. Observability & Production Readiness

#### Actuator Configuration
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    tags:
      application: payment-initiation-service
      service-domain: payment-initiation
```

#### Custom Metrics
```java
@Component
@RequiredArgsConstructor
public class PaymentMetrics {
    
    private final MeterRegistry registry;
    
    public void recordPaymentInitiated(PaymentAmount amount) {
        registry.counter("payment.initiated", 
            "currency", amount.getCurrency().toString())
            .increment();
        
        registry.summary("payment.amount")
            .record(amount.getValue().doubleValue());
    }
}
```

#### Logging Best Practices
```java
// Structured logging
log.info("Payment order initiated", 
    kv("paymentOrderReference", order.getId()),
    kv("amount", order.getAmount().getValue()),
    kv("status", order.getStatus()));

// Never log sensitive data (PII)
// Use correlation IDs for tracing
```

### 14. Security Considerations

- Validate all inputs at adapter layer
- Use Bean Validation annotations in DTOs
- Implement idempotency using `Idempotency-Key` header
- Add rate limiting for endpoints
- Sanitize error messages (don't expose internal details)

### 15. Documentation Requirements

#### README.md Must Include
1. **Project Overview**: BIAN SD, migration context
2. **Architecture Decision Records (ADRs)**: Why hexagonal, why reactive
3. **Setup Instructions**: Prerequisites, local run, Docker
4. **API Documentation**: Link to Swagger UI, example requests
5. **Testing**: How to run tests, coverage reports
6. **AI Usage**: Summary of prompts and generated code
7. **Quality Gates**: Checkstyle, SpotBugs, JaCoCo results

## Validation Checklist

Before committing code, ensure:
- [ ] Follows hexagonal architecture (no Spring in domain)
- [ ] OpenAPI contract-first approach used (interfaces generated)
- [ ] All BIAN naming conventions followed (payment-initiation, PaymentOrder BQ)
- [ ] MapStruct mappers configured correctly (3 layers: REST, Persistence, Application)
- [ ] Unit tests written for domain and application layers (80%+ coverage)
- [ ] Integration tests with WebTestClient for all endpoints
- [ ] Repository tests for JPA layer
- [ ] `./gradlew check` passes (Checkstyle, SpotBugs, JaCoCo)
- [ ] H2 database configured correctly (in-memory or file-based)
- [ ] Dockerfile builds successfully (`docker build -t payment-service .`)
- [ ] docker-compose up works (`docker-compose up -d`)
- [ ] All endpoints return correct HTTP status codes (201, 200, 404, 400, 500)
- [ ] RFC 7807 error handling implemented (application/problem+json)
- [ ] AI usage documented in ai/ folder (prompts.md, decisions.md, generations/)
- [ ] README updated with setup instructions and API documentation
- [ ] Actuator endpoints exposed for health checks
- [ ] Logging configured appropriately (no sensitive data)
- [ ] Value objects are immutable (Lombok @Value)
- [ ] No framework dependencies in domain layer
- [ ] All exceptions properly handled in GlobalExceptionHandler

## Additional Gradle Commands

```bash
# Clean build
./gradlew clean build

# Run with quality checks
./gradlew clean build check

# Run only tests
./gradlew test

# Generate coverage report
./gradlew test jacocoTestReport
# Open: build/reports/jacoco/test/html/index.html

# Run checkstyle only
./gradlew checkstyleMain checkstyleTest

# Run spotbugs only
./gradlew spotbugsMain spotbugsTest

# Build without tests (faster for development)
./gradlew clean build -x test

# Run application locally
./gradlew bootRun

# Generate OpenAPI code
./gradlew openApiGenerate

# View project dependencies
./gradlew dependencies

# View available tasks
./gradlew tasks
```

## Remember
- **BIAN alignment is non-negotiable**: Always validate against BIAN standards
- **Domain purity**: Keep domain layer framework-agnostic
- **Test-first mindset**: Write tests before implementation
- **Document AI usage**: Every AI-generated code must be reviewed and documented
- **Quality over speed**: Meet all quality gates before considering "done"

---

When in doubt, ask yourself: "Does this align with BIAN Payment Initiation Service Domain standards?" and "Is this following hexagonal architecture principles?"
          minLength: 15
          maxLength: 34
          example: "EC12DEBTOR"
    
    # Instructed Amount (replaces SOAP separate amount + currency)
    InstructedAmount:
      type: object
      required:
        - amount
        - currency
      properties:
        amount:
          type: number
          format: double
          minimum: 0.01
          description: Payment amount
          example: 150.75
        currency:
          type: string
          description: ISO 4217 currency code
          pattern: '^[A-Z]{3}
```yaml
# openapi.yaml structure
openapi: 3.0.3
info:
  title: BIAN Payment Initiation API
  version: 1.0.0
  description: Payment Order management aligned with BIAN Service Domain

servers:
  - url: http://localhost:8080
    description: Local development server

paths:
  /payment-initiation/payment-orders:
    post:
      operationId: initiatePaymentOrder
      tags: [Payment Initiation]
      summary: Initiate a new payment order
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InitiatePaymentOrderRequest'
      responses:
        '201':
          description: Payment order successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InitiatePaymentOrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '500':
          $ref: '#/components/responses/InternalServerError'
  
  /payment-initiation/payment-orders/{id}:
    get:
      operationId: retrievePaymentOrder
      tags: [Payment Initiation]
      summary: Retrieve payment order details
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RetrievePaymentOrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /payment-initiation/payment-orders/{id}/status:
    get:
      operationId: retrievePaymentOrderStatus
      tags: [Payment Initiation]
      summary: Retrieve payment order status
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order status retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentOrderStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    InitiatePaymentOrderRequest:
      type: object
      required: 
        - payerReference
        - payeeReference
        - amount
      properties:
        payerReference:
          type: string
          description: Reference to the payer (customer ID)
          example: "CUST-12345"
        payeeReference:
          type: string
          description: Reference to the payee (beneficiary ID)
          example: "CUST-67890"
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
          description: Purpose of the payment
          example: "Invoice payment"
        paymentDate:
          type: string
          format: date
          description: Requested payment date
          example: "2024-11-20"
    
    InitiatePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
          description: BIAN-compliant payment order reference
          example: "PO-2024-001234"
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        createdAt:
          type: string
          format: date-time
    
    RetrievePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
        paymentDate:
          type: string
          format: date
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    PaymentOrderStatusResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        statusReason:
          type: string
          description: Reason for current status
        lastUpdated:
          type: string
          format: date-time
    
    PaymentAmount:
      type: object
      required:
        - value
        - currency
      properties:
        value:
          type: number
          format: double
          minimum: 0.01
          example: 1500.50
        currency:
          type: string
          enum: [USD, EUR, GBP, JPY]
          example: "USD"
    
    ProblemDetail:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request - validation errors
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    NotFound:
      description: Resource not found
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    InternalServerError:
      description: Internal server error
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
```

#### Gradle Configuration (build.gradle)
```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'org.openapi.generator' version '7.0.1'
    id 'checkstyle'
    id 'com.github.spotbugs' version '6.0.0'
    id 'jacoco'
}

group = 'com.hiberus.banking'
version = '1.0.0'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

ext {
    mapstructVersion = '1.5.5.Final'
    lombokVersion = '1.18.30'
    openApiVersion = '2.2.0'
}

dependencies {
    // Spring Boot Starters
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    
    // H2 Database
    runtimeOnly 'com.h2database:h2'
    
    // OpenAPI
    implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${openApiVersion}"
    
    // MapStruct
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
    
    // Lombok
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    
    // Lombok + MapStruct compatibility
    annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"
    
    // Testing
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-webflux'  // For WebTestClient
    testImplementation 'io.rest-assured:rest-assured:5.4.0'
    testImplementation 'org.assertj:assertj-core'
    
    // Test Lombok
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
}

// OpenAPI Generator Task
openApiGenerate {
    generatorName = 'spring'
    inputSpec = "$projectDir/src/main/resources/openapi.yaml"
    outputDir = "$buildDir/generated"
    apiPackage = 'com.hiberus.banking.payment.adapter.in.rest.api'
    modelPackage = 'com.hiberus.banking.payment.adapter.in.rest.dto'
    invokerPackage = 'com.hiberus.banking.payment.adapter.in.rest.invoker'
    configOptions = [
        interfaceOnly: 'true',
        useSpringBoot3: 'true',
        useTags: 'true',
        dateLibrary: 'java8',
        serializationLibrary: 'jackson',
        hideGenerationTimestamp: 'true'
    ]
}

// Add generated sources to source sets
sourceSets {
    main {
        java {
            srcDirs += "$buildDir/generated/src/main/java"
        }
    }
}

// Compile depends on generation
compileJava.dependsOn tasks.openApiGenerate

// JaCoCo Configuration
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
    }
}

// Checkstyle Configuration
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
}

// SpotBugs Configuration
spotbugs {
    effort = 'max'
    reportLevel = 'high'
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
        }
        xml {
            required = false
        }
    }
}

// Test Configuration
test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

// Build task order
check.dependsOn jacocoTestCoverageVerification
```

#### Controller Implementation (Spring MVC)
```java
@RestController
@RequiredArgsConstructor
@Slf4j
public class PaymentInitiationController implements PaymentInitiationApi {
    
    private final InitiatePaymentOrderUseCase initiateUseCase;
    private final RetrievePaymentOrderUseCase retrieveUseCase;
    private final RetrievePaymentOrderStatusUseCase retrieveStatusUseCase;
    private final PaymentOrderRestMapper mapper;
    
    @Override
    public ResponseEntity<InitiatePaymentOrderResponse> initiatePaymentOrder(
            InitiatePaymentOrderRequest request) {
        
        log.info("Initiating payment order for payer: {}", request.getPayerReference());
        
        PaymentOrder domainOrder = mapper.toDomain(request);
        PaymentOrder initiatedOrder = initiateUseCase.initiate(domainOrder);
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(initiatedOrder);
        
        log.info("Payment order initiated successfully: {}", response.getPaymentOrderReference());
        
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(response);
    }
    
    @Override
    public ResponseEntity<RetrievePaymentOrderResponse> retrievePaymentOrder(String id) {
        
        log.info("Retrieving payment order: {}", id);
        
        PaymentOrder paymentOrder = retrieveUseCase.retrieve(id);
        RetrievePaymentOrderResponse response = mapper.toRetrieveResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
    
    @Override
    public ResponseEntity<PaymentOrderStatusResponse> retrievePaymentOrderStatus(String id) {
        
        log.info("Retrieving payment order status: {}", id);
        
        PaymentOrder paymentOrder = retrieveStatusUseCase.retrieveStatus(id);
        PaymentOrderStatusResponse response = mapper.toStatusResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
}
```

### 5. Spring MVC with H2 Database

#### Application Configuration (application.yml)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 Database Configuration
  datasource:
    url: jdbc:h2:mem:paymentdb
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: false
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
  
  # Jackson Configuration
  jackson:
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

# Server Configuration
server:
  port: 8080
  servlet:
    context-path: /
  error:
    include-message: always
    include-binding-errors: always
    include-exception: false
    include-stacktrace: never

# Management / Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    tags:
      application: ${spring.application.name}
      service-domain: payment-initiation

# Logging
logging:
  level:
    com.hiberus.banking: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

#### JPA Entity Example
```java
@Entity
@Table(name = "payment_orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PaymentOrderEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(name = "payment_order_reference", nullable = false, unique = true, length = 50)
    private String paymentOrderReference;
    
    @Column(name = "payer_reference", nullable = false, length = 50)
    private String payerReference;
    
    @Column(name = "payee_reference", nullable = false, length = 50)
    private String payeeReference;
    
    @Column(name = "amount", nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "currency", nullable = false, length = 3)
    private String currency;
    
    @Column(name = "payment_purpose", length = 255)
    private String paymentPurpose;
    
    @Column(name = "payment_date")
    private LocalDate paymentDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PaymentStatusEntity status;
    
    @Column(name = "status_reason", length = 500)
    private String statusReason;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        if (status == null) {
            status = PaymentStatusEntity.INITIATED;
        }
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

@Getter
@RequiredArgsConstructor
enum PaymentStatusEntity {
    INITIATED("Payment order has been initiated"),
    PENDING("Payment order is pending processing"),
    PROCESSED("Payment order has been processed"),
    COMPLETED("Payment order completed successfully"),
    FAILED("Payment order failed"),
    CANCELLED("Payment order has been cancelled");
    
    private final String description;
}
```

#### Spring Data JPA Repository
```java
@Repository
public interface PaymentOrderJpaRepository extends JpaRepository<PaymentOrderEntity, UUID> {
    
    Optional<PaymentOrderEntity> findByPaymentOrderReference(String paymentOrderReference);
    
    List<PaymentOrderEntity> findByPayerReference(String payerReference);
    
    List<PaymentOrderEntity> findByStatus(PaymentStatusEntity status);
    
    @Query("SELECT p FROM PaymentOrderEntity p WHERE p.createdAt BETWEEN :startDate AND :endDate")
    List<PaymentOrderEntity> findByDateRange(
        @Param("startDate") LocalDateTime startDate, 
        @Param("endDate") LocalDateTime endDate
    );
    
    boolean existsByPaymentOrderReference(String paymentOrderReference);
}
```

#### Repository Adapter Implementation
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PaymentOrderRepositoryAdapter implements PaymentOrderRepository {
    
    private final PaymentOrderJpaRepository jpaRepository;
    private final PaymentOrderPersistenceMapper persistenceMapper;
    
    @Override
    public PaymentOrder save(PaymentOrder paymentOrder) {
        log.debug("Saving payment order: {}", paymentOrder.getPaymentOrderReference());
        
        PaymentOrderEntity entity = persistenceMapper.toEntity(paymentOrder);
        PaymentOrderEntity savedEntity = jpaRepository.save(entity);
        
        log.debug("Payment order saved with ID: {}", savedEntity.getId());
        return persistenceMapper.toDomain(savedEntity);
    }
    
    @Override
    public Optional<PaymentOrder> findByReference(String paymentOrderReference) {
        log.debug("Finding payment order by reference: {}", paymentOrderReference);
        
        return jpaRepository.findByPaymentOrderReference(paymentOrderReference)
            .map(persistenceMapper::toDomain);
    }
    
    @Override
    public boolean existsByReference(String paymentOrderReference) {
        return jpaRepository.existsByPaymentOrderReference(paymentOrderReference);
    }
    
    @Override
    public List<PaymentOrder> findAll() {
        return jpaRepository.findAll().stream()
            .map(persistenceMapper::toDomain)
            .collect(Collectors.toList());
    }
}
```

#### H2 Console Configuration
```java
@Configuration
public class H2ConsoleConfig {
    
    @Bean
    public ServletRegistrationBean<WebServlet> h2Console() {
        ServletRegistrationBean<WebServlet> registration = 
            new ServletRegistrationBean<>(new WebServlet());
        registration.addUrlMappings("/h2-console/*");
        return registration;
    }
}
```

#### Data Initialization (Optional - for testing)
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class DataInitializer {
    
    private final PaymentOrderJpaRepository repository;
    
    @EventListener(ApplicationReadyEvent.class)
    public void loadSampleData() {
        if (repository.count() == 0) {
            log.info("Loading sample payment orders...");
            
            PaymentOrderEntity order1 = PaymentOrderEntity.builder()
                .paymentOrderReference("PO-2024-001")
                .payerReference("CUST-12345")
                .payeeReference("CUST-67890")
                .amount(new BigDecimal("1500.50"))
                .currency("USD")
                .paymentPurpose("Invoice payment")
                .paymentDate(LocalDate.now())
                .status(PaymentStatusEntity.INITIATED)
                .build();
            
            repository.save(order1);
            log.info("Sample data loaded successfully");
        }
    }
}
```

### 6. MapStruct Mappers (Three Layers)

MapStruct is used for clean transformation between layers. There are THREE types of mappers:

#### 1. REST Mapper (Adapter Layer: DTO ↔ Domain)
```java
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR)
public interface PaymentOrderRestMapper {
    
    // Request DTO → Domain
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "paymentOrderReference", ignore = true)
    @Mapping(target = "status", constant = "INITIATED")
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    @Mapping(target = "updatedAt", ignore = true)
    PaymentOrder toDomain(InitiatePaymentOrderRequest request);
    
    // Domain → Response DTO (Initiate)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    InitiatePaymentOrderResponse toInitiateResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Retrieve)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    RetrievePaymentOrderResponse toRetrieveResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Status)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    @Mapping(source = "updatedAt", target = "lastUpdated")
    PaymentOrderStatusResponse toStatusResponse(PaymentOrder paymentOrder);
    
    // Value Object mappings
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    PaymentAmount toPaymentAmount(com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount dtoAmount);
    
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount toPaymentAmountDto(PaymentAmount domainAmount);
}
```

#### 2. Persistence Mapper (Adapter Layer: Domain ↔ Entity)
```java
@Mapper(componentModel = "spring", 
        unmappedTargetPolicy = ReportingPolicy.ERROR,
        uses = {PaymentStatusMapper.class})
public interface PaymentOrderPersistenceMapper {
    
    // Domain → Entity
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "payerReference.value", target = "payerReference")
    @Mapping(source = "payeeReference.value", target = "payeeReference")
    @Mapping(source = "amount.value", target = "amount")
    @Mapping(source = "amount.currency", target = "currency")
    @Mapping(source = "status", target = "status")
    @Mapping(target = "id", ignore = true)  // Let JPA generate
    PaymentOrderEntity toEntity(PaymentOrder domain);
    
    // Entity → Domain
    @Mapping(source = "paymentOrderReference", target = "id.value")
    @Mapping(source = "payerReference", target = "payerReference.value")
    @Mapping(source = "payeeReference", target = "payeeReference.value")
    @Mapping(source = "amount", target = "amount.value")
    @Mapping(source = "currency", target = "amount.currency")
    PaymentOrder toDomain(PaymentOrderEntity entity);
    
    // Custom mapping for status
    default PaymentStatus mapStatus(PaymentStatusEntity entityStatus) {
        return PaymentStatus.valueOf(entityStatus.name());
    }
    
    default PaymentStatusEntity mapStatus(PaymentStatus domainStatus) {
        return PaymentStatusEntity.valueOf(domainStatus.name());
    }
}
```

#### 3. Application Mapper (Optional: Complex transformations)
```java
@Mapper(componentModel = "spring")
public interface PaymentOrderApplicationMapper {
    
    // For complex business logic transformations
    @Mapping(target = "enrichedData", expression = "java(enrichData(source))")
    PaymentOrder enrichForProcessing(PaymentOrder source);
    
    default String enrichData(PaymentOrder order) {
        // Complex business logic here
        return "ENRICHED-" + order.getPaymentOrderReference();
    }
}
```

#### MapStruct Configuration Best Practices
```java
@MapperConfig(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.ERROR,  // Fail on unmapped fields
    unmappedSourcePolicy = ReportingPolicy.WARN,    // Warn on unmapped sources
    mappingInheritanceStrategy = MappingInheritanceStrategy.AUTO_INHERIT_FROM_CONFIG
)
public interface CentralMapperConfig {
}

// Then use it in mappers
@Mapper(config = CentralMapperConfig.class)
public interface PaymentOrderRestMapper {
    // ... mappings
}
```

#### Testing MapStruct Mappers
```java
@SpringBootTest
class PaymentOrderRestMapperTest {
    
    @Autowired
    private PaymentOrderRestMapper mapper;
    
    @Test
    @DisplayName("Should map InitiatePaymentOrderRequest to PaymentOrder domain")
    void shouldMapRequestToDomain() {
        // Given
        InitiatePaymentOrderRequest request = new InitiatePaymentOrderRequest()
            .payerReference("CUST-123")
            .payeeReference("CUST-456")
            .amount(new com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount()
                .value(1000.0)
                .currency("USD"))
            .paymentPurpose("Test payment");
        
        // When
        PaymentOrder domain = mapper.toDomain(request);
        
        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getPayerReference().getValue()).isEqualTo("CUST-123");
        assertThat(domain.getPayeeReference().getValue()).isEqualTo("CUST-456");
        assertThat(domain.getAmount().getValue()).isEqualByComparingTo("1000.0");
        assertThat(domain.getAmount().getCurrency()).isEqualTo(Currency.USD);
        assertThat(domain.getStatus()).isEqualTo(PaymentStatus.INITIATED);
    }
    
    @Test
    @DisplayName("Should map PaymentOrder domain to InitiatePaymentOrderResponse")
    void shouldMapDomainToResponse() {
        // Given
        PaymentOrder domain = PaymentOrderMother.valid();
        
        // When
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(domain);
        
        // Then
        assertThat(response).isNotNull();
        assertThat(response.getPaymentOrderReference()).isEqualTo(domain.getId().getValue());
        assertThat(response.getPaymentOrderStatus()).isEqualTo(domain.getStatus().name());
    }
}
```

### 7. Testing Strategy with Spring MVC and WebTestClient

#### Unit Tests (Domain & Application Layer)
```java
@ExtendWith(MockitoExtension.class)
class InitiatePaymentOrderServiceTest {
    
    @Mock
    private PaymentOrderRepository repository;
    
    @Mock
    private PaymentValidationPort validationPort;
    
    @InjectMocks
    private InitiatePaymentOrderService service;
    
    @Test
    @DisplayName("Should initiate payment order when valid")
    void shouldInitiatePaymentOrderWhenValid() {
        // Given
        PaymentOrder order = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenReturn(order);
        
        // When
        PaymentOrder result = service.initiate(order);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getStatus()).isEqualTo(PaymentStatus.INITIATED);
        assertThat(result.getPaymentOrderReference()).isNotNull();
        
        verify(validationPort).validate(order);
        verify(repository).save(any(PaymentOrder.class));
    }
    
    @Test
    @DisplayName("Should throw InvalidPaymentException when validation fails")
    void shouldThrowExceptionWhenValidationFails() {
        // Given
        PaymentOrder order = PaymentOrderMother.withInvalidAmount();
        when(validationPort.validate(any())).thenReturn(false);
        
        // When & Then
        assertThatThrownBy(() -> service.initiate(order))
            .isInstanceOf(InvalidPaymentException.class)
            .hasMessageContaining("validation failed");
        
        verify(validationPort).validate(order);
        verify(repository, never()).save(any());
    }
    
    @Test
    @DisplayName("Should generate unique payment order reference")
    void shouldGenerateUniqueReference() {
        // Given
        PaymentOrder order1 = PaymentOrderMother.valid();
        PaymentOrder order2 = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenAnswer(inv -> inv.getArgument(0));
        
        // When
        PaymentOrder result1 = service.initiate(order1);
        PaymentOrder result2 = service.initiate(order2);
        
        // Then
        assertThat(result1.getPaymentOrderReference())
            .isNotEqualTo(result2.getPaymentOrderReference());
    }
}
```

#### Integration Tests with WebTestClient (Recommended for Spring MVC)
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class PaymentInitiationIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        repository.deleteAll();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 201 Created")
    void shouldInitiatePaymentOrderSuccessfully() {
        // Given
        InitiatePaymentOrderRequest request = InitiatePaymentOrderRequest.builder()
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1500.50)
                .currency("USD")
                .build())
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .build();
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .exchange()
            .expectStatus().isCreated()
            .expectHeader().exists("Location")
            .expectBody(InitiatePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getPaymentOrderReference()).startsWith("PO-");
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getPayeeReference()).isEqualTo("CUST-67890");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
                assertThat(response.getCreatedAt()).isNotNull();
            });
        
        // Verify database
        assertThat(repository.count()).isEqualTo(1);
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 200 OK")
    void shouldRetrievePaymentOrderSuccessfully() {
        // Given - Create a payment order first
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(RetrievePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id}/status - Should return 200 OK")
    void shouldRetrievePaymentOrderStatusSuccessfully() {
        // Given
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}/status", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(PaymentOrderStatusResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getLastUpdated()).isNotNull();
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 404 Not Found")
    void shouldReturn404WhenPaymentOrderNotFound() {
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", "NON-EXISTENT")
            .exchange()
            .expectStatus().isNotFound()
            .expectBody()
            .jsonPath("$.title").isEqualTo("Payment Order Not Found")
            .jsonPath("$.status").isEqualTo(404)
            .jsonPath("$.detail").exists();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 400 Bad Request for invalid data")
    void shouldReturn400ForInvalidRequest() {
        // Given - Invalid request (missing required fields)
        String invalidRequest = """
            {
                "payerReference": "CUST-123"
            }
            """;
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(invalidRequest)
            .exchange()
            .expectStatus().isBadRequest()
            .expectBody()
            .jsonPath("$.title").exists()
            .jsonPath("$.status").isEqualTo(400);
    }
    
    @Test
    @DisplayName("Should handle concurrent payment order creation")
    void shouldHandleConcurrentCreation() throws Exception {
        // Given
        int numberOfThreads = 5;
        ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);
        CountDownLatch latch = new CountDownLatch(numberOfThreads);
        
        // When
        for (int i = 0; i < numberOfThreads; i++) {
            final int index = i;
            executorService.submit(() -> {
                try {
                    InitiatePaymentOrderRequest request = createRequest("PAYER-" + index);
                    webTestClient.post()
                        .uri("/payment-initiation/payment-orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(request)
                        .exchange()
                        .expectStatus().isCreated();
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(10, TimeUnit.SECONDS);
        executorService.shutdown();
        
        // Then
        assertThat(repository.count()).isEqualTo(numberOfThreads);
    }
    
    // Helper methods
    private PaymentOrderEntity createSampleEntity() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-TEST-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Test payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
    
    private InitiatePaymentOrderRequest createRequest(String payerRef) {
        return InitiatePaymentOrderRequest.builder()
            .payerReference(payerRef)
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1000.0)
                .currency("USD")
                .build())
            .paymentPurpose("Concurrent test")
            .build();
    }
}
```

#### Alternative: REST Assured for Integration Tests
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class PaymentInitiationRestAssuredTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        RestAssured.basePath = "/payment-initiation";
        repository.deleteAll();
    }
    
    @Test
    void shouldInitiatePaymentOrder() {
        given()
            .contentType(ContentType.JSON)
            .body(createValidRequest())
        .when()
            .post("/payment-orders")
        .then()
            .statusCode(201)
            .body("paymentOrderReference", notNullValue())
            .body("paymentOrderStatus", equalTo("INITIATED"))
            .body("amount.value", equalTo(1500.50f))
            .body("amount.currency", equalTo("USD"));
    }
    
    @Test
    void shouldRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity saved = repository.save(createSampleEntity());
        
        // When & Then
        given()
            .pathParam("id", saved.getPaymentOrderReference())
        .when()
            .get("/payment-orders/{id}")
        .then()
            .statusCode(200)
            .body("paymentOrderReference", equalTo(saved.getPaymentOrderReference()))
            .body("paymentOrderStatus", equalTo("INITIATED"));
    }
}
```

#### Test Data Builders (Object Mother Pattern)
```java
public class PaymentOrderMother {
    
    public static PaymentOrder valid() {
        return PaymentOrder.builder()
            .id(PaymentOrderId.generate())
            .payerReference(PayerReference.of("CUST-12345"))
            .payeeReference(PayeeReference.of("CUST-67890"))
            .amount(PaymentAmount.of(1500.50, Currency.USD))
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatus.INITIATED)
            .createdAt(LocalDateTime.now())
            .build();
    }
    
    public static PaymentOrder withInvalidAmount() {
        return valid().toBuilder()
            .amount(PaymentAmount.of(-100.00, Currency.USD))
            .build();
    }
    
    public static PaymentOrder withStatus(PaymentStatus status) {
        return valid().toBuilder()
            .status(status)
            .build();
    }
    
    public static PaymentOrder pending() {
        return withStatus(PaymentStatus.PENDING);
    }
    
    public static PaymentOrder completed() {
        return withStatus(PaymentStatus.COMPLETED);
    }
}

public class PaymentOrderEntityMother {
    
    public static PaymentOrderEntity valid() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
}
```

#### Repository Tests
```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class PaymentOrderJpaRepositoryTest {
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    @DisplayName("Should save and retrieve payment order")
    void shouldSaveAndRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity entity = PaymentOrderEntityMother.valid();
        
        // When
        PaymentOrderEntity saved = repository.save(entity);
        entityManager.flush();
        entityManager.clear();
        
        // Then
        Optional<PaymentOrderEntity> found = repository.findByPaymentOrderReference(
            saved.getPaymentOrderReference()
        );
        
        assertThat(found).isPresent();
        assertThat(found.get().getPayerReference()).isEqualTo("CUST-12345");
        assertThat(found.get().getAmount()).isEqualByComparingTo("1500.50");
    }
    
    @Test
    @DisplayName("Should find payment orders by status")
    void shouldFindByStatus() {
        // Given
        repository.save(PaymentOrderEntityMother.valid());
        repository.save(PaymentOrderEntityMother.valid().toBuilder()
            .paymentOrderReference("PO-2024-002")
            .status(PaymentStatusEntity.COMPLETED)
            .build());
        entityManager.flush();
        
        // When
        List<PaymentOrderEntity> initiated = repository.findByStatus(PaymentStatusEntity.INITIATED);
        List<PaymentOrderEntity> completed = repository.findByStatus(PaymentStatusEntity.COMPLETED);
        
        // Then
        assertThat(initiated).hasSize(1);
        assertThat(completed).hasSize(1);
    }
}
```

### 8. Quality Gates (Mandatory - Gradle)

#### JaCoCo Configuration (Gradle)
```groovy
// build.gradle
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                '**/dto/**',
                '**/entity/**',
                '**/config/**',
                '**/*Application.class',
                '**/*MapperImpl.class'  // Exclude MapStruct generated classes
            ])
        }))
    }
}

jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
        
        rule {
            element = 'CLASS'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.70
            }
            excludes = [
                '*.dto.*',
                '*.entity.*',
                '*.config.*',
                '*Application',
                '*MapperImpl'
            ]
        }
    }
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

check.dependsOn jacocoTestCoverageVerification
```

#### Checkstyle Configuration (Gradle)
```groovy
// build.gradle
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
    configProperties = [
        'checkstyle.suppressions.file': "${project.rootDir}/config/checkstyle/suppressions.xml"
    ]
}

checkstyleMain {
    source = 'src/main/java'
    exclude '**/dto/**', '**/entity/**'  // Exclude generated code
}

checkstyleTest {
    source = 'src/test/java'
}

tasks.withType(Checkstyle) {
    reports {
        xml.required = true
        html.required = true
    }
}
```

#### config/checkstyle/checkstyle.xml
```xml
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
    "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
    "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <property name="charset" value="UTF-8"/>
    <property name="severity" value="error"/>
    <property name="fileExtensions" value="java"/>
    
    <module name="SuppressionFilter">
        <property name="file" value="${checkstyle.suppressions.file}"/>
    </module>
    
    <module name="TreeWalker">
        <!-- Naming Conventions -->
        <module name="TypeName">
            <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="MethodName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="ConstantName">
            <property name="format" value="^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"/>
        </module>
        
        <module name="LocalVariableName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <!-- Code Style -->
        <module name="LeftCurly"/>
        <module name="RightCurly"/>
        <module name="NeedBraces"/>
        
        <module name="WhitespaceAround"/>
        <module name="NoWhitespaceBefore"/>
        
        <!-- Imports -->
        <module name="AvoidStarImport"/>
        <module name="UnusedImports"/>
        <module name="RedundantImport"/>
        
        <!-- Size Violations -->
        <module name="LineLength">
            <property name="max" value="120"/>
        </module>
        
        <module name="MethodLength">
            <property name="max" value="150"/>
        </module>
        
        <!-- Complexity -->
        <module name="CyclomaticComplexity">
            <property name="max" value="15"/>
        </module>
        
        <!-- Best Practices -->
        <module name="EmptyBlock"/>
        <module name="EqualsHashCode"/>
        <module name="SimplifyBooleanExpression"/>
        <module name="SimplifyBooleanReturn"/>
        
        <!-- Annotations -->
        <module name="MissingOverride"/>
    </module>
</module>
```

#### SpotBugs Configuration (Gradle)
```groovy
// build.gradle
spotbugs {
    effort = 'max'
    reportLevel = 'high'
    excludeFilter = file("${project.rootDir}/config/spotbugs/spotbugs-exclude.xml")
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/main/spotbugs.html")
        }
        xml {
            required = false
        }
    }
}

tasks.named('spotbugsTest') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/test/spotbugs.html")
        }
    }
}
```

#### config/spotbugs/spotbugs-exclude.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<FindBugsFilter>
    <!-- Exclude generated code -->
    <Match>
        <Package name="~.*\.dto.*"/>
    </Match>
    
    <Match>
        <Package name="~.*\.entity.*"/>
    </Match>
    
    <Match>
        <Class name="~.*MapperImpl"/>
    </Match>
    
    <!-- Exclude specific bugs for Lombok -->
    <Match>
        <Bug pattern="EI_EXPOSE_REP,EI_EXPOSE_REP2"/>
        <Or>
            <Class name="~.*\.domain\.model\..*"/>
        </Or>
    </Match>
</FindBugsFilter>
```

#### Gradle Verification Tasks
```groovy
// Create custom task to run all quality checks
tasks.register('qualityCheck') {
    dependsOn 'checkstyleMain', 'checkstyleTest', 'spotbugsMain', 'jacocoTestCoverageVerification'
    description = 'Run all quality checks: Checkstyle, SpotBugs, and JaCoCo'
    group = 'verification'
}

// Make 'check' depend on quality checks
check {
    dependsOn 'qualityCheck'
}

// Gradle wrapper
wrapper {
    gradleVersion = '8.5'
    distributionType = Wrapper.DistributionType.ALL
}
```

#### Run Quality Checks
```bash
# Run all quality checks
./gradlew check

# Run individual checks
./gradlew checkstyleMain
./gradlew spotbugsMain
./gradlew test jacocoTestReport
./gradlew jacocoTestCoverageVerification

# Build with quality checks
./gradlew clean build

# Generate reports
./gradlew jacocoTestReport
# Report: build/reports/jacoco/test/html/index.html

./gradlew checkstyleMain
# Report: build/reports/checkstyle/main.html

./gradlew spotbugsMain
# Report: build/reports/spotbugs/main/spotbugs.html
```

### 8. Domain Modeling Best Practices

#### Value Objects
```java
@Value
@Builder
public class PaymentAmount {
    BigDecimal value;
    Currency currency;
    
    public static PaymentAmount of(double value, Currency currency) {
        if (value <= 0) {
            throw new InvalidPaymentException("Amount must be positive");
        }
        return new PaymentAmount(BigDecimal.valueOf(value), currency);
    }
}
```

#### Aggregates
```java
@Builder(toBuilder = true)
@Value
public class PaymentOrder {
    PaymentOrderId id;
    PayerReference payerReference;
    PayeeReference payeeReference;
    PaymentAmount amount;
    PaymentStatus status;
    LocalDateTime createdAt;
    
    // Business invariants
    public PaymentOrder validate() {
        if (status == PaymentStatus.CANCELLED && amount.getValue().compareTo(BigDecimal.ZERO) > 0) {
            throw new InvalidPaymentException("Cancelled orders cannot have positive amount");
        }
        return this;
    }
    
    public PaymentOrder markAsProcessed() {
        if (status != PaymentStatus.INITIATED) {
            throw new InvalidPaymentException("Only initiated orders can be processed");
        }
        return this.toBuilder().status(PaymentStatus.PROCESSED).build();
    }
}
```

#### Domain Events (if needed)
```java
@Value
public class PaymentOrderInitiatedEvent {
    String paymentOrderReference;
    PaymentAmount amount;
    LocalDateTime occurredOn;
}
```

### 9. Error Handling (RFC 7807)

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(PaymentOrderNotFoundException.class)
    public ResponseEntity<ProblemDetail> handleNotFound(PaymentOrderNotFoundException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, 
            ex.getMessage()
        );
        problem.setTitle("Payment Order Not Found");
        problem.setProperty("paymentOrderReference", ex.getPaymentOrderReference());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem);
    }
    
    @ExceptionHandler(InvalidPaymentException.class)
    public ResponseEntity<ProblemDetail> handleInvalidPayment(InvalidPaymentException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST,
            ex.getMessage()
        );
        problem.setTitle("Invalid Payment Order");
        problem.setProperty("validationErrors", ex.getErrors());
        return ResponseEntity.badRequest().body(problem);
    }
}
```

### 10. Docker Configuration with H2

#### Multi-stage Dockerfile (Gradle)
```dockerfile
# Build stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

# Copy Gradle files
COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .

# Copy source code
COPY src src
COPY config config

# Build application (skip tests for faster builds, tests run in CI/CD)
RUN ./gradlew clean build -x test --no-daemon

# Runtime stage
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Create non-root user for security
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# Copy JAR from builder
COPY --from=builder /app/build/libs/*.jar app.jar

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# JVM options
ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC -XX:+UseContainerSupport"

# Run application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

#### docker-compose.yml (H2 in-memory)
```yaml
version: '3.8'

services:
  payment-initiation-service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: payment-initiation-service
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - JAVA_OPTS=-Xms256m -Xmx512m
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - payment-network
    restart: unless-stopped

networks:
  payment-network:
    driver: bridge

# Optional: Add volumes for H2 file-based persistence
# volumes:
#   h2-data:
#     driver: local
```

#### application-docker.yml (For containerized H2)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 with file persistence in Docker (optional)
  datasource:
    url: jdbc:h2:file:/app/data/paymentdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: true  # Allow access from outside container
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: false

server:
  port: 8080

logging:
  level:
    com.hiberus.banking: INFO
    org.springframework.web: WARN
```

#### Docker Commands
```bash
# Build image
docker build -t payment-initiation-service:latest .

# Run with docker-compose
docker-compose up -d

# View logs
docker-compose logs -f payment-initiation-service

# Stop services
docker-compose down

# Rebuild and restart
docker-compose up -d --build

# Access H2 Console (if enabled)
# URL: http://localhost:8080/h2-console
# JDBC URL: jdbc:h2:mem:paymentdb
# Username: sa
# Password: (empty)

# Health check
curl http://localhost:8080/actuator/health

# Test API
curl -X POST http://localhost:8080/payment-initiation/payment-orders \
  -H "Content-Type: application/json" \
  -d '{
    "payerReference": "CUST-123",
    "payeeReference": "CUST-456",
    "amount": {
      "value": 1500.50,
      "currency": "USD"
    },
    "paymentPurpose": "Invoice payment"
  }'
```

#### .dockerignore
```
.git
.gitignore
.gradle
build/
!build/libs/*.jar
*.md
.idea
*.iml
.vscode
target/
*.log
```

#### Alternative: Dockerfile with tests included
```dockerfile
# Build and test stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .
COPY config config
COPY src src

# Run tests and build
RUN ./gradlew clean build --no-daemon

# Runtime stage (same as before)
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

COPY --from=builder /app/build/libs/*.jar app.jar

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 11. AI-Assisted Development Documentation

#### Structure for ai/ folder
```
ai/
├── prompts.md                 # All prompts used
├── decisions.md              # Architectural decisions and rationale
└── generations/              # Generated code samples
    ├── openapi-draft.yaml
    ├── domain-skeleton.java
    └── test-generation.java
```

#### Example prompts.md format
```markdown
## Prompt 1: WSDL Analysis
**Prompt**: "Analyze this WSDL for PaymentOrderService and map to BIAN Payment Initiation Service Domain. Identify: operations, data structures, business rules, and status flows."

**Response Summary**: 
- SOAP operations: createPaymentOrder, getPaymentOrder, updateOrderStatus
- Mapped to BIAN: Initiate, Retrieve, Execute
- Key fields: orderId → paymentOrderReference, amount, payer/payee, status

**Manual Corrections**:
- Changed generic "orderId" to BIAN-compliant "paymentOrderReference"
- Added currency field (was missing in WSDL)
- Refined status enum to align with BIAN lifecycle

## Prompt 2: OpenAPI Generation
[...]
```

### 12. Code Style & Conventions

#### Naming Conventions
- **Classes**: PascalCase (e.g., `PaymentOrder`, `InitiatePaymentOrderService`)
- **Methods**: camelCase, verb-based (e.g., `initiatePayment`, `retrieveOrderStatus`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_PAYMENT_AMOUNT`)
- **Packages**: lowercase, domain-driven (e.g., `domain.model`, `adapter.in.rest`)

#### BIAN-Specific Conventions
- Prefix interfaces with use case: `InitiatePaymentOrderUseCase`
- Use "Reference" suffix for IDs: `paymentOrderReference`, `payerReference`
- Status naming: Use BIAN lifecycle terms (INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED)

#### Lombok Usage
```java
@Value                    // For immutable value objects
@Builder(toBuilder=true) // For entities with many fields
@RequiredArgsConstructor // For dependency injection
@Slf4j                   // For logging
```

### 13. Observability & Production Readiness

#### Actuator Configuration
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    tags:
      application: payment-initiation-service
      service-domain: payment-initiation
```

#### Custom Metrics
```java
@Component
@RequiredArgsConstructor
public class PaymentMetrics {
    
    private final MeterRegistry registry;
    
    public void recordPaymentInitiated(PaymentAmount amount) {
        registry.counter("payment.initiated", 
            "currency", amount.getCurrency().toString())
            .increment();
        
        registry.summary("payment.amount")
            .record(amount.getValue().doubleValue());
    }
}
```

#### Logging Best Practices
```java
// Structured logging
log.info("Payment order initiated", 
    kv("paymentOrderReference", order.getId()),
    kv("amount", order.getAmount().getValue()),
    kv("status", order.getStatus()));

// Never log sensitive data (PII)
// Use correlation IDs for tracing
```

### 14. Security Considerations

- Validate all inputs at adapter layer
- Use Bean Validation annotations in DTOs
- Implement idempotency using `Idempotency-Key` header
- Add rate limiting for endpoints
- Sanitize error messages (don't expose internal details)

### 15. Documentation Requirements

#### README.md Must Include
1. **Project Overview**: BIAN SD, migration context
2. **Architecture Decision Records (ADRs)**: Why hexagonal, why reactive
3. **Setup Instructions**: Prerequisites, local run, Docker
4. **API Documentation**: Link to Swagger UI, example requests
5. **Testing**: How to run tests, coverage reports
6. **AI Usage**: Summary of prompts and generated code
7. **Quality Gates**: Checkstyle, SpotBugs, JaCoCo results

## Validation Checklist

Before committing code, ensure:
- [ ] Follows hexagonal architecture (no Spring in domain)
- [ ] OpenAPI contract-first approach used (interfaces generated)
- [ ] All BIAN naming conventions followed (payment-initiation, PaymentOrder BQ)
- [ ] MapStruct mappers configured correctly (3 layers: REST, Persistence, Application)
- [ ] Unit tests written for domain and application layers (80%+ coverage)
- [ ] Integration tests with WebTestClient for all endpoints
- [ ] Repository tests for JPA layer
- [ ] `./gradlew check` passes (Checkstyle, SpotBugs, JaCoCo)
- [ ] H2 database configured correctly (in-memory or file-based)
- [ ] Dockerfile builds successfully (`docker build -t payment-service .`)
- [ ] docker-compose up works (`docker-compose up -d`)
- [ ] All endpoints return correct HTTP status codes (201, 200, 404, 400, 500)
- [ ] RFC 7807 error handling implemented (application/problem+json)
- [ ] AI usage documented in ai/ folder (prompts.md, decisions.md, generations/)
- [ ] README updated with setup instructions and API documentation
- [ ] Actuator endpoints exposed for health checks
- [ ] Logging configured appropriately (no sensitive data)
- [ ] Value objects are immutable (Lombok @Value)
- [ ] No framework dependencies in domain layer
- [ ] All exceptions properly handled in GlobalExceptionHandler

## Additional Gradle Commands

```bash
# Clean build
./gradlew clean build

# Run with quality checks
./gradlew clean build check

# Run only tests
./gradlew test

# Generate coverage report
./gradlew test jacocoTestReport
# Open: build/reports/jacoco/test/html/index.html

# Run checkstyle only
./gradlew checkstyleMain checkstyleTest

# Run spotbugs only
./gradlew spotbugsMain spotbugsTest

# Build without tests (faster for development)
./gradlew clean build -x test

# Run application locally
./gradlew bootRun

# Generate OpenAPI code
./gradlew openApiGenerate

# View project dependencies
./gradlew dependencies

# View available tasks
./gradlew tasks
```

## Remember
- **BIAN alignment is non-negotiable**: Always validate against BIAN standards
- **Domain purity**: Keep domain layer framework-agnostic
- **Test-first mindset**: Write tests before implementation
- **Document AI usage**: Every AI-generated code must be reviewed and documented
- **Quality over speed**: Meet all quality gates before considering "done"

---

When in doubt, ask yourself: "Does this align with BIAN Payment Initiation Service Domain standards?" and "Is this following hexagonal architecture principles?"
          enum: [USD, EUR, GBP, JPY]
          example: "USD"
    
    # Payment Status Enum (BIAN lifecycle, mapped from SOAP)
    PaymentStatus:
      type: string
      description: |
        Payment order status following BIAN lifecycle.
        **SOAP to BIAN mapping**:
        - ACCEPTED → INITIATED
        - PENDING → PENDING
        - PROCESSING → PROCESSED
        - SETTLED → COMPLETED
        - REJECTED → FAILED
        - CANCELLED → CANCELLED
      enum:
        - INITIATED
        - PENDING
        - PROCESSED
        - COMPLETED
        - FAILED
        - CANCELLED
      example: "INITIATED"
    
    # RFC 7807 Problem Detail
    ProblemDetail:
      type: object
      properties:
        type:
          type: string
          format: uri
          example: "https://api.bank.com/problems/payment-validation-error"
        title:
          type: string
          example: "Payment Validation Error"
        status:
          type: integer
          example: 400
        detail:
          type: string
          example: "Invalid IBAN format for debtor account"
        instance:
          type: string
          format: uri
          example: "/payment-initiation/payment-orders"
        validationErrors:
          type: array
          items:
            type: object
            properties:
              field:
                type: string
              message:
                type: string
  
  responses:
    BadRequest:
      description: Bad request - validation errors
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
          examples:
            validation:
              summary: Validation error
              value:
                type: "https://api.bank.com/problems/validation-error"
                title: "Validation Error"
                status: 400
                detail: "Request validation failed"
                validationErrors:
                  - field: "debtorAccount.iban"
                    message: "Invalid IBAN format"
    
    NotFound:
      description: Resource not found
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
          examples:
            notFound:
              summary: Payment order not found
              value:
                type: "https://api.bank.com/problems/not-found"
                title: "Payment Order Not Found"
                status: 404
                detail: "Payment order with reference PO-9999 not found"
    
    InternalServerError:
      description: Internal server error
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
```
```yaml
# openapi.yaml structure
openapi: 3.0.3
info:
  title: BIAN Payment Initiation API
  version: 1.0.0
  description: Payment Order management aligned with BIAN Service Domain

servers:
  - url: http://localhost:8080
    description: Local development server

paths:
  /payment-initiation/payment-orders:
    post:
      operationId: initiatePaymentOrder
      tags: [Payment Initiation]
      summary: Initiate a new payment order
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InitiatePaymentOrderRequest'
      responses:
        '201':
          description: Payment order successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InitiatePaymentOrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '500':
          $ref: '#/components/responses/InternalServerError'
  
  /payment-initiation/payment-orders/{id}:
    get:
      operationId: retrievePaymentOrder
      tags: [Payment Initiation]
      summary: Retrieve payment order details
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RetrievePaymentOrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /payment-initiation/payment-orders/{id}/status:
    get:
      operationId: retrievePaymentOrderStatus
      tags: [Payment Initiation]
      summary: Retrieve payment order status
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order status retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentOrderStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    InitiatePaymentOrderRequest:
      type: object
      required: 
        - payerReference
        - payeeReference
        - amount
      properties:
        payerReference:
          type: string
          description: Reference to the payer (customer ID)
          example: "CUST-12345"
        payeeReference:
          type: string
          description: Reference to the payee (beneficiary ID)
          example: "CUST-67890"
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
          description: Purpose of the payment
          example: "Invoice payment"
        paymentDate:
          type: string
          format: date
          description: Requested payment date
          example: "2024-11-20"
    
    InitiatePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
          description: BIAN-compliant payment order reference
          example: "PO-2024-001234"
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        createdAt:
          type: string
          format: date-time
    
    RetrievePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
        paymentDate:
          type: string
          format: date
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    PaymentOrderStatusResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        statusReason:
          type: string
          description: Reason for current status
        lastUpdated:
          type: string
          format: date-time
    
    PaymentAmount:
      type: object
      required:
        - value
        - currency
      properties:
        value:
          type: number
          format: double
          minimum: 0.01
          example: 1500.50
        currency:
          type: string
          enum: [USD, EUR, GBP, JPY]
          example: "USD"
    
    ProblemDetail:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request - validation errors
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    NotFound:
      description: Resource not found
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    InternalServerError:
      description: Internal server error
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
```

#### Gradle Configuration (build.gradle)
```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'org.openapi.generator' version '7.0.1'
    id 'checkstyle'
    id 'com.github.spotbugs' version '6.0.0'
    id 'jacoco'
}

group = 'com.hiberus.banking'
version = '1.0.0'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

ext {
    mapstructVersion = '1.5.5.Final'
    lombokVersion = '1.18.30'
    openApiVersion = '2.2.0'
}

dependencies {
    // Spring Boot Starters
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    
    // H2 Database
    runtimeOnly 'com.h2database:h2'
    
    // OpenAPI
    implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${openApiVersion}"
    
    // MapStruct
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
    
    // Lombok
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    
    // Lombok + MapStruct compatibility
    annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"
    
    // Testing
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-webflux'  // For WebTestClient
    testImplementation 'io.rest-assured:rest-assured:5.4.0'
    testImplementation 'org.assertj:assertj-core'
    
    // Test Lombok
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
}

// OpenAPI Generator Task
openApiGenerate {
    generatorName = 'spring'
    inputSpec = "$projectDir/src/main/resources/openapi.yaml"
    outputDir = "$buildDir/generated"
    apiPackage = 'com.hiberus.banking.payment.adapter.in.rest.api'
    modelPackage = 'com.hiberus.banking.payment.adapter.in.rest.dto'
    invokerPackage = 'com.hiberus.banking.payment.adapter.in.rest.invoker'
    configOptions = [
        interfaceOnly: 'true',
        useSpringBoot3: 'true',
        useTags: 'true',
        dateLibrary: 'java8',
        serializationLibrary: 'jackson',
        hideGenerationTimestamp: 'true'
    ]
}

// Add generated sources to source sets
sourceSets {
    main {
        java {
            srcDirs += "$buildDir/generated/src/main/java"
        }
    }
}

// Compile depends on generation
compileJava.dependsOn tasks.openApiGenerate

// JaCoCo Configuration
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
    }
}

// Checkstyle Configuration
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
}

// SpotBugs Configuration
spotbugs {
    effort = 'max'
    reportLevel = 'high'
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
        }
        xml {
            required = false
        }
    }
}

// Test Configuration
test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

// Build task order
check.dependsOn jacocoTestCoverageVerification
```

#### Controller Implementation (Spring MVC)
```java
@RestController
@RequiredArgsConstructor
@Slf4j
public class PaymentInitiationController implements PaymentInitiationApi {
    
    private final InitiatePaymentOrderUseCase initiateUseCase;
    private final RetrievePaymentOrderUseCase retrieveUseCase;
    private final RetrievePaymentOrderStatusUseCase retrieveStatusUseCase;
    private final PaymentOrderRestMapper mapper;
    
    @Override
    public ResponseEntity<InitiatePaymentOrderResponse> initiatePaymentOrder(
            InitiatePaymentOrderRequest request) {
        
        log.info("Initiating payment order for payer: {}", request.getPayerReference());
        
        PaymentOrder domainOrder = mapper.toDomain(request);
        PaymentOrder initiatedOrder = initiateUseCase.initiate(domainOrder);
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(initiatedOrder);
        
        log.info("Payment order initiated successfully: {}", response.getPaymentOrderReference());
        
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(response);
    }
    
    @Override
    public ResponseEntity<RetrievePaymentOrderResponse> retrievePaymentOrder(String id) {
        
        log.info("Retrieving payment order: {}", id);
        
        PaymentOrder paymentOrder = retrieveUseCase.retrieve(id);
        RetrievePaymentOrderResponse response = mapper.toRetrieveResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
    
    @Override
    public ResponseEntity<PaymentOrderStatusResponse> retrievePaymentOrderStatus(String id) {
        
        log.info("Retrieving payment order status: {}", id);
        
        PaymentOrder paymentOrder = retrieveStatusUseCase.retrieveStatus(id);
        PaymentOrderStatusResponse response = mapper.toStatusResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
}
```

### 5. Spring MVC with H2 Database

#### Application Configuration (application.yml)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 Database Configuration
  datasource:
    url: jdbc:h2:mem:paymentdb
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: false
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
  
  # Jackson Configuration
  jackson:
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

# Server Configuration
server:
  port: 8080
  servlet:
    context-path: /
  error:
    include-message: always
    include-binding-errors: always
    include-exception: false
    include-stacktrace: never

# Management / Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    tags:
      application: ${spring.application.name}
      service-domain: payment-initiation

# Logging
logging:
  level:
    com.hiberus.banking: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

#### JPA Entity Example
```java
@Entity
@Table(name = "payment_orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PaymentOrderEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(name = "payment_order_reference", nullable = false, unique = true, length = 50)
    private String paymentOrderReference;
    
    @Column(name = "payer_reference", nullable = false, length = 50)
    private String payerReference;
    
    @Column(name = "payee_reference", nullable = false, length = 50)
    private String payeeReference;
    
    @Column(name = "amount", nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "currency", nullable = false, length = 3)
    private String currency;
    
    @Column(name = "payment_purpose", length = 255)
    private String paymentPurpose;
    
    @Column(name = "payment_date")
    private LocalDate paymentDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PaymentStatusEntity status;
    
    @Column(name = "status_reason", length = 500)
    private String statusReason;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        if (status == null) {
            status = PaymentStatusEntity.INITIATED;
        }
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

@Getter
@RequiredArgsConstructor
enum PaymentStatusEntity {
    INITIATED("Payment order has been initiated"),
    PENDING("Payment order is pending processing"),
    PROCESSED("Payment order has been processed"),
    COMPLETED("Payment order completed successfully"),
    FAILED("Payment order failed"),
    CANCELLED("Payment order has been cancelled");
    
    private final String description;
}
```

#### Spring Data JPA Repository
```java
@Repository
public interface PaymentOrderJpaRepository extends JpaRepository<PaymentOrderEntity, UUID> {
    
    Optional<PaymentOrderEntity> findByPaymentOrderReference(String paymentOrderReference);
    
    List<PaymentOrderEntity> findByPayerReference(String payerReference);
    
    List<PaymentOrderEntity> findByStatus(PaymentStatusEntity status);
    
    @Query("SELECT p FROM PaymentOrderEntity p WHERE p.createdAt BETWEEN :startDate AND :endDate")
    List<PaymentOrderEntity> findByDateRange(
        @Param("startDate") LocalDateTime startDate, 
        @Param("endDate") LocalDateTime endDate
    );
    
    boolean existsByPaymentOrderReference(String paymentOrderReference);
}
```

#### Repository Adapter Implementation
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PaymentOrderRepositoryAdapter implements PaymentOrderRepository {
    
    private final PaymentOrderJpaRepository jpaRepository;
    private final PaymentOrderPersistenceMapper persistenceMapper;
    
    @Override
    public PaymentOrder save(PaymentOrder paymentOrder) {
        log.debug("Saving payment order: {}", paymentOrder.getPaymentOrderReference());
        
        PaymentOrderEntity entity = persistenceMapper.toEntity(paymentOrder);
        PaymentOrderEntity savedEntity = jpaRepository.save(entity);
        
        log.debug("Payment order saved with ID: {}", savedEntity.getId());
        return persistenceMapper.toDomain(savedEntity);
    }
    
    @Override
    public Optional<PaymentOrder> findByReference(String paymentOrderReference) {
        log.debug("Finding payment order by reference: {}", paymentOrderReference);
        
        return jpaRepository.findByPaymentOrderReference(paymentOrderReference)
            .map(persistenceMapper::toDomain);
    }
    
    @Override
    public boolean existsByReference(String paymentOrderReference) {
        return jpaRepository.existsByPaymentOrderReference(paymentOrderReference);
    }
    
    @Override
    public List<PaymentOrder> findAll() {
        return jpaRepository.findAll().stream()
            .map(persistenceMapper::toDomain)
            .collect(Collectors.toList());
    }
}
```

#### H2 Console Configuration
```java
@Configuration
public class H2ConsoleConfig {
    
    @Bean
    public ServletRegistrationBean<WebServlet> h2Console() {
        ServletRegistrationBean<WebServlet> registration = 
            new ServletRegistrationBean<>(new WebServlet());
        registration.addUrlMappings("/h2-console/*");
        return registration;
    }
}
```

#### Data Initialization (Optional - for testing)
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class DataInitializer {
    
    private final PaymentOrderJpaRepository repository;
    
    @EventListener(ApplicationReadyEvent.class)
    public void loadSampleData() {
        if (repository.count() == 0) {
            log.info("Loading sample payment orders...");
            
            PaymentOrderEntity order1 = PaymentOrderEntity.builder()
                .paymentOrderReference("PO-2024-001")
                .payerReference("CUST-12345")
                .payeeReference("CUST-67890")
                .amount(new BigDecimal("1500.50"))
                .currency("USD")
                .paymentPurpose("Invoice payment")
                .paymentDate(LocalDate.now())
                .status(PaymentStatusEntity.INITIATED)
                .build();
            
            repository.save(order1);
            log.info("Sample data loaded successfully");
        }
    }
}
```

### 6. MapStruct Mappers (Three Layers)

MapStruct is used for clean transformation between layers. There are THREE types of mappers:

#### 1. REST Mapper (Adapter Layer: DTO ↔ Domain)
```java
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR)
public interface PaymentOrderRestMapper {
    
    // Request DTO → Domain
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "paymentOrderReference", ignore = true)
    @Mapping(target = "status", constant = "INITIATED")
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    @Mapping(target = "updatedAt", ignore = true)
    PaymentOrder toDomain(InitiatePaymentOrderRequest request);
    
    // Domain → Response DTO (Initiate)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    InitiatePaymentOrderResponse toInitiateResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Retrieve)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    RetrievePaymentOrderResponse toRetrieveResponse(PaymentOrder paymentOrder);
    
    // Domain → Response DTO (Status)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    @Mapping(source = "updatedAt", target = "lastUpdated")
    PaymentOrderStatusResponse toStatusResponse(PaymentOrder paymentOrder);
    
    // Value Object mappings
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    PaymentAmount toPaymentAmount(com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount dtoAmount);
    
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount toPaymentAmountDto(PaymentAmount domainAmount);
}
```

#### 2. Persistence Mapper (Adapter Layer: Domain ↔ Entity)
```java
@Mapper(componentModel = "spring", 
        unmappedTargetPolicy = ReportingPolicy.ERROR,
        uses = {PaymentStatusMapper.class})
public interface PaymentOrderPersistenceMapper {
    
    // Domain → Entity
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "payerReference.value", target = "payerReference")
    @Mapping(source = "payeeReference.value", target = "payeeReference")
    @Mapping(source = "amount.value", target = "amount")
    @Mapping(source = "amount.currency", target = "currency")
    @Mapping(source = "status", target = "status")
    @Mapping(target = "id", ignore = true)  // Let JPA generate
    PaymentOrderEntity toEntity(PaymentOrder domain);
    
    // Entity → Domain
    @Mapping(source = "paymentOrderReference", target = "id.value")
    @Mapping(source = "payerReference", target = "payerReference.value")
    @Mapping(source = "payeeReference", target = "payeeReference.value")
    @Mapping(source = "amount", target = "amount.value")
    @Mapping(source = "currency", target = "amount.currency")
    PaymentOrder toDomain(PaymentOrderEntity entity);
    
    // Custom mapping for status
    default PaymentStatus mapStatus(PaymentStatusEntity entityStatus) {
        return PaymentStatus.valueOf(entityStatus.name());
    }
    
    default PaymentStatusEntity mapStatus(PaymentStatus domainStatus) {
        return PaymentStatusEntity.valueOf(domainStatus.name());
    }
}
```

#### 3. Application Mapper (Optional: Complex transformations)
```java
@Mapper(componentModel = "spring")
public interface PaymentOrderApplicationMapper {
    
    // For complex business logic transformations
    @Mapping(target = "enrichedData", expression = "java(enrichData(source))")
    PaymentOrder enrichForProcessing(PaymentOrder source);
    
    default String enrichData(PaymentOrder order) {
        // Complex business logic here
        return "ENRICHED-" + order.getPaymentOrderReference();
    }
}
```

#### MapStruct Configuration Best Practices
```java
@MapperConfig(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.ERROR,  // Fail on unmapped fields
    unmappedSourcePolicy = ReportingPolicy.WARN,    // Warn on unmapped sources
    mappingInheritanceStrategy = MappingInheritanceStrategy.AUTO_INHERIT_FROM_CONFIG
)
public interface CentralMapperConfig {
}

// Then use it in mappers
@Mapper(config = CentralMapperConfig.class)
public interface PaymentOrderRestMapper {
    // ... mappings
}
```

#### Testing MapStruct Mappers
```java
@SpringBootTest
class PaymentOrderRestMapperTest {
    
    @Autowired
    private PaymentOrderRestMapper mapper;
    
    @Test
    @DisplayName("Should map InitiatePaymentOrderRequest to PaymentOrder domain")
    void shouldMapRequestToDomain() {
        // Given
        InitiatePaymentOrderRequest request = new InitiatePaymentOrderRequest()
            .payerReference("CUST-123")
            .payeeReference("CUST-456")
            .amount(new com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount()
                .value(1000.0)
                .currency("USD"))
            .paymentPurpose("Test payment");
        
        // When
        PaymentOrder domain = mapper.toDomain(request);
        
        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getPayerReference().getValue()).isEqualTo("CUST-123");
        assertThat(domain.getPayeeReference().getValue()).isEqualTo("CUST-456");
        assertThat(domain.getAmount().getValue()).isEqualByComparingTo("1000.0");
        assertThat(domain.getAmount().getCurrency()).isEqualTo(Currency.USD);
        assertThat(domain.getStatus()).isEqualTo(PaymentStatus.INITIATED);
    }
    
    @Test
    @DisplayName("Should map PaymentOrder domain to InitiatePaymentOrderResponse")
    void shouldMapDomainToResponse() {
        // Given
        PaymentOrder domain = PaymentOrderMother.valid();
        
        // When
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(domain);
        
        // Then
        assertThat(response).isNotNull();
        assertThat(response.getPaymentOrderReference()).isEqualTo(domain.getId().getValue());
        assertThat(response.getPaymentOrderStatus()).isEqualTo(domain.getStatus().name());
    }
}
```

### 7. Testing Strategy with Spring MVC and WebTestClient

#### Unit Tests (Domain & Application Layer)
```java
@ExtendWith(MockitoExtension.class)
class InitiatePaymentOrderServiceTest {
    
    @Mock
    private PaymentOrderRepository repository;
    
    @Mock
    private PaymentValidationPort validationPort;
    
    @InjectMocks
    private InitiatePaymentOrderService service;
    
    @Test
    @DisplayName("Should initiate payment order when valid")
    void shouldInitiatePaymentOrderWhenValid() {
        // Given
        PaymentOrder order = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenReturn(order);
        
        // When
        PaymentOrder result = service.initiate(order);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getStatus()).isEqualTo(PaymentStatus.INITIATED);
        assertThat(result.getPaymentOrderReference()).isNotNull();
        
        verify(validationPort).validate(order);
        verify(repository).save(any(PaymentOrder.class));
    }
    
    @Test
    @DisplayName("Should throw InvalidPaymentException when validation fails")
    void shouldThrowExceptionWhenValidationFails() {
        // Given
        PaymentOrder order = PaymentOrderMother.withInvalidAmount();
        when(validationPort.validate(any())).thenReturn(false);
        
        // When & Then
        assertThatThrownBy(() -> service.initiate(order))
            .isInstanceOf(InvalidPaymentException.class)
            .hasMessageContaining("validation failed");
        
        verify(validationPort).validate(order);
        verify(repository, never()).save(any());
    }
    
    @Test
    @DisplayName("Should generate unique payment order reference")
    void shouldGenerateUniqueReference() {
        // Given
        PaymentOrder order1 = PaymentOrderMother.valid();
        PaymentOrder order2 = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenAnswer(inv -> inv.getArgument(0));
        
        // When
        PaymentOrder result1 = service.initiate(order1);
        PaymentOrder result2 = service.initiate(order2);
        
        // Then
        assertThat(result1.getPaymentOrderReference())
            .isNotEqualTo(result2.getPaymentOrderReference());
    }
}
```

#### Integration Tests with WebTestClient (Recommended for Spring MVC)
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class PaymentInitiationIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        repository.deleteAll();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 201 Created")
    void shouldInitiatePaymentOrderSuccessfully() {
        // Given
        InitiatePaymentOrderRequest request = InitiatePaymentOrderRequest.builder()
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1500.50)
                .currency("USD")
                .build())
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .build();
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .exchange()
            .expectStatus().isCreated()
            .expectHeader().exists("Location")
            .expectBody(InitiatePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getPaymentOrderReference()).startsWith("PO-");
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getPayeeReference()).isEqualTo("CUST-67890");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
                assertThat(response.getCreatedAt()).isNotNull();
            });
        
        // Verify database
        assertThat(repository.count()).isEqualTo(1);
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 200 OK")
    void shouldRetrievePaymentOrderSuccessfully() {
        // Given - Create a payment order first
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(RetrievePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id}/status - Should return 200 OK")
    void shouldRetrievePaymentOrderStatusSuccessfully() {
        // Given
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}/status", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(PaymentOrderStatusResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getLastUpdated()).isNotNull();
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 404 Not Found")
    void shouldReturn404WhenPaymentOrderNotFound() {
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", "NON-EXISTENT")
            .exchange()
            .expectStatus().isNotFound()
            .expectBody()
            .jsonPath("$.title").isEqualTo("Payment Order Not Found")
            .jsonPath("$.status").isEqualTo(404)
            .jsonPath("$.detail").exists();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 400 Bad Request for invalid data")
    void shouldReturn400ForInvalidRequest() {
        // Given - Invalid request (missing required fields)
        String invalidRequest = """
            {
                "payerReference": "CUST-123"
            }
            """;
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(invalidRequest)
            .exchange()
            .expectStatus().isBadRequest()
            .expectBody()
            .jsonPath("$.title").exists()
            .jsonPath("$.status").isEqualTo(400);
    }
    
    @Test
    @DisplayName("Should handle concurrent payment order creation")
    void shouldHandleConcurrentCreation() throws Exception {
        // Given
        int numberOfThreads = 5;
        ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);
        CountDownLatch latch = new CountDownLatch(numberOfThreads);
        
        // When
        for (int i = 0; i < numberOfThreads; i++) {
            final int index = i;
            executorService.submit(() -> {
                try {
                    InitiatePaymentOrderRequest request = createRequest("PAYER-" + index);
                    webTestClient.post()
                        .uri("/payment-initiation/payment-orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(request)
                        .exchange()
                        .expectStatus().isCreated();
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(10, TimeUnit.SECONDS);
        executorService.shutdown();
        
        // Then
        assertThat(repository.count()).isEqualTo(numberOfThreads);
    }
    
    // Helper methods
    private PaymentOrderEntity createSampleEntity() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-TEST-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Test payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
    
    private InitiatePaymentOrderRequest createRequest(String payerRef) {
        return InitiatePaymentOrderRequest.builder()
            .payerReference(payerRef)
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1000.0)
                .currency("USD")
                .build())
            .paymentPurpose("Concurrent test")
            .build();
    }
}
```

#### Alternative: REST Assured for Integration Tests
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class PaymentInitiationRestAssuredTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        RestAssured.basePath = "/payment-initiation";
        repository.deleteAll();
    }
    
    @Test
    void shouldInitiatePaymentOrder() {
        given()
            .contentType(ContentType.JSON)
            .body(createValidRequest())
        .when()
            .post("/payment-orders")
        .then()
            .statusCode(201)
            .body("paymentOrderReference", notNullValue())
            .body("paymentOrderStatus", equalTo("INITIATED"))
            .body("amount.value", equalTo(1500.50f))
            .body("amount.currency", equalTo("USD"));
    }
    
    @Test
    void shouldRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity saved = repository.save(createSampleEntity());
        
        // When & Then
        given()
            .pathParam("id", saved.getPaymentOrderReference())
        .when()
            .get("/payment-orders/{id}")
        .then()
            .statusCode(200)
            .body("paymentOrderReference", equalTo(saved.getPaymentOrderReference()))
            .body("paymentOrderStatus", equalTo("INITIATED"));
    }
}
```

#### Test Data Builders (Object Mother Pattern)
```java
public class PaymentOrderMother {
    
    public static PaymentOrder valid() {
        return PaymentOrder.builder()
            .id(PaymentOrderId.generate())
            .payerReference(PayerReference.of("CUST-12345"))
            .payeeReference(PayeeReference.of("CUST-67890"))
            .amount(PaymentAmount.of(1500.50, Currency.USD))
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatus.INITIATED)
            .createdAt(LocalDateTime.now())
            .build();
    }
    
    public static PaymentOrder withInvalidAmount() {
        return valid().toBuilder()
            .amount(PaymentAmount.of(-100.00, Currency.USD))
            .build();
    }
    
    public static PaymentOrder withStatus(PaymentStatus status) {
        return valid().toBuilder()
            .status(status)
            .build();
    }
    
    public static PaymentOrder pending() {
        return withStatus(PaymentStatus.PENDING);
    }
    
    public static PaymentOrder completed() {
        return withStatus(PaymentStatus.COMPLETED);
    }
}

public class PaymentOrderEntityMother {
    
    public static PaymentOrderEntity valid() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
}
```

#### Repository Tests
```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class PaymentOrderJpaRepositoryTest {
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    @DisplayName("Should save and retrieve payment order")
    void shouldSaveAndRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity entity = PaymentOrderEntityMother.valid();
        
        // When
        PaymentOrderEntity saved = repository.save(entity);
        entityManager.flush();
        entityManager.clear();
        
        // Then
        Optional<PaymentOrderEntity> found = repository.findByPaymentOrderReference(
            saved.getPaymentOrderReference()
        );
        
        assertThat(found).isPresent();
        assertThat(found.get().getPayerReference()).isEqualTo("CUST-12345");
        assertThat(found.get().getAmount()).isEqualByComparingTo("1500.50");
    }
    
    @Test
    @DisplayName("Should find payment orders by status")
    void shouldFindByStatus() {
        // Given
        repository.save(PaymentOrderEntityMother.valid());
        repository.save(PaymentOrderEntityMother.valid().toBuilder()
            .paymentOrderReference("PO-2024-002")
            .status(PaymentStatusEntity.COMPLETED)
            .build());
        entityManager.flush();
        
        // When
        List<PaymentOrderEntity> initiated = repository.findByStatus(PaymentStatusEntity.INITIATED);
        List<PaymentOrderEntity> completed = repository.findByStatus(PaymentStatusEntity.COMPLETED);
        
        // Then
        assertThat(initiated).hasSize(1);
        assertThat(completed).hasSize(1);
    }
}
```

### 8. Quality Gates (Mandatory - Gradle)

#### JaCoCo Configuration (Gradle)
```groovy
// build.gradle
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                '**/dto/**',
                '**/entity/**',
                '**/config/**',
                '**/*Application.class',
                '**/*MapperImpl.class'  // Exclude MapStruct generated classes
            ])
        }))
    }
}

jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
        
        rule {
            element = 'CLASS'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.70
            }
            excludes = [
                '*.dto.*',
                '*.entity.*',
                '*.config.*',
                '*Application',
                '*MapperImpl'
            ]
        }
    }
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

check.dependsOn jacocoTestCoverageVerification
```

#### Checkstyle Configuration (Gradle)
```groovy
// build.gradle
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
    configProperties = [
        'checkstyle.suppressions.file': "${project.rootDir}/config/checkstyle/suppressions.xml"
    ]
}

checkstyleMain {
    source = 'src/main/java'
    exclude '**/dto/**', '**/entity/**'  // Exclude generated code
}

checkstyleTest {
    source = 'src/test/java'
}

tasks.withType(Checkstyle) {
    reports {
        xml.required = true
        html.required = true
    }
}
```

#### config/checkstyle/checkstyle.xml
```xml
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
    "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
    "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <property name="charset" value="UTF-8"/>
    <property name="severity" value="error"/>
    <property name="fileExtensions" value="java"/>
    
    <module name="SuppressionFilter">
        <property name="file" value="${checkstyle.suppressions.file}"/>
    </module>
    
    <module name="TreeWalker">
        <!-- Naming Conventions -->
        <module name="TypeName">
            <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="MethodName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="ConstantName">
            <property name="format" value="^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"/>
        </module>
        
        <module name="LocalVariableName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <!-- Code Style -->
        <module name="LeftCurly"/>
        <module name="RightCurly"/>
        <module name="NeedBraces"/>
        
        <module name="WhitespaceAround"/>
        <module name="NoWhitespaceBefore"/>
        
        <!-- Imports -->
        <module name="AvoidStarImport"/>
        <module name="UnusedImports"/>
        <module name="RedundantImport"/>
        
        <!-- Size Violations -->
        <module name="LineLength">
            <property name="max" value="120"/>
        </module>
        
        <module name="MethodLength">
            <property name="max" value="150"/>
        </module>
        
        <!-- Complexity -->
        <module name="CyclomaticComplexity">
            <property name="max" value="15"/>
        </module>
        
        <!-- Best Practices -->
        <module name="EmptyBlock"/>
        <module name="EqualsHashCode"/>
        <module name="SimplifyBooleanExpression"/>
        <module name="SimplifyBooleanReturn"/>
        
        <!-- Annotations -->
        <module name="MissingOverride"/>
    </module>
</module>
```

#### SpotBugs Configuration (Gradle)
```groovy
// build.gradle
spotbugs {
    effort = 'max'
    reportLevel = 'high'
    excludeFilter = file("${project.rootDir}/config/spotbugs/spotbugs-exclude.xml")
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/main/spotbugs.html")
        }
        xml {
            required = false
        }
    }
}

tasks.named('spotbugsTest') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/test/spotbugs.html")
        }
    }
}
```

#### config/spotbugs/spotbugs-exclude.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<FindBugsFilter>
    <!-- Exclude generated code -->
    <Match>
        <Package name="~.*\.dto.*"/>
    </Match>
    
    <Match>
        <Package name="~.*\.entity.*"/>
    </Match>
    
    <Match>
        <Class name="~.*MapperImpl"/>
    </Match>
    
    <!-- Exclude specific bugs for Lombok -->
    <Match>
        <Bug pattern="EI_EXPOSE_REP,EI_EXPOSE_REP2"/>
        <Or>
            <Class name="~.*\.domain\.model\..*"/>
        </Or>
    </Match>
</FindBugsFilter>
```

#### Gradle Verification Tasks
```groovy
// Create custom task to run all quality checks
tasks.register('qualityCheck') {
    dependsOn 'checkstyleMain', 'checkstyleTest', 'spotbugsMain', 'jacocoTestCoverageVerification'
    description = 'Run all quality checks: Checkstyle, SpotBugs, and JaCoCo'
    group = 'verification'
}

// Make 'check' depend on quality checks
check {
    dependsOn 'qualityCheck'
}

// Gradle wrapper
wrapper {
    gradleVersion = '8.5'
    distributionType = Wrapper.DistributionType.ALL
}
```

#### Run Quality Checks
```bash
# Run all quality checks
./gradlew check

# Run individual checks
./gradlew checkstyleMain
./gradlew spotbugsMain
./gradlew test jacocoTestReport
./gradlew jacocoTestCoverageVerification

# Build with quality checks
./gradlew clean build

# Generate reports
./gradlew jacocoTestReport
# Report: build/reports/jacoco/test/html/index.html

./gradlew checkstyleMain
# Report: build/reports/checkstyle/main.html

./gradlew spotbugsMain
# Report: build/reports/spotbugs/main/spotbugs.html
```

### 8. Domain Modeling Best Practices

#### Value Objects
```java
@Value
@Builder
public class PaymentAmount {
    BigDecimal value;
    Currency currency;
    
    public static PaymentAmount of(double value, Currency currency) {
        if (value <= 0) {
            throw new InvalidPaymentException("Amount must be positive");
        }
        return new PaymentAmount(BigDecimal.valueOf(value), currency);
    }
}
```

#### Aggregates
```java
@Builder(toBuilder = true)
@Value
public class PaymentOrder {
    PaymentOrderId id;
    PayerReference payerReference;
    PayeeReference payeeReference;
    PaymentAmount amount;
    PaymentStatus status;
    LocalDateTime createdAt;
    
    // Business invariants
    public PaymentOrder validate() {
        if (status == PaymentStatus.CANCELLED && amount.getValue().compareTo(BigDecimal.ZERO) > 0) {
            throw new InvalidPaymentException("Cancelled orders cannot have positive amount");
        }
        return this;
    }
    
    public PaymentOrder markAsProcessed() {
        if (status != PaymentStatus.INITIATED) {
            throw new InvalidPaymentException("Only initiated orders can be processed");
        }
        return this.toBuilder().status(PaymentStatus.PROCESSED).build();
    }
}
```

#### Domain Events (if needed)
```java
@Value
public class PaymentOrderInitiatedEvent {
    String paymentOrderReference;
    PaymentAmount amount;
    LocalDateTime occurredOn;
}
```

### 9. Error Handling (RFC 7807)

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(PaymentOrderNotFoundException.class)
    public ResponseEntity<ProblemDetail> handleNotFound(PaymentOrderNotFoundException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, 
            ex.getMessage()
        );
        problem.setTitle("Payment Order Not Found");
        problem.setProperty("paymentOrderReference", ex.getPaymentOrderReference());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem);
    }
    
    @ExceptionHandler(InvalidPaymentException.class)
    public ResponseEntity<ProblemDetail> handleInvalidPayment(InvalidPaymentException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST,
            ex.getMessage()
        );
        problem.setTitle("Invalid Payment Order");
        problem.setProperty("validationErrors", ex.getErrors());
        return ResponseEntity.badRequest().body(problem);
    }
}
```

### 10. Docker Configuration with H2

#### Multi-stage Dockerfile (Gradle)
```dockerfile
# Build stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

# Copy Gradle files
COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .

# Copy source code
COPY src src
COPY config config

# Build application (skip tests for faster builds, tests run in CI/CD)
RUN ./gradlew clean build -x test --no-daemon

# Runtime stage
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Create non-root user for security
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# Copy JAR from builder
COPY --from=builder /app/build/libs/*.jar app.jar

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# JVM options
ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC -XX:+UseContainerSupport"

# Run application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

#### docker-compose.yml (H2 in-memory)
```yaml
version: '3.8'

services:
  payment-initiation-service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: payment-initiation-service
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - JAVA_OPTS=-Xms256m -Xmx512m
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - payment-network
    restart: unless-stopped

networks:
  payment-network:
    driver: bridge

# Optional: Add volumes for H2 file-based persistence
# volumes:
#   h2-data:
#     driver: local
```

#### application-docker.yml (For containerized H2)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 with file persistence in Docker (optional)
  datasource:
    url: jdbc:h2:file:/app/data/paymentdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: true  # Allow access from outside container
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: false

server:
  port: 8080

logging:
  level:
    com.hiberus.banking: INFO
    org.springframework.web: WARN
```

#### Docker Commands
```bash
# Build image
docker build -t payment-initiation-service:latest .

# Run with docker-compose
docker-compose up -d

# View logs
docker-compose logs -f payment-initiation-service

# Stop services
docker-compose down

# Rebuild and restart
docker-compose up -d --build

# Access H2 Console (if enabled)
# URL: http://localhost:8080/h2-console
# JDBC URL: jdbc:h2:mem:paymentdb
# Username: sa
# Password: (empty)

# Health check
curl http://localhost:8080/actuator/health

# Test API
curl -X POST http://localhost:8080/payment-initiation/payment-orders \
  -H "Content-Type: application/json" \
  -d '{
    "payerReference": "CUST-123",
    "payeeReference": "CUST-456",
    "amount": {
      "value": 1500.50,
      "currency": "USD"
    },
    "paymentPurpose": "Invoice payment"
  }'
```

#### .dockerignore
```
.git
.gitignore
.gradle
build/
!build/libs/*.jar
*.md
.idea
*.iml
.vscode
target/
*.log
```

#### Alternative: Dockerfile with tests included
```dockerfile
# Build and test stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .
COPY config config
COPY src src

# Run tests and build
RUN ./gradlew clean build --no-daemon

# Runtime stage (same as before)
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

COPY --from=builder /app/build/libs/*.jar app.jar

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 11. AI-Assisted Development Documentation

#### Structure for ai/ folder
```
ai/
├── prompts.md                 # All prompts used
├── decisions.md              # Architectural decisions and rationale
└── generations/              # Generated code samples
    ├── openapi-draft.yaml
    ├── domain-skeleton.java
    └── test-generation.java
```

#### Example prompts.md format
```markdown
## Prompt 1: WSDL Analysis
**Prompt**: "Analyze this WSDL for PaymentOrderService and map to BIAN Payment Initiation Service Domain. Identify: operations, data structures, business rules, and status flows."

**Response Summary**: 
- SOAP operations: createPaymentOrder, getPaymentOrder, updateOrderStatus
- Mapped to BIAN: Initiate, Retrieve, Execute
- Key fields: orderId → paymentOrderReference, amount, payer/payee, status

**Manual Corrections**:
- Changed generic "orderId" to BIAN-compliant "paymentOrderReference"
- Added currency field (was missing in WSDL)
- Refined status enum to align with BIAN lifecycle

## Prompt 2: OpenAPI Generation
[...]
```

### 12. Code Style & Conventions

#### Naming Conventions
- **Classes**: PascalCase (e.g., `PaymentOrder`, `InitiatePaymentOrderService`)
- **Methods**: camelCase, verb-based (e.g., `initiatePayment`, `retrieveOrderStatus`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_PAYMENT_AMOUNT`)
- **Packages**: lowercase, domain-driven (e.g., `domain.model`, `adapter.in.rest`)

#### BIAN-Specific Conventions
- Prefix interfaces with use case: `InitiatePaymentOrderUseCase`
- Use "Reference" suffix for IDs: `paymentOrderReference`, `payerReference`
- Status naming: Use BIAN lifecycle terms (INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED)

#### Lombok Usage
```java
@Value                    // For immutable value objects
@Builder(toBuilder=true) // For entities with many fields
@RequiredArgsConstructor // For dependency injection
@Slf4j                   // For logging
```

### 13. Observability & Production Readiness

#### Actuator Configuration
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    tags:
      application: payment-initiation-service
      service-domain: payment-initiation
```

#### Custom Metrics
```java
@Component
@RequiredArgsConstructor
public class PaymentMetrics {
    
    private final MeterRegistry registry;
    
    public void recordPaymentInitiated(PaymentAmount amount) {
        registry.counter("payment.initiated", 
            "currency", amount.getCurrency().toString())
            .increment();
        
        registry.summary("payment.amount")
            .record(amount.getValue().doubleValue());
    }
}
```

#### Logging Best Practices
```java
// Structured logging
log.info("Payment order initiated", 
    kv("paymentOrderReference", order.getId()),
    kv("amount", order.getAmount().getValue()),
    kv("status", order.getStatus()));

// Never log sensitive data (PII)
// Use correlation IDs for tracing
```

### 14. Security Considerations

- Validate all inputs at adapter layer
- Use Bean Validation annotations in DTOs
- Implement idempotency using `Idempotency-Key` header
- Add rate limiting for endpoints
- Sanitize error messages (don't expose internal details)

### 15. Documentation Requirements

#### README.md Must Include
1. **Project Overview**: BIAN SD, migration context
2. **Architecture Decision Records (ADRs)**: Why hexagonal, why reactive
3. **Setup Instructions**: Prerequisites, local run, Docker
4. **API Documentation**: Link to Swagger UI, example requests
5. **Testing**: How to run tests, coverage reports
6. **AI Usage**: Summary of prompts and generated code
7. **Quality Gates**: Checkstyle, SpotBugs, JaCoCo results

## Validation Checklist

Before committing code, ensure:
- [ ] Follows hexagonal architecture (no Spring in domain)
- [ ] OpenAPI contract-first approach used (interfaces generated)
- [ ] All BIAN naming conventions followed (payment-initiation, PaymentOrder BQ)
- [ ] MapStruct mappers configured correctly (3 layers: REST, Persistence, Application)
- [ ] Unit tests written for domain and application layers (80%+ coverage)
- [ ] Integration tests with WebTestClient for all endpoints
- [ ] Repository tests for JPA layer
- [ ] `./gradlew check` passes (Checkstyle, SpotBugs, JaCoCo)
- [ ] H2 database configured correctly (in-memory or file-based)
- [ ] Dockerfile builds successfully (`docker build -t payment-service .`)
- [ ] docker-compose up works (`docker-compose up -d`)
- [ ] All endpoints return correct HTTP status codes (201, 200, 404, 400, 500)
- [ ] RFC 7807 error handling implemented (application/problem+json)
- [ ] AI usage documented in ai/ folder (prompts.md, decisions.md, generations/)
- [ ] README updated with setup instructions and API documentation
- [ ] Actuator endpoints exposed for health checks
- [ ] Logging configured appropriately (no sensitive data)
- [ ] Value objects are immutable (Lombok @Value)
- [ ] No framework dependencies in domain layer
- [ ] All exceptions properly handled in GlobalExceptionHandler

## Additional Gradle Commands

```bash
# Clean build
./gradlew clean build

# Run with quality checks
./gradlew clean build check

# Run only tests
./gradlew test

# Generate coverage report
./gradlew test jacocoTestReport
# Open: build/reports/jacoco/test/html/index.html

# Run checkstyle only
./gradlew checkstyleMain checkstyleTest

# Run spotbugs only
./gradlew spotbugsMain spotbugsTest

# Build without tests (faster for development)
./gradlew clean build -x test

# Run application locally
./gradlew bootRun

# Generate OpenAPI code
./gradlew openApiGenerate

# View project dependencies
./gradlew dependencies

# View available tasks
./gradlew tasks
```

## Remember
- **BIAN alignment is non-negotiable**: Always validate against BIAN standards
- **Domain purity**: Keep domain layer framework-agnostic
- **Test-first mindset**: Write tests before implementation
- **Document AI usage**: Every AI-generated code must be reviewed and documented
- **Quality over speed**: Meet all quality gates before considering "done"

---

When in doubt, ask yourself: "Does this align with BIAN Payment Initiation Service Domain standards?" and "Is this following hexagonal architecture principles?"