package com.bank.paymentinitiation.domain.model;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Payment Order Aggregate Root.
 * 
 * <p>Represents a payment order in the domain. This is the aggregate root
 * for the payment order aggregate, containing all business logic and rules
 * related to payment orders.
 * 
 * <p>This aggregate enforces business invariants through:
 * <ul>
 *   <li>Immutable value objects (ExternalReference, PayerReference, PayeeReference, PaymentAmount)</li>
 *   <li>Domain methods (validate(), initiate(), changeStatus())</li>
 *   <li>Status transitions validation</li>
 * </ul>
 * 
 * <p>Important: The status and createdAt fields are set when initiate() is called.
 * The validate() method requires these fields to be non-null, so the correct order
 * is: 1) initiate(), 2) validate().
 */
@Getter
@Setter(AccessLevel.PRIVATE)
@Builder(toBuilder = true)
public class PaymentOrder {

    /**
     * Unique identifier for the payment order (generated by the system).
     */
    String paymentOrderReference;

    /**
     * External reference provided by the client.
     */
    ExternalReference externalReference;

    /**
     * Reference to the payer (debtor) account.
     */
    PayerReference payerReference;

    /**
     * Reference to the payee (creditor) account.
     */
    PayeeReference payeeReference;

    /**
     * Payment amount and currency.
     */
    PaymentAmount instructedAmount;

    /**
     * Remittance information (optional).
     */
    String remittanceInformation;

    /**
     * Requested execution date.
     */
    LocalDate requestedExecutionDate;

    /**
     * Current status of the payment order.
     * Set to INITIATED when initiate() is called.
     */
    PaymentStatus status;

    /**
     * Timestamp when the payment order was created.
     * Set to current time when initiate() is called.
     */
    LocalDateTime createdAt;

    /**
     * Timestamp when the payment order was last updated.
     * Updated when status changes or other modifications occur.
     */
    LocalDateTime updatedAt;

    /**
     * Initiates the payment order.
     * 
     * <p>Sets the status to INITIATED and createdAt to the current time.
     * This method must be called before validate() as validate() requires
     * status and createdAt to be non-null.
     */
    public void initiate() {
        this.status = PaymentStatus.INITIATED;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Validates the payment order aggregate.
     * 
     * <p>Validates business invariants:
     * <ul>
     *   <li>All required fields are non-null</li>
     *   <li>Status is set (must be called after initiate())</li>
     *   <li>createdAt is set (must be called after initiate())</li>
     *   <li>requestedExecutionDate is not in the past</li>
     *   <li>Other business rules</li>
     * </ul>
     * 
     * @throws IllegalStateException if validation fails
     */
    public void validate() {
        if (paymentOrderReference == null || paymentOrderReference.trim().isEmpty()) {
            throw new IllegalStateException("Payment order reference must not be null or empty");
        }
        if (externalReference == null) {
            throw new IllegalStateException("External reference must not be null");
        }
        if (payerReference == null) {
            throw new IllegalStateException("Payer reference must not be null");
        }
        if (payeeReference == null) {
            throw new IllegalStateException("Payee reference must not be null");
        }
        if (instructedAmount == null) {
            throw new IllegalStateException("Instructed amount must not be null");
        }
        if (requestedExecutionDate == null) {
            throw new IllegalStateException("Requested execution date must not be null");
        }
        if (status == null) {
            throw new IllegalStateException("Status must not be null (call initiate() first)");
        }
        if (createdAt == null) {
            throw new IllegalStateException("CreatedAt must not be null (call initiate() first)");
        }
        if (requestedExecutionDate.isBefore(LocalDate.now())) {
            throw new IllegalStateException("Requested execution date must not be in the past");
        }
    }

    /**
     * Changes the status of the payment order, validating state transitions.
     * 
     * <p>Valid state transitions:
     * <ul>
     *   <li>INITIATED → PENDING</li>
     *   <li>PENDING → PROCESSED</li>
     *   <li>PROCESSED → COMPLETED</li>
     *   <li>Any state → FAILED</li>
     *   <li>Any state → CANCELLED (except COMPLETED and FAILED)</li>
     * </ul>
     * 
     * <p>Updates the updatedAt timestamp automatically.
     * 
     * @param newStatus the new status to transition to
     * @throws IllegalStateException if the transition is not allowed
     */
    public void changeStatus(final PaymentStatus newStatus) {
        if (newStatus == null) {
            throw new IllegalArgumentException("New status must not be null");
        }
        if (this.status == null) {
            throw new IllegalStateException("Cannot change status: current status is null");
        }

        // Allow transition to FAILED from any state
        if (newStatus == PaymentStatus.FAILED) {
            this.status = newStatus;
            this.updatedAt = LocalDateTime.now();
            return;
        }

        // Allow transition to CANCELLED from any state except COMPLETED and FAILED
        if (newStatus == PaymentStatus.CANCELLED) {
            if (this.status == PaymentStatus.COMPLETED || this.status == PaymentStatus.FAILED) {
                throw new IllegalStateException(
                    String.format("Cannot cancel payment order in status %s", this.status));
            }
            this.status = newStatus;
            this.updatedAt = LocalDateTime.now();
            return;
        }

        // Validate normal flow transitions
        switch (this.status) {
            case INITIATED:
                if (newStatus != PaymentStatus.PENDING) {
                    throw new IllegalStateException(
                        String.format("Cannot transition from %s to %s. Expected: PENDING", 
                            this.status, newStatus));
                }
                break;
            case PENDING:
                if (newStatus != PaymentStatus.PROCESSED) {
                    throw new IllegalStateException(
                        String.format("Cannot transition from %s to %s. Expected: PROCESSED", 
                            this.status, newStatus));
                }
                break;
            case PROCESSED:
                if (newStatus != PaymentStatus.COMPLETED) {
                    throw new IllegalStateException(
                        String.format("Cannot transition from %s to %s. Expected: COMPLETED", 
                            this.status, newStatus));
                }
                break;
            case COMPLETED:
            case FAILED:
            case CANCELLED:
                throw new IllegalStateException(
                    String.format("Cannot transition from terminal state %s", this.status));
            default:
                throw new IllegalStateException(
                    String.format("Unknown status: %s", this.status));
        }

        this.status = newStatus;
        this.updatedAt = LocalDateTime.now();
    }
}

