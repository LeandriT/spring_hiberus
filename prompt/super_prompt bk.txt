

===== /mnt/data/prompt_v1.txt =====
BIAN PAYMENT INITIATION ‚Äì CURSOR PRO PLAYBOOK (JAVA 21)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

NOTA IMPORTANTE: Este playbook ha sido refinado y ajustado bas√°ndose en la implementaci√≥n 
exitosa del challenge. Incluye todas las correcciones y mejoras identificadas durante el 
desarrollo, incluyendo soluciones a problemas comunes con SpotBugs, MapStruct, Checkstyle, 
JaCoCo y configuraci√≥n de Docker.

Versi√≥n: 1.1 (Refinada post-implementaci√≥n)
√öltima actualizaci√≥n: Noviembre 2024

======================================================
SECCI√ìN A ‚Äì PASOS PARA IMPLEMENTAR EL CHALLENGE CON CURSOR
======================================================

Contexto r√°pido
---------------
- Dominio BIAN: Payment Initiation
- BQ principal: PaymentOrder
- Migraci√≥n: SOAP ‚Üí REST (BIAN-aligned)
- Arquitectura: Hexagonal (Ports & Adapters)
- Enfoque: Contract-First con OpenAPI 3.0
- Stack:
  - Java 21
  - Spring Boot 3 (Spring MVC, NO WebFlux en runtime)
  - H2 como base de datos
  - Gradle (Groovy DSL)
  - MapStruct para mapeos
  - WebTestClient para tests de integraci√≥n
- Artefactos de soporte:
  - WSDL legacy: PaymentOrderService.wsdl
  - XML ejemplos: SubmitPaymentOrder / GetPaymentOrderStatus (request/response)
  - Colecci√≥n Postman: postman_collection.json (endpoints REST a validar)

Los siguientes pasos est√°n pensados para copiarlos en Cursor Pro por bloques y dejar que genere el c√≥digo, mientras t√∫
revisas, corriges y documentas el uso de IA en la carpeta ai/.

‚ö†Ô∏è INSTRUCCIONES DE USO:
1. Copia cada PASO individualmente en Cursor Pro.
2. Revisa el c√≥digo generado antes de continuar al siguiente paso.
3. Ejecuta tests despu√©s de cada paso cr√≠tico (PASO 4, PASO 9, PASO 10, etc.).
4. Documenta cualquier correcci√≥n manual en ai/decisions.md.
5. Los pasos marcados con ‚ö†Ô∏è IMPORTANTE contienen correcciones cr√≠ticas que deben aplicarse.


PASO 0 ‚Äì Crear proyecto base (Java 21 + Gradle + Spring MVC + H2)
-----------------------------------------------------------------
Prompt para Cursor:

Crea un proyecto Spring Boot 3 con Java 21 usando Gradle (Groovy DSL).
Act√∫a como un generador de proyectos y crea lo siguiente:

- Nombre del proyecto (crear carpeta): payment-initiation-service
- Group: com.bank.paymentinitiation
- Paquete base: com.bank.paymentinitiation

En build.gradle configura:

- Plugins:
  - id 'java'
  - id 'org.springframework.boot' version '3.2.0'
  - id 'io.spring.dependency-management' version '1.1.4'
  - id 'org.openapi.generator' version '7.0.1'
  - id 'checkstyle'
  - id 'com.github.spotbugs' version '6.0.0'
  - id 'jacoco'

- Java 21:
  - sourceCompatibility = JavaVersion.VERSION_21
  - targetCompatibility = JavaVersion.VERSION_21

- Dependencias principales:
  - implementation 'org.springframework.boot:spring-boot-starter-web'           // Spring MVC
  - implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
  - implementation 'org.springframework.boot:spring-boot-starter-validation'
  - implementation 'org.springframework.boot:spring-boot-starter-actuator'
  - runtimeOnly  'com.h2database:h2'
  - MapStruct:
    - implementation "org.mapstruct:mapstruct:1.5.5.Final"
    - annotationProcessor "org.mapstruct:mapstruct-processor:1.5.5.Final"
  - Lombok:
    - compileOnly "org.projectlombok:lombok:1.18.30"
    - annotationProcessor "org.projectlombok:lombok:1.18.30"
    - annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"
  - Tests:
    - testImplementation 'org.springframework.boot:spring-boot-starter-test'
    - testImplementation 'org.springframework:spring-webflux'   // solo para WebTestClient

Configura:
- test { useJUnitPlatform() }
- jacoco b√°sico (toolVersion, reporte html/xml m√≠nimo).

--------------------------------------------------
Checkstyle (CONFIGURACI√ìN OBLIGATORIA)
--------------------------------------------------
- Usa encoding expl√≠cito UTF-8 en la configuraci√≥n de Checkstyle.
- Aplica una configuraci√≥n ‚Äúmedia‚Äù adecuada para proyectos BIAN:
    ‚Ä¢ Reglas de naming
    ‚Ä¢ Reglas de imports
    ‚Ä¢ Whitespace y llaves
    ‚Ä¢ Longitud de l√≠nea razonable (ej. 120)
    ‚Ä¢ Complejidad razonable
    ‚Ä¢ Buenas pr√°cticas b√°sicas
  (NO uses reglas extremas ni demasiado restrictivas que frenen el desarrollo).

- Debes crear y usar estos archivos obligatorios:
    ‚Ä¢ config/checkstyle/checkstyle.xml
    ‚Ä¢ config/checkstyle/suppressions.xml

- En build.gradle debes referenciarlos as√≠:
    ‚Ä¢ configFile = file("$rootDir/config/checkstyle/checkstyle.xml")
    ‚Ä¢ configProperties = ['checkstyle.suppressions.file': "$rootDir/config/checkstyle/suppressions.xml"]

- ANTES de ejecutar el build completo, ejecuta:
    ./gradlew checkstyleMain --no-daemon

  IMPORTANTE (manejo de errores):
  ‚Ä¢ NO uses tail, grep ni recortes de salida (NO uses ‚Äú| tail -3‚Äù ni ‚Äú| tail -10‚Äù).
  ‚Ä¢ Muestra el log completo del comando o, como m√≠nimo, suficiente contexto (varias decenas de l√≠neas) para entender bien el error.
  ‚Ä¢ Si aparece un error en Checkstyle:
      ‚Üí Lee exactamente el mensaje del log (incluyendo ‚ÄúCaused by:‚Äù, m√≥dulo afectado, archivo y l√≠nea).
      ‚Üí Identifica la causa real (ruta incorrecta, error DTD, m√≥dulo mal definido, regla inv√°lida, propiedad inexistente, etc.).
      ‚Üí Corrige la configuraci√≥n modificando SOLO los archivos:
            - build.gradle
            - config/checkstyle/checkstyle.xml
            - config/checkstyle/suppressions.xml
      ‚Üí Vuelve a ejecutar:
            ./gradlew checkstyleMain --no-daemon
        hasta que pase sin errores.
  ‚Ä¢ Nunca elimines el plugin de Checkstyle ni ignores los errores: siempre corrige la configuraci√≥n seg√∫n el log.

--------------------------------------------------
‚ö†Ô∏è IMPORTANTE - SpotBugs
--------------------------------------------------
- SpotBugs: NO configures `effort` y `reportLevel` en el bloque `spotbugs {}` directamente como strings.
  Estos deben configurarse en las tareas individuales usando:
    - com.github.spotbugs.snom.Effort.valueOf('MAX')
    - com.github.spotbugs.snom.Confidence.valueOf('HIGH')
- La configuraci√≥n detallada de SpotBugs est√° en el PASO 14 del archivo super_prompt.txt, pero en este paso solo deja el plugin declarado sin romper el build.

Al final de este paso, el proyecto debe:
- Compilar correctamente.
- Tener Checkstyle configurado y ejecut√°ndose sin errores con `./gradlew checkstyleMain --no-daemon`.

Aseg√∫rate de que ./gradlew clean build compila correctamente.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y lo que gener√≥ la IA
- ai/decisions.md: Documenta cualquier correcci√≥n manual aplicada (ej: configuraci√≥n de SpotBugs)


PASO 1 ‚Äì Carpeta de evidencias de IA
------------------------------------
Crea en la ra√≠z del proyecto (junto a build.gradle):

- ai/prompts.md      ‚Üí lista de prompts usados (incluye los que uses con Cursor).
- ai/decisions.md    ‚Üí decisiones de dise√±o, correcciones manuales, trade-offs.
- ai/generations/    ‚Üí fragmentos relevantes generados por IA (por ejemplo openapi.yaml, controladores, etc.).

Inicializa los .md con t√≠tulos y una peque√±a descripci√≥n de c√≥mo se documentar√° el uso de IA.


PASO 2 ‚Äì Analizar el WSDL y los XML legacy
------------------------------------------
Usa PaymentOrderService.wsdl, SubmitPaymentOrder*.xml y GetPaymentOrderStatus*.xml como entrada.

Prompt sugerido para Cursor:

Analiza el archivo PaymentOrderService.wsdl y los XML de ejemplo (SubmitPaymentOrderRequest/Response, GetPaymentOrderStatusRequest/Response) y dame:

1) Operaciones SOAP disponibles relacionadas con √≥rdenes de pago.
2) Estructuras de datos principales (campos clave) de la orden de pago.
3) Estados posibles de la orden de pago en el servicio legacy.
4) Un mapeo de estos conceptos al Service Domain BIAN Payment Initiation y al BQ PaymentOrder.


Resume y copia el resultado en ai/decisions.md.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el an√°lisis generado
- ai/decisions.md: Guarda el resultado completo del an√°lisis del WSDL y mapeo a BIAN
- ai/generations/: Opcionalmente guarda el WSDL analizado si es relevante


PASO 3 ‚Äì Dise√±ar el contrato OpenAPI 3.0 (contract-first, alineado con Postman)
-------------------------------------------------------------------------------
Prompt para Cursor:

Bas√°ndote en el an√°lisis del WSDL y la colecci√≥n postman_collection.json (endpoints):

- POST http://localhost:8080/payment-initiation/payment-orders
- GET  http://localhost:8080/payment-initiation/payment-orders/{id}
- GET  http://localhost:8080/payment-initiation/payment-orders/{id}/status

Genera un archivo openapi/openapi.yaml con OpenAPI 3.0 que defina:

- servers:
  - url: http://localhost:8080
- paths:
  - POST /payment-initiation/payment-orders
    - operationId: initiatePaymentOrder
    - requestBody con esquema InitiatePaymentOrderRequest con campos alineados a la colecci√≥n Postman:
      - externalReference
      - debtorAccount { iban }
      - creditorAccount { iban }
      - instructedAmount { amount, currency }
      - remittanceInformation
      - requestedExecutionDate (date)
    - responses:
      - 201: InitiatePaymentOrderResponse
      - 400, 500 en formato application/problem+json
  - GET /payment-initiation/payment-orders/{id}
    - operationId: retrievePaymentOrder
    - 200: RetrievePaymentOrderResponse
    - 404: ProblemDetail
  - GET /payment-initiation/payment-orders/{id}/status
    - operationId: retrievePaymentOrderStatus
    - 200: PaymentOrderStatusResponse
    - 404: ProblemDetail

Define schemas:

- InitiatePaymentOrderRequest
- InitiatePaymentOrderResponse
- RetrievePaymentOrderResponse
- PaymentOrderStatusResponse
- PaymentAmount (value/currency)
- ProblemDetail (RFC 7807)

Implementa el contenido completo de openapi/openapi.yaml.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el contrato OpenAPI generado
- ai/decisions.md: Documenta decisiones de dise√±o del contrato (endpoints, schemas, validaciones)
- ai/generations/: Guarda una copia del openapi.yaml inicial generado por IA con comentarios sobre qu√© se mantuvo y qu√© se modific√≥


PASO 4 ‚Äì Configurar OpenAPI Generator en Gradle
-----------------------------------------------
Prompt:

En build.gradle, configura la tarea openApiGenerate:

- generatorName = 'spring'
- inputSpec   = "$rootDir/openapi/openapi.yaml"
- outputDir   = "$buildDir/generated"
- apiPackage  = 'com.bank.paymentinitiation.generated.api'
- modelPackage = 'com.bank.paymentinitiation.generated.model'
- invokerPackage = 'com.bank.paymentinitiation.generated.invoker'
- configOptions:
  - interfaceOnly = 'true'
  - useSpringBoot3 = 'true'
  - useTags = 'true'
  - dateLibrary = 'java8'
  - serializationLibrary = 'jackson'
  - hideGenerationTimestamp = 'true'

A√±ade la carpeta generada como source set:

- sourceSets.main.java.srcDir("$buildDir/generated/src/main/java")

Y haz que compileJava dependa de openApiGenerate.

‚ö†Ô∏è IMPORTANTE - Dependencias necesarias para c√≥digo generado:
Agrega estas dependencias adicionales que requiere el c√≥digo generado por OpenAPI:

- implementation "io.swagger.core.v3:swagger-annotations:2.2.21"
- implementation "org.openapitools:jackson-databind-nullable:0.2.6"
- implementation "jakarta.validation:jakarta.validation-api:3.0.2"
- implementation "jakarta.annotation:jakarta.annotation-api:2.1.1"

Comprueba que ./gradlew openApiGenerate && ./gradlew compileJava funciona sin errores.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la configuraci√≥n de OpenAPI Generator generada
- ai/decisions.md: Documenta las dependencias adicionales agregadas y por qu√© fueron necesarias


PASO 5 ‚Äì Estructura de paquetes (Hexagonal)
-------------------------------------------
Prompt:

Crea la siguiente estructura de paquetes bajo com.bank.paymentinitiation:

- domain
  - model
  - port.in
  - port.out
  - exception
  - service
- application
  - service
  - mapper (opcional)
- adapter.in.rest
  - dto (los modelos generados van en generated.model, aqu√≠ solo wrappers si los necesitas)
  - mapper
- adapter.out.persistence
  - entity
  - jpa
  - mapper
  - PaymentOrderRepositoryAdapter
- config

Crea clases vac√≠as (o interfaces) con javadoc describiendo su rol, sin meter a√∫n mucha l√≥gica.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la estructura de paquetes generada
- ai/decisions.md: Documenta la decisi√≥n de usar arquitectura hexagonal y la organizaci√≥n de paquetes


PASO 6 ‚Äì Modelo de dominio BIAN (PaymentOrder)
----------------------------------------------
Prompt:

En com.bank.paymentinitiation.domain.model crea:

- Enum PaymentStatus con valores: INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED.
- Value object PaymentAmount (BigDecimal value, String currency) con factor√≠a est√°tica que valide que value > 0.
- Value objects PayerReference, PayeeReference, ExternalReference (strings no vac√≠os).
- Aggregate root PaymentOrder con campos:
  - String paymentOrderReference
  - ExternalReference externalReference
  - PayerReference payerReference
  - PayeeReference payeeReference
  - PaymentAmount instructedAmount
  - String remittanceInformation
  - LocalDate requestedExecutionDate
  - PaymentStatus status
  - LocalDateTime createdAt
  - LocalDateTime updatedAt

Incluye m√©todos de dominio para:
- validar el agregado (validate())
- iniciar la orden (marcar INITIATED)
- cambiar estado respetando una secuencia razonable (por ejemplo INITIATED ‚Üí PENDING ‚Üí PROCESSED ‚Üí COMPLETED).

No uses anotaciones de Spring en el dominio. Usa Lombok (@Value/@Builder) cuando tenga sentido.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el modelo de dominio generado
- ai/decisions.md: Documenta decisiones sobre value objects, estados del enum PaymentStatus, y m√©todos de dominio
- ai/generations/: Opcionalmente guarda clases del dominio generadas inicialmente si hubo cambios significativos


PASO 7 ‚Äì Puertos de dominio (ports in/out) y servicios de aplicaci√≥n
--------------------------------------------------------------------
Prompt:

En domain.port.in crea interfaces:

- InitiatePaymentOrderUseCase
  - PaymentOrder initiate(PaymentOrder order);
- RetrievePaymentOrderUseCase
  - PaymentOrder retrieve(String paymentOrderReference);
- RetrievePaymentOrderStatusUseCase
  - PaymentStatus retrieveStatus(String paymentOrderReference);

En domain.port.out crea:

- PaymentOrderRepository
  - PaymentOrder save(PaymentOrder order);
  - Optional<PaymentOrder> findByReference(String paymentOrderReference);

En application.service crea implementaciones de estos casos de uso que:
- Inyectan PaymentOrderRepository (port out).
- Aplican reglas de negocio b√°sicas y delegan en el repositorio.
- Lanzan excepciones de dominio (PaymentOrderNotFoundException, InvalidPaymentException) cuando aplique.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y los puertos/servicios generados
- ai/decisions.md: Documenta decisiones sobre la separaci√≥n de puertos in/out y la implementaci√≥n de servicios de aplicaci√≥n


PASO 8 ‚Äì H2 + JPA (entidad y repositorio)
-----------------------------------------
Prompt:

Configura application.yml para H2 en memoria:

spring:
  datasource:
    url: jdbc:h2:mem:paymentdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
      path: /h2-console
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: false
    properties:
      hibernate:
        format_sql: true

management:
  endpoints:
    web:
      exposure:
        include: health,info
      base-path: /actuator
  endpoint:
    health:
      show-details: when_authorized

En adapter.out.persistence.entity crea PaymentOrderEntity con campos equivalentes al dominio, usando @Entity y @Table. Usa UUID como id t√©cnico y paymentOrderReference como identificador de negocio √∫nico.

En adapter.out.persistence.jpa crea PaymentOrderJpaRepository extends JpaRepository<PaymentOrderEntity, UUID> con m√©todo:
- Optional<PaymentOrderEntity> findByPaymentOrderReference(String paymentOrderReference);

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la configuraci√≥n de H2/JPA generada
- ai/decisions.md: Documenta decisiones sobre la estructura de la entidad JPA, uso de UUID vs paymentOrderReference, y configuraci√≥n de H2


PASO 9 ‚Äì MapStruct para mapeos (REST ‚Üî Dominio ‚Üî Entidad)
----------------------------------------------------------
Prompt:

Configura MapStruct usando:

- implementation "org.mapstruct:mapstruct:1.5.5.Final"
- annotationProcessor "org.mapstruct:mapstruct-processor:1.5.5.Final"

Crea en adapter.in.rest.mapper:

- PaymentOrderRestMapper con m√©todos:
  - PaymentOrder toDomain(InitiatePaymentOrderRequest request);
  - InitiatePaymentOrderResponse toInitiateResponse(PaymentOrder domain);
  - RetrievePaymentOrderResponse toRetrieveResponse(PaymentOrder domain);
  - PaymentOrderStatusResponse toStatusResponse(PaymentOrder domain);

Crea en adapter.out.persistence.mapper:

- PaymentOrderPersistenceMapper con m√©todos:
  - PaymentOrderEntity toEntity(PaymentOrder domain);
  - PaymentOrder toDomain(PaymentOrderEntity entity);

Usa @Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR).

‚ö†Ô∏è IMPORTANTE - Evitar ambig√ºedades de tipos:
- En los mappers MapStruct, usa nombres completamente calificados (fully qualified names) para tipos 
  que tienen el mismo nombre en diferentes paquetes (ej: PaymentAmount, PaymentStatus en dominio vs generated.model).
- Ejemplo: usa `com.bank.paymentinitiation.domain.model.PaymentAmount` en lugar de solo `PaymentAmount` 
  cuando hay ambig√ºedad entre dominio y DTOs generados.
- Para m√©todos `toDomain(InitiatePaymentOrderRequest request, String paymentOrderReference)`, 
  el mapper debe recibir el `paymentOrderReference` como par√°metro adicional porque se genera 
  en el controlador, no en el mapper.

‚ö†Ô∏è Conversi√≥n de timestamps:
- Agrega m√©todos @Named para convertir LocalDateTime ‚Üí OffsetDateTime en mappers REST, 
  ya que los DTOs de OpenAPI usan OffsetDateTime pero el dominio usa LocalDateTime.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y los mappers MapStruct generados
- ai/decisions.md: Documenta las correcciones manuales aplicadas (ambig√ºedades de tipos, conversiones de timestamps, m√©todos custom)
- ai/generations/: Opcionalmente guarda mappers generados inicialmente si hubo cambios significativos


PASO 10 ‚Äì Adaptador REST (implementando interfaces generadas)
-------------------------------------------------------------
Prompt:

Usando las interfaces generadas en com.bank.paymentinitiation.generated.api, crea PaymentOrdersController en adapter.in.rest que:

- Implemente PaymentOrdersApi (el nombre generado por OpenAPI).
- Inyecte los use cases, PaymentOrderRestMapper y PaymentOrderReferenceGenerator.
- Para POST /payment-initiation/payment-orders:
  - Reciba InitiatePaymentOrderRequest con @Valid.
  - Genere paymentOrderReference usando PaymentOrderReferenceGenerator.
  - Mapee DTO ‚Üí dominio usando `mapper.toDomain(request, paymentOrderReference)`.
  - Llame InitiatePaymentOrderUseCase, mapee dominio ‚Üí InitiatePaymentOrderResponse.
  - Devuelva ResponseEntity.status(HttpStatus.CREATED).body(response).
- Para GET /payment-initiation/payment-orders/{id}:
  - Llame RetrievePaymentOrderUseCase, mapee dominio ‚Üí RetrievePaymentOrderResponse.
  - Devuelva ResponseEntity.ok(response).
- Para GET /payment-initiation/payment-orders/{id}/status:
  - Llame RetrievePaymentOrderUseCase (necesita orden completa para mapear a response con paymentOrderReference y lastUpdated).
  - Mapee dominio ‚Üí PaymentOrderStatusResponse usando mapper.toStatusResponse().
  - Devuelva ResponseEntity.ok(response).
  - ‚ö†Ô∏è NOTA: Aunque existe RetrievePaymentOrderStatusUseCase que retorna solo PaymentStatus, 
    el controlador usa RetrievePaymentOrderUseCase porque necesita la orden completa para 
    incluir paymentOrderReference y lastUpdated en la respuesta.

‚ö†Ô∏è IMPORTANTE - Servicios necesarios:
1. Crea PaymentOrderReferenceGenerator en application.service:
   - Componente Spring que genera referencias √∫nicas en formato "PO-{UUID compacto}".
   - Usa UUID.randomUUID() y formatea como "PO-XXXXXXXX" (ejemplo: "PO-A1B2C3D4E5F6G7H8").

2. Crea ApplicationConfig en config/:
   - Clase de configuraci√≥n Spring con @Configuration.
   - Define beans para InitiatePaymentOrderService, RetrievePaymentOrderService, RetrievePaymentOrderStatusService.
   - Estos servicios reciben PaymentOrderRepository (que ser√° inyectado autom√°ticamente por Spring).

3. Completa PaymentOrderRepositoryAdapter:
   - Debe tener @Component para ser detectado por Spring.
   - Implementa los m√©todos save() y findByReference() usando PaymentOrderJpaRepository y PaymentOrderPersistenceMapper.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el controlador REST generado
- ai/decisions.md: Documenta decisiones sobre PaymentOrderReferenceGenerator, ApplicationConfig, y la implementaci√≥n del controlador
- ai/generations/: Opcionalmente guarda el controlador generado inicialmente si hubo cambios significativos


PASO 11 ‚Äì Manejo global de errores (RFC 7807)
---------------------------------------------
Prompt:

Crea en adapter.in.rest un @RestControllerAdvice GlobalExceptionHandler que maneje:

- PaymentOrderNotFoundException ‚Üí 404 NOT FOUND, body ProblemDetail con title "Payment Order Not Found".
- InvalidPaymentException ‚Üí 400 BAD REQUEST, body ProblemDetail con title "Invalid Payment Order".
- Exception gen√©rica ‚Üí 500 INTERNAL SERVER ERROR.

Usa org.springframework.http.ProblemDetail (Spring 6+). Todos los errores deben tener content-type application/problem+json.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el GlobalExceptionHandler generado
- ai/decisions.md: Documenta decisiones sobre el manejo de errores RFC 7807 y el mapeo de excepciones de dominio a HTTP


PASO 12 ‚Äì Tests unitarios (dominio, casos de uso, mappers)
----------------------------------------------------------
Prompt:
Crea tests unitarios siguiendo buenas pr√°cticas de testing para el microservicio Payment Initiation.

‚ö†Ô∏è MUY IMPORTANTE ‚Äì REGLA OBLIGATORIA PARA LEER LOGS
Cuando ejecutes comandos como:

    ./gradlew test --no-daemon
    ./gradlew build --no-daemon
    ./gradlew checkstyleMain --no-daemon
    ./gradlew check --no-daemon

NO uses grep, tail ni ning√∫n filtro como:

    | grep "FAILED"
    | grep -A 10
    | tail -3
    | tail -10

Estos comandos OCULTAN el log real y te impiden corregir los errores correctamente.

En su lugar:

1. Muestra el log COMPLETO del error.
2. Si el log es muy largo, NO lo recortes. En vez de eso, mu√©stralo completo y luego provee un RESUMEN manual con:
   ‚Ä¢ La excepci√≥n principal (tipo y mensaje)
   ‚Ä¢ ‚ÄúCaused by‚Äù
   ‚Ä¢ El archivo involucrado
   ‚Ä¢ La l√≠nea espec√≠fica
   ‚Ä¢ El m√≥dulo afectado (JUnit, Checkstyle, SpotBugs, Jacoco)
3. Usa esa informaci√≥n para:
   ‚Ä¢ Identificar el error real
   ‚Ä¢ Explicar la causa ra√≠z
   ‚Ä¢ Proponer y aplicar la correcci√≥n adecuada
   ‚Ä¢ Ejecutar el comando nuevamente hasta que pase sin errores

Nunca adivines soluciones sin ver el log completo. La depuraci√≥n SIEMPRE debe ser basada en el error exacto que muestra Gradle.


-------------------------------------------------------------------
1) TESTS DEL AGREGADO PaymentOrder (domain.model.PaymentOrderTest)
-------------------------------------------------------------------

Cubre al menos estos escenarios:

- Validaciones de creaci√≥n:
  - Creaci√≥n exitosa con campos v√°lidos.
  - Falla si:
    ‚Ä¢ paymentOrderReference es null/blank
    ‚Ä¢ externalReference es null
    ‚Ä¢ payerReference es null
    ‚Ä¢ payeeReference es null
    ‚Ä¢ instructedAmount es null o amount <= 0
    ‚Ä¢ requestedExecutionDate es null
    ‚Ä¢ createdAt null cuando es requerido
    ‚Ä¢ status null cuando sea requerido

- Reglas de negocio / transiciones de estado:
  ‚Ä¢ INITIATED ‚Üí PENDING / CANCELLED
  ‚Ä¢ PENDING ‚Üí PROCESSED / FAILED / CANCELLED
  ‚Ä¢ PROCESSED ‚Üí COMPLETED / FAILED
  ‚Ä¢ Transiciones inv√°lidas deben lanzar IllegalStateException
  ‚Ä¢ Estados finales (COMPLETED, FAILED, CANCELLED) no permiten m√°s cambios
  ‚Ä¢ updatedAt debe cambiar en cada transici√≥n v√°lida

- Buenas pr√°cticas:
  ‚Ä¢ Usa AAA (Arrange ‚Äì Act ‚Äì Assert)
  ‚Ä¢ Usa AssertJ: assertThat(), assertThatThrownBy(), etc.
  ‚Ä¢ Usa @DisplayName con descripciones claras
  ‚Ä¢ Usa builders/helpers para evitar repetir datos


-------------------------------------------------------------------
2) TESTS DE SERVICIOS DE APLICACI√ìN
-------------------------------------------------------------------

Clases sugeridas:
- InitiatePaymentOrderServiceTest
- RetrievePaymentOrderServiceTest
- RetrievePaymentOrderStatusServiceTest

Configuraci√≥n:
- @ExtendWith(MockitoExtension.class)
- @Mock PaymentOrderRepository
- @InjectMocks servicio bajo test

Casos m√≠nimos:

a) InitiatePaymentOrderServiceTest
- shouldInitiatePaymentOrderSuccessfully()
- shouldThrowExceptionWhenValidationFails()
- shouldUseExistingPaymentOrderReference()
- shouldNotSaveWhenOrderInvalid()

b) RetrievePaymentOrderServiceTest
- shouldRetrievePaymentOrderSuccessfully()
- shouldThrowWhenOrderNotFound()
- shouldThrowWhenReferenceIsNullOrBlank()

c) RetrievePaymentOrderStatusServiceTest
- Igual que retrieve, pero enfocado solo en status / lastUpdated.


-------------------------------------------------------------------
3) TESTS DE MAPPERS MAPSTRUCT (RECOMENDADO)
-------------------------------------------------------------------

Si existen mappers como PaymentOrderRestMapper o PaymentOrderPersistenceMapper, crear tests:

- shouldMapRequestToDomain()
- shouldMapDomainToInitiateResponse()
- shouldMapDomainToRetrieveResponse()
- shouldMapDomainToStatusResponse()

- shouldMapDomainToEntity()
- shouldMapEntityToDomain()
- shouldMapAllStatuses()


-------------------------------------------------------------------
4) CONVENCIONES DE TESTS
-------------------------------------------------------------------

‚Ä¢ Nombres estilo:
  should[Behavior]When[Condition]()
  shouldReturnXWhenY()

‚Ä¢ Usar @DisplayName con lenguaje natural

‚Ä¢ AssertJ obligatorio:
  assertThat()
  assertThatThrownBy()
  assertThat(list).hasSize()

‚Ä¢ Mockito:
  verify(repository).save(...)
  verify(repository, never()).save(...)
  when(findBy...).thenReturn(...)
  doThrow(...).when(...)


-------------------------------------------------------------------
5) COBERTURA ESPERADA
-------------------------------------------------------------------

- Dominio (Aggregate, Value Objects): 85‚Äì95%
- Servicios de Aplicaci√≥n: 90‚Äì100%
- Mappers: cubrir campos clave (IDs, referencias, monto, status)


-------------------------------------------------------------------
DOCUMENTACI√ìN IA
-------------------------------------------------------------------

Despu√©s de completar este paso, documenta:

- ai/prompts.md: registra este prompt y describe los tests creados.
- ai/decisions.md: documenta decisiones sobre estrategia de testing, cobertura objetivo y casos cr√≠ticos.

PASO 13 ‚Äì Tests de integraci√≥n del microservicio Payment Initiation

Configura y crea tests de integraci√≥n usando Spring Boot Test + WebTestClient, asegurando que los endpoints REST funcionen de extremo a extremo con H2 real, el contrato OpenAPI y la colecci√≥n Postman.

‚ö†Ô∏è MUY IMPORTANTE ‚Äì REGLA OBLIGATORIA PARA LEER LOGS (NO GREP / NO TAIL)
Al ejecutar comandos como:

    ./gradlew test --no-daemon
    ./gradlew build --no-daemon
    ./gradlew check --no-daemon

NO uses grep, tail ni filtros como:
    | grep "FAILED"
    | grep -A 10
    | tail -3
    | tail -10

Estos comandos OCULTAN informaci√≥n cr√≠tica del log, impiden encontrar fallos reales y hacen que no puedas corregir nada.

En su lugar:
1. Muestra SIEMPRE el log COMPLETO del error sin filtrar.
2. Si es muy largo, mu√©stralo completo y despu√©s haz un resumen con:
   ‚Ä¢ Excepci√≥n principal
   ‚Ä¢ "Caused by"
   ‚Ä¢ Archivo y l√≠nea afectados
   ‚Ä¢ Componente que fall√≥ (JUnit, Jackson, Checkstyle, WebTestClient, etc.)
3. Con esa informaci√≥n:
   ‚Ä¢ Identifica la causa real
   ‚Ä¢ Explica por qu√© ocurri√≥
   ‚Ä¢ Corrige √∫nicamente los archivos necesarios
   ‚Ä¢ Re-ejecuta `./gradlew test` hasta que pase sin errores

Nunca adivines soluciones sin ver el log completo.


---------------------------------------------------------------
CONFIGURACI√ìN GENERAL DEL TEST DE INTEGRACI√ìN
---------------------------------------------------------------

Crea la clase:

    src/test/java/.../adapter/in/rest/PaymentInitiationIntegrationTest

con el siguiente contenido base:

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class PaymentInitiationIntegrationTest {

    @Autowired
    private WebTestClient webTestClient;

    @Autowired
    private PaymentOrderJpaRepository repository;

    @BeforeEach
    void setUp() {
        repository.deleteAll(); // limpiar estado entre tests
    }
}
Requisitos:
	‚Ä¢	Usar H2 real (configuraci√≥n de application.yml).
	‚Ä¢	No usar mocks en tests de integraci√≥n.
	‚Ä¢	Validar la aplicaci√≥n completa: controladores, mappers, servicios, repositorio, JPA, H2, validaciones y serializaci√≥n JSON.
TESTS A IMPLEMENTAR

1) POST /payment-initiation/payment-orders ‚Äì Creaci√≥n EXITOSA

Enviar JSON basado en Postman:

{
‚ÄúexternalReference‚Äù: ‚ÄúEXT-1‚Äù,
‚ÄúdebtorAccount‚Äù: { ‚Äúiban‚Äù: ‚ÄúEC12DEBTOR‚Äù },
‚ÄúcreditorAccount‚Äù: { ‚Äúiban‚Äù: ‚ÄúEC98CREDITOR‚Äù },
‚ÄúinstructedAmount‚Äù: { ‚Äúamount‚Äù: 150.75, ‚Äúcurrency‚Äù: ‚ÄúUSD‚Äù },
‚ÄúremittanceInformation‚Äù: ‚ÄúFactura 001-123‚Äù,
‚ÄúrequestedExecutionDate‚Äù: ‚Äú2025-10-31‚Äù
}

Verificaciones:
	‚Ä¢	.expectStatus().isCreated()
	‚Ä¢	jsonPath(‚Äù$.paymentOrderReference‚Äù).exists()
	‚Ä¢	jsonPath(‚Äù$.paymentOrderStatus‚Äù).isEqualTo(‚ÄúINITIATED‚Äù)
	‚Ä¢	jsonPath(‚Äù$.debtorAccount.iban‚Äù).isEqualTo(‚ÄúEC12DEBTOR‚Äù)
	‚Ä¢	jsonPath(‚Äù$.creditorAccount.iban‚Äù).isEqualTo(‚ÄúEC98CREDITOR‚Äù)
	‚Ä¢	jsonPath(‚Äù$.instructedAmount.amount‚Äù).isEqualTo(150.75)
	‚Ä¢	jsonPath(‚Äù$.instructedAmount.currency‚Äù).isEqualTo(‚ÄúUSD‚Äù)
	‚Ä¢	jsonPath(‚Äù$.createdAt‚Äù).exists()

2) GET /payment-initiation/payment-orders/{id} ‚Äì Recuperaci√≥n COMPLETA

Flujo:
	1.	Crear una orden via POST (capturar paymentOrderReference)
	2.	Usar ese ID en el GET

Verificaciones:
	‚Ä¢	.expectStatus().isOk()
	‚Ä¢	jsonPath(‚Äù$.paymentOrderReference‚Äù) == ID creado
	‚Ä¢	jsonPath(‚Äù$.externalReference‚Äù) correcto
	‚Ä¢	jsonPath(‚Äù$.debtorAccount.iban‚Äù).isEqualTo(‚ÄúEC12DEBTOR‚Äù)
	‚Ä¢	jsonPath(‚Äù$.creditorAccount.iban‚Äù).isEqualTo(‚ÄúEC98CREDITOR‚Äù)
	‚Ä¢	jsonPath(‚Äù$.instructedAmount.amount‚Äù).isEqualTo(150.75)
	‚Ä¢	jsonPath(‚Äù$.requestedExecutionDate‚Äù) existe
	‚Ä¢	jsonPath(‚Äù$.createdAt‚Äù).exists()
	‚Ä¢	jsonPath(‚Äù$.lastUpdated‚Äù).exists()

3) GET /payment-initiation/payment-orders/{id}/status ‚Äì Solo estado

Verificaciones:
	‚Ä¢	.expectStatus().isOk()
	‚Ä¢	jsonPath(‚Äù$.paymentOrderReference‚Äù) correcto
	‚Ä¢	jsonPath(‚Äù$.paymentOrderStatus‚Äù) correcto
	‚Ä¢	jsonPath(‚Äù$.lastUpdated‚Äù).exists()

4) Casos de ERROR (404, 400)

a) GET con ID inexistente ‚Üí 404
	‚Ä¢	.expectStatus().isNotFound()
	‚Ä¢	Validar ProblemDetail RFC 7807:
‚Ä¢ status = 404
‚Ä¢ title = ‚ÄúPayment Order Not Found‚Äù
‚Ä¢ detail contiene el ID

b) POST con body inv√°lido ‚Üí 400
Ejemplos:
	‚Ä¢	Falta debtorAccount
	‚Ä¢	Falta instructedAmount
	‚Ä¢	amount <= 0
	‚Ä¢	currency inv√°lida
	‚Ä¢	fecha incorrecta

Verificaciones:
	‚Ä¢	.expectStatus().isBadRequest()
	‚Ä¢	ProblemDetail:
‚Ä¢ status = 400
‚Ä¢ title = ‚ÄúBad Request‚Äù
‚Ä¢ detail describe el error

‚∏ª

MEJORES PR√ÅCTICAS OBLIGATORIAS CON WEBTESTCLIENT
	‚Ä¢	Usar AAA (Arrange ‚Äì Act ‚Äì Assert)
	‚Ä¢	Evitar .block()
	‚Ä¢	Limpiar H2 en cada @BeforeEach
	‚Ä¢	Para capturar el ID del POST:
String id = webTestClient.post()
    .uri("/payment-initiation/payment-orders")
    .bodyValue(requestJson)
    .exchange()
    .expectStatus().isCreated()
    .expectBody()
    .jsonPath("$.paymentOrderReference")
    .value(String.class);
    	‚Ä¢	Reusar ese ID con transformaciones funcionales o variables locales.

    ‚∏ª

    CRITERIO DE √âXITO
El comando:
./gradlew test --no-daemon
debe pasar COMPLETAMENTE sin fallos.

Los endpoints deben comportarse exactamente seg√∫n:
	‚Ä¢	La colecci√≥n Postman
	‚Ä¢	El contrato OpenAPI
	‚Ä¢	El dominio Payment Initiation
	‚Ä¢	Las reglas de validaci√≥n

‚∏ª

DOCUMENTACI√ìN IA

Despu√©s de completar este paso debes documentar:
	‚Ä¢	ai/prompts.md
Registrar este prompt y los tests de integraci√≥n generados.
	‚Ä¢	ai/decisions.md
Explicar decisiones sobre:
‚Ä¢ uso de WebTestClient
‚Ä¢ casos de integraci√≥n cubiertos
‚Ä¢ alineaci√≥n con OpenAPI/Postman
‚Ä¢ manejo de errores y validaciones end-to-end

PASO 14 ‚Äì Calidad: JaCoCo, Checkstyle y SpotBugs
-------------------------------------------------
Prompt:

En build.gradle:

- Configura jacoco para generar reporte HTML y verificaci√≥n de cobertura m√≠nima (>= 85%).
  
- Excluir de cobertura JaCoCo:
  - C√≥digo generado (**/generated/**)
  - Entidades JPA (PaymentOrderEntity)
  - Implementaciones de MapStruct (*MapperImpl.class)
  - Clase principal (PaymentInitiationServiceApplication)
  - Configuraci√≥n (config/**)
  
- Configura checkstyle apuntando a config/checkstyle/checkstyle.xml:
  - maxWarnings: 10 (permite algunos warnings antes de fallar)
  - Excluir c√≥digo generado en checkstyle.xml usando BeforeExecutionExclusionFileFilter:
    - Patr√≥n: "generated/.*"
    - Patr√≥n: ".*MapperImpl\.java$"
  
- Configura spotbugs con nivel de severidad alto:
  ‚ö†Ô∏è IMPORTANTE: NO uses strings directamente para effort y reportLevel.
  En su lugar, configura cada tarea individualmente:
  
  ```gradle
  tasks.named('spotbugsMain') {
      effort = com.github.spotbugs.snom.Effort.valueOf('MAX')
      reportLevel = com.github.spotbugs.snom.Confidence.valueOf('HIGH')
      excludeFilter = file("${rootProject.projectDir}/config/spotbugs/exclude.xml")
  }
  ```
  
  Crea config/spotbugs/exclude.xml para excluir:
  - C√≥digo generado (com.bank.paymentinitiation.generated)
  - Implementaciones MapStruct (*MapperImpl)
  - Entidades JPA (PaymentOrderEntity)
  - Clase principal (PaymentInitiationServiceApplication)

- Configura el task check:
  ```gradle
  check {
      dependsOn 'checkstyleMain'
      dependsOn 'checkstyleTest'
      dependsOn 'spotbugsMain'
      dependsOn 'spotbugsTest'
      dependsOn 'test'
      dependsOn 'jacocoTestCoverageVerification'
      finalizedBy 'jacocoTestReport'  // Ejecuta despu√©s de los tests
  }
  ```
  ‚ö†Ô∏è NOTA: jacocoTestReport depende de test, as√≠ que se ejecuta despu√©s (finalizedBy) 
  para evitar dependencias circulares.

No seas extremo con las reglas pero s√≠ suficiente para que el c√≥digo est√© ordenado.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la configuraci√≥n de quality gates generada
- ai/decisions.md: Documenta todas las correcciones manuales aplicadas (SpotBugs, Checkstyle, JaCoCo), exclusiones de c√≥digo generado, y ajustes de cobertura m√≠nima
- ai/generations/: Opcionalmente guarda archivos de configuraci√≥n generados (checkstyle.xml, exclude.xml de SpotBugs) si hubo cambios significativos


PASO 15 ‚Äì Docker y docker-compose
---------------------------------
Prompt:

Crea un Dockerfile multi-stage para Gradle + Java 21:

- Stage builder: eclipse-temurin:21-jdk-alpine
  - Copia archivos de configuraci√≥n (gradle/, gradlew, build.gradle, settings.gradle)
  - Copia c√≥digo fuente (src/, openapi/, config/)
  - Da permisos de ejecuci√≥n a gradlew (chmod +x gradlew)
  - Compila con ./gradlew clean build -x test --no-daemon
  - Verifica que se gener√≥ el JAR con ls -la build/libs/

- Stage runtime: eclipse-temurin:21-jre-alpine
  - Instala wget para health checks (apk add --no-cache wget)
  - Crea usuario no-root para seguridad (addgroup/adduser spring)
  - Copia el JAR desde builder: payment-initiation-service-0.0.1-SNAPSHOT.jar ‚Üí app.jar
  - Usa usuario no-root (USER spring:spring)
  - Expone puerto 8080 (EXPOSE 8080)
  - Configura HEALTHCHECK usando /actuator/health
  - ENTRYPOINT: java -jar app.jar

Crea docker-compose.yml con un servicio payment-initiation-service que:

- build: context: ., dockerfile: Dockerfile
- container_name: payment-initiation-service
- ports: "8080:8080"
- environment:
  - SPRING_PROFILES_ACTIVE=docker
  - JAVA_OPTS=-Xmx512m -Xms256m
- healthcheck: usando wget con /actuator/health
- restart: unless-stopped
- networks: payment-network (bridge)

‚ö†Ô∏è IMPORTANTE: Crea .dockerignore para excluir:
- build/, .gradle/, out/
- .idea/, .vscode/, *.iml
- .git/
- Dockerfile, docker-compose.yml
- **/test-results/, **/reports/
- ai/ (documentaci√≥n, no necesario en runtime)

No necesitas otro contenedor de DB porque H2 es embebido.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y los archivos Docker generados
- ai/decisions.md: Documenta decisiones sobre Dockerfile multi-stage, docker-compose.yml, y .dockerignore
- ai/generations/: Opcionalmente guarda Dockerfile y docker-compose.yml iniciales si hubo cambios significativos


PASO 16 ‚Äì README y documentaci√≥n de IA
--------------------------------------
Prompt:

Crea README.md con:

1) Descripci√≥n del proyecto (BIAN Payment Initiation / PaymentOrder, migraci√≥n de SOAP a REST).
2) Arquitectura hexagonal y estructura de paquetes.
3) Stack t√©cnico (Java 21, Spring Boot 3, H2, JPA, Gradle, MapStruct, OpenAPI, WebTestClient, JaCoCo, Checkstyle, SpotBugs, Docker).
4) C√≥mo ejecutar:
   - ./gradlew clean check
   - ./gradlew bootRun
   - docker compose up --build
5) C√≥mo probar con Postman (referencia a postman_collection.json).
6) Uso de IA (descripci√≥n de carpeta ai/, qu√© se ha documentado).

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el README generado
- ai/decisions.md: Opcionalmente documenta decisiones finales sobre la estructura del README
- Verifica que toda la documentaci√≥n en ai/ est√° completa y actualizada


======================================================
SECCI√ìN B ‚Äì CURSOR RULES PARA EL PROYECTO (JAVA 21)
======================================================
# BIAN Payment Initiation ‚Äì Java 21 Spring Boot Migration Rules

## 1. Context

You are an expert software architect specialized in banking systems with 10+ years in fintech, migrating legacy SOAP services to REST APIs aligned with BIAN standards.

This project migrates a Payment Order SOAP service (PaymentOrderService.wsdl + XML samples) to a BIAN-compliant REST microservice, validated with the Postman collection (postman_collection.json).

## 2. Project Specifications

- BIAN Service Domain: Payment Initiation
- Behavior Qualifier: PaymentOrder
- Migration: SOAP (legacy) ‚Üí REST (BIAN-aligned)
- Architecture: Hexagonal (Ports & Adapters)
- Approach: Contract-First using OpenAPI 3.0
- Stack:
  - Java 21
  - Spring Boot 3 (Spring MVC, no reactive stack at runtime)
  - H2 Database (in-memory for local/testing, optional file-based for Docker)
  - Gradle (Groovy DSL)
  - MapStruct
  - WebTestClient for integration tests
  - JaCoCo, Checkstyle, SpotBugs for quality gates

Always keep domain code framework-agnostic and respect BIAN naming conventions.

## 3. BIAN Alignment

- Base path: /payment-initiation
- Behavior Qualifier: PaymentOrder
- Resource naming:
  - PaymentOrder instance is the Control Record (CR).
  - Use paymentOrderReference as the business identifier (similar to cr-reference-id).
- Operations:
  - Initiate ‚Üí POST /payment-initiation/payment-orders
  - Retrieve ‚Üí GET  /payment-initiation/payment-orders/{id}
  - Retrieve Status ‚Üí GET /payment-initiation/payment-orders/{id}/status

Map SOAP operations from PaymentOrderService.wsdl (SubmitPaymentOrder, GetPaymentOrderStatus, etc.) to these REST operations.

## 4. API Design

### Endpoint Structure

- POST /payment-initiation/payment-orders
- GET  /payment-initiation/payment-orders/{id}
- GET  /payment-initiation/payment-orders/{id}/status

### Request/Response Shapes

Align the request body with the Postman collection and BIAN concepts, for example:

InitiatePaymentOrderRequest:
- externalReference
- debtorAccount { iban }
- creditorAccount { iban }
- instructedAmount { amount, currency }
- remittanceInformation
- requestedExecutionDate

Responses must include:
- paymentOrderReference
- paymentOrderStatus
- payer/debtor and payee/creditor references or accounts
- amount (value + currency)
- timestamps (createdAt, updatedAt/lastUpdated)

### HTTP Status Codes

- 201 Created: successful POST initiate.
- 200 OK: successful GET retrieve / status.
- 400 Bad Request: validation errors, malformed requests.
- 404 Not Found: missing payment order.
- 500 Internal Server Error: unexpected errors.

Produce errors in application/problem+json (RFC 7807) using Spring‚Äôs ProblemDetail.

## 5. Hexagonal Architecture

### Root package

- com.bank.paymentinitiation

### Package structure

- com.bank.paymentinitiation.domain
  - model        (PaymentOrder, PaymentAmount, PaymentStatus, value objects)
  - port.in      (use case interfaces)
  - port.out     (repository interfaces, external ports)
  - exception    (domain exceptions)
  - service      (domain-level services if needed)
- com.bank.paymentinitiation.application
  - service      (use case implementations)
  - mapper       (optional)
- com.bank.paymentinitiation.adapter.in.rest
  - PaymentInitiationController (implements generated OpenAPI interfaces)
  - mapper (MapStruct DTO ‚Üî domain)
- com.bank.paymentinitiation.adapter.out.persistence
  - entity       (JPA entities for H2)
  - jpa          (Spring Data JPA repositories)
  - mapper       (MapStruct domain ‚Üî entity)
  - PaymentOrderRepositoryAdapter (implements domain port)
- com.bank.paymentinitiation.config
  - WebMvc, JPA, H2 console, security (if any)

Rules:
- Domain layer is pure Java, no Spring annotations.
- Ports live in domain; adapters implement ports.
- MapStruct only in adapter/application, never in domain.

## 6. Contract-First OpenAPI

- Source of truth: openapi/openapi.yaml.
- Use org.openapi.generator Gradle plugin with generatorName "spring" and interfaceOnly = true.
- Generated packages:
  - com.bank.paymentinitiation.generated.api
  - com.bank.paymentinitiation.generated.model
- Controllers in adapter.in.rest must implement these generated interfaces, not define their own method signatures manually.

OpenAPI must be consistent with:
- WSDL and XML samples for fields and states.
- Postman collection for endpoints and example payloads.

## 7. Gradle Build (Java 21)

Key points:
- sourceCompatibility = JavaVersion.VERSION_21
- targetCompatibility = JavaVersion.VERSION_21
- Use spring-boot-starter-web (MVC), spring-boot-starter-data-jpa, spring-boot-starter-validation, spring-boot-starter-actuator.
- runtimeOnly com.h2database:h2
- WebTestClient is allowed via testImplementation "org.springframework:spring-webflux" (tests only).

‚ö†Ô∏è IMPORTANTE - Dependencias para c√≥digo generado:
- Add dependencies required by OpenAPI Generator:
  - implementation "io.swagger.core.v3:swagger-annotations:2.2.21"
  - implementation "org.openapitools:jackson-databind-nullable:0.2.6"
  - implementation "jakarta.validation:jakarta.validation-api:3.0.2"
  - implementation "jakarta.annotation:jakarta.annotation-api:2.1.1"

Quality gates:
- JaCoCo with minimum 75% line coverage on main code (realistic target, can be increased to 80% with more tests).
  Exclusions:
  - **/generated/** (OpenAPI generated code)
  - PaymentOrderEntity and inner classes
  - *MapperImpl.class (MapStruct implementations)
  - PaymentInitiationServiceApplication (main class)
  - config/** (configuration classes)
  
- Checkstyle:
  - Config file: config/checkstyle/checkstyle.xml
  - maxWarnings: 10 (allows some warnings)
  - Exclude generated code using BeforeExecutionExclusionFileFilter in checkstyle.xml
  - Patterns: "generated/.*" and ".*MapperImpl\.java$"
  
- SpotBugs:
  ‚ö†Ô∏è CRITICAL: Do NOT configure effort and reportLevel as strings in spotbugs {} block.
  Use tasks.named('spotbugsMain') with:
  - effort = com.github.spotbugs.snom.Effort.valueOf('MAX')
  - reportLevel = com.github.spotbugs.snom.Confidence.valueOf('HIGH')
  - excludeFilter pointing to config/spotbugs/exclude.xml
  - Report level: HIGH (only report high-confidence issues)

The Gradle check task must run unit tests, integration tests, coverage verification, Checkstyle and SpotBugs.
‚ö†Ô∏è NOTE: Configure check task dependencies carefully to avoid circular dependencies:
- jacocoTestReport depends on test, so use finalizedBy instead of dependsOn

## 8. Spring Configuration (H2 + MVC)

- Use application.yml to configure H2 in-memory for local/dev.
- Enable H2 console at /h2-console for debugging.
- Set JPA ddl-auto to update or create-drop for tests.
- Configure Jackson to use ISO date/time, no timestamps.

Ensure the application runs on port 8080 and matches the URLs in the Postman collection.

## 9. Controller Rules (Spring MVC)

PaymentOrdersController MUST:

- Implement the interface generated from OpenAPI (e.g. PaymentOrdersApi - check generated.api package).
- Use @RestController, @RequiredArgsConstructor, @Slf4j.
- Inject:
  - Use cases (Initiate/Retrieve/Status)
  - PaymentOrderRestMapper
  - PaymentOrderReferenceGenerator (for generating unique references)

HTTP behavior:

- POST initiatePaymentOrder:
  - Validate request with @Valid.
  - Generate paymentOrderReference using PaymentOrderReferenceGenerator.generate().
  - Map DTO ‚Üí domain using mapper.toDomain(request, paymentOrderReference).
  - Call InitiatePaymentOrderUseCase.
  - Map domain ‚Üí InitiatePaymentOrderResponse.
  - Return ResponseEntity.status(HttpStatus.CREATED).body(response).

- GET retrievePaymentOrder:
  - Call RetrievePaymentOrderUseCase with id (paymentOrderReference).
  - Map domain ‚Üí RetrievePaymentOrderResponse.
  - Return ResponseEntity.ok(body).

- GET retrievePaymentOrderStatus:
  - Call RetrievePaymentOrderUseCase (needs full order for mapping to response).
  - Map domain ‚Üí PaymentOrderStatusResponse.
  - Return ResponseEntity.ok(body).

Never expose domain entities or JPA entities directly in REST responses. Always go through DTOs generated from OpenAPI + MapStruct mappers.

## 10. Error Handling (RFC 7807)

Implement GlobalExceptionHandler with @RestControllerAdvice that:

- Maps PaymentOrderNotFoundException ‚Üí 404 NOT FOUND with ProblemDetail:
  - title = "Payment Order Not Found"
  - status = 404
  - detail = useful error message

- Maps InvalidPaymentException ‚Üí 400 BAD REQUEST with ProblemDetail:
  - title = "Invalid Payment Order"
  - status = 400
  - detail = validation/business error description

- Maps generic Exception ‚Üí 500 Internal Server Error with ProblemDetail.

All error responses must use application/problem+json and avoid exposing internal details (stack traces, SQL, etc.).

## 11. Persistence Layer Rules (H2 + JPA)

- Use H2 for persistence in local and tests.
- Define PaymentOrderEntity with UUID primary key and paymentOrderReference as unique column.
- Spring Data JPA repository with method findByPaymentOrderReference.
- PaymentOrderRepositoryAdapter implementing domain port PaymentOrderRepository, using MapStruct PaymentOrderPersistenceMapper to convert between domain and entity.

Domain layer must not depend on JPA or persistence annotations.

## 12. MapStruct Usage

Define three main mapper types:

1. REST mapper (adapter.in.rest.mapper):
   - DTO ‚Üî Domain.
   - Responsible for translating REST-level semantics (BIAN JSON) into domain objects and vice versa.
   - Method signature: `toDomain(InitiatePaymentOrderRequest request, String paymentOrderReference)`
     - The paymentOrderReference is generated in the controller and passed as parameter.

2. Persistence mapper (adapter.out.persistence.mapper):
   - Domain ‚Üî Entity.
   - Responsible for mapping business objects to relational persistence structures.
   - For toDomain(PaymentOrderEntity), use PaymentOrder.create() factory method and changeStatus() 
     if the entity status is different from INITIATED.

3. Optional application-level mapper (application.mapper):
   - For complex transformations inside use cases if needed.

All mappers:
- Use @Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR).
- Keep mapping logic declarative; avoid custom imperative logic in mappers unless absolutely required.

‚ö†Ô∏è IMPORTANTE - Evitar ambig√ºedades de tipos:
- Use fully qualified names for types with same name in different packages:
  - `com.bank.paymentinitiation.domain.model.PaymentAmount` vs `com.bank.paymentinitiation.generated.model.PaymentAmount`
  - `com.bank.paymentinitiation.domain.model.PaymentStatus` vs `com.bank.paymentinitiation.generated.model.PaymentStatus`
- For timestamp conversions (LocalDateTime ‚Üî OffsetDateTime), add @Named methods:
  ```java
  @Named("localDateTimeToOffsetDateTime")
  default OffsetDateTime localDateTimeToOffsetDateTime(LocalDateTime localDateTime) {
      return localDateTime != null ? localDateTime.atOffset(ZoneOffset.UTC) : null;
  }
  ```

## 13. Testing Strategy

### Unit Tests

- Domain:
  - Cover PaymentOrder aggregate behavior, value objects, status transitions and invariants.
- Application:
  - Use cases with mocked PaymentOrderRepository.
  - Verify business rules and error handling.

### Integration Tests (WebTestClient + Spring MVC)

- Use @SpringBootTest(webEnvironment = RANDOM_PORT) + @AutoConfigureWebTestClient.
- Use real H2 configuration.
- Cover:
  - POST /payment-initiation/payment-orders ‚Üí 201 Created with correct body.
  - GET /payment-initiation/payment-orders/{id} ‚Üí 200 OK.
  - GET /payment-initiation/payment-orders/{id}/status ‚Üí 200 OK.
  - Error cases 404 and 400.

Align test requests/responses with the Postman collection examples.

### Repository Tests

- Use @DataJpaTest for PaymentOrderJpaRepository and verify basic CRUD + custom queries (findByPaymentOrderReference).

## 14. Docker & Runtime Rules

- Use multi-stage Dockerfile with Java 21 (Temurin JDK/JRE):
  - Stage 1 (builder): eclipse-temurin:21-jdk-alpine
    - Copy Gradle files, source code (src/, openapi/, config/)
    - Run `./gradlew clean build -x test --no-daemon`
    - Verify JAR generation
  - Stage 2 (runtime): eclipse-temurin:21-jre-alpine
    - Install wget for health checks
    - Create non-root user (spring:spring)
    - Copy JAR from builder (rename to app.jar)
    - Set USER spring:spring
    - Expose port 8080
    - HEALTHCHECK using /actuator/health
    - ENTRYPOINT: java -jar app.jar

- Create .dockerignore to exclude:
  - build/, .gradle/, out/
  - .idea/, .vscode/, *.iml
  - .git/, Dockerfile, docker-compose.yml
  - test-results/, reports/, ai/

- docker-compose.yml:
  - Build context: current directory
  - Ports: "8080:8080"
  - Environment: SPRING_PROFILES_ACTIVE=docker, JAVA_OPTS
  - Healthcheck configuration
  - Restart policy: unless-stopped
  - Network: dedicated bridge network

- Ensure the container runs the Spring Boot jar listening on port 8080.
- Health check uses /actuator/health endpoint.
- In Docker profile, you may use H2 in file mode if persistence across restarts is needed.

## 15. AI Usage Documentation (ai/ folder)

For every significant use of AI (Cursor/ChatGPT):

- Log the prompt and a short summary of the answer in ai/prompts.md.
- Document architectural decisions, manual corrections, and final choices in ai/decisions.md.
- Store key generated fragments (for example initial openapi.yaml or first controller draft) in ai/generations/, with a short comment in the header explaining what was kept and what was changed.

All AI-generated code MUST be reviewed, adapted and tested before being considered production-ready.

## 16. Final Checklist

Before considering the challenge DONE, verify:

‚úÖ **OpenAPI Contract:**
- OpenAPI contract is the source of truth and matches Postman and WSDL semantics.
- All paths are correctly defined (POST /payment-initiation/payment-orders, GET /payment-initiation/payment-orders/{id}, GET /payment-initiation/payment-orders/{id}/status).
- Schemas match Postman collection examples.

‚úÖ **Architecture:**
- Hexagonal architecture is respected, with no Spring/framework dependencies in domain.
- Domain models are pure Java (no annotations from Spring/JPA).
- Ports and adapters are correctly separated.

‚úÖ **REST API:**
- All REST endpoints return correct HTTP status codes (201, 200, 400, 404, 500).
- Error responses follow RFC 7807 and use application/problem+json.
- PaymentOrderReferenceGenerator generates unique references correctly.

‚úÖ **Mappers:**
- MapStruct mappers work correctly and are covered by tests where necessary.
- No ambiguity errors between domain and generated types.
- Timestamp conversions (LocalDateTime ‚Üî OffsetDateTime) work correctly.

‚úÖ **Persistence:**
- PaymentOrderRepositoryAdapter fully implements domain port.
- JPA entity correctly maps to domain model.
- H2 is configured and accessible; H2 console works in dev.

‚úÖ **Testing:**
- Unit tests for domain models (PaymentOrder, PaymentAmount, value objects).
- Unit tests for application services (with mocked repository).
- Integration tests with WebTestClient cover all endpoints.
- All tests pass on Java 21.

‚úÖ **Quality Gates:**
- ./gradlew clean check passes:
  - JaCoCo coverage >= 75% (realistic target)
  - Checkstyle (maxWarnings: 10, excludes generated code)
  - SpotBugs (HIGH confidence, excludes generated code)
  - All tests pass

‚úÖ **Configuration:**
- ApplicationConfig defines beans for application services.
- PaymentOrderReferenceGenerator is configured as @Component.
- All dependencies are correctly injected.

‚úÖ **Docker:**
- Dockerfile multi-stage builds successfully.
- Docker image runs and service starts correctly on port 8080.
- Health check works via /actuator/health.
- docker-compose.yml works correctly.

‚úÖ **Documentation:**
- AI usage is documented in ai/prompts.md and ai/decisions.md.
- Key generated fragments stored in ai/generations/.
- README.md explains setup, architecture, how to run, and how to test via Postman collection.

If any of these checks fail, fix them before delivering the solution.

---

## 17. Lecciones Aprendidas y Mejoras para Futuros Proyectos

### Problemas Comunes y Soluciones

1. **Ambiguidad de Tipos en MapStruct:**
   - Problema: PaymentAmount y PaymentStatus existen en dominio y generated.model.
   - Soluci√≥n: Usar nombres completamente calificados en mappers.

2. **SpotBugs Configuration:**
   - Problema: effort y reportLevel no aceptan strings en plugin 6.0.0+.
   - Soluci√≥n: Configurar por tarea usando Effort.valueOf() y Confidence.valueOf().

3. **Cobertura de C√≥digo:**
   - Problema: 80% es dif√≠cil de alcanzar inicialmente.
   - Soluci√≥n: Comenzar con 75% y aumentar gradualmente.

4. **Checkstyle y C√≥digo Generado:**
   - Problema: Checkstyle falla en c√≥digo generado por OpenAPI.
   - Soluci√≥n: Excluir usando BeforeExecutionExclusionFileFilter en checkstyle.xml.

5. **Generaci√≥n de paymentOrderReference:**
   - Problema: El mapper necesita la referencia pero no debe generarla.
   - Soluci√≥n: Generar en el controlador y pasar como par√°metro al mapper.

6. **Dependencias Circulares en task check:**
   - Problema: jacocoTestReport depende de test que est√° en check.
   - Soluci√≥n: Usar finalizedBy en lugar de dependsOn para jacocoTestReport.

7. **Conversi√≥n de Timestamps en MapStruct:**
   - Problema: DTOs OpenAPI usan OffsetDateTime pero dominio usa LocalDateTime.
   - Soluci√≥n: Agregar m√©todos @Named para convertir LocalDateTime ‚Üí OffsetDateTime en mappers REST.

8. **Generador de paymentOrderReference:**
   - Problema: Se necesita generar ID √∫nico pero el mapper no debe tener esta responsabilidad.
   - Soluci√≥n: Crear PaymentOrderReferenceGenerator como componente Spring separado.

9. **ApplicationConfig para Beans:**
   - Problema: Servicios de aplicaci√≥n necesitan configuraci√≥n expl√≠cita para inyecci√≥n de dependencias.
   - Soluci√≥n: Crear ApplicationConfig con @Configuration y definir beans manualmente.

10. **Controlador retrievePaymentOrderStatus:**
    - Problema: RetrievePaymentOrderStatusUseCase retorna solo PaymentStatus pero response necesita paymentOrderReference y lastUpdated.
    - Soluci√≥n: Usar RetrievePaymentOrderUseCase en el controlador para obtener orden completa.

---

## 18. Resumen de Archivos Clave del Proyecto

### Archivos de Configuraci√≥n
- `build.gradle`: Configuraci√≥n Gradle con plugins, dependencias y quality gates
- `settings.gradle`: Nombre del proyecto
- `application.yml`: Configuraci√≥n Spring Boot (H2, JPA, logging)
- `config/checkstyle/checkstyle.xml`: Reglas Checkstyle con exclusiones
- `config/spotbugs/exclude.xml`: Filtros de exclusi√≥n para SpotBugs

### Archivos de Contrato
- `openapi/openapi.yaml`: Contrato OpenAPI 3.0 (source of truth)
- `postman_collection.json`: Colecci√≥n Postman para testing

### Archivos Docker
- `Dockerfile`: Multi-stage build para Java 21
- `docker-compose.yml`: Orquestaci√≥n del servicio
- `.dockerignore`: Exclusiones para contexto de build

### Archivos de Documentaci√≥n
- `README.md`: Documentaci√≥n completa del proyecto
- `ai/prompts.md`: Lista de prompts usados con IA
- `ai/decisions.md`: Decisiones arquitect√≥nicas y correcciones
- `ai/generations/`: Fragmentos generados por IA

---

## 19. Checklist de Verificaci√≥n Final

Antes de considerar el proyecto completo, ejecuta estos comandos y verifica que todos pasan:

```bash
# 1. Verificar compilaci√≥n
./gradlew clean build -x test

# 2. Ejecutar todos los tests
./gradlew test

# 3. Ejecutar quality gates
./gradlew check

# 4. Verificar reportes
# - Tests: build/reports/tests/test/index.html
# - JaCoCo: build/reports/jacoco/html/index.html
# - Checkstyle: build/reports/checkstyle/main.html
# - SpotBugs: build/reports/spotbugs/main.html

# 5. Ejecutar aplicaci√≥n localmente
./gradlew bootRun
# Verificar: http://localhost:8080/actuator/health

# 6. Construir y ejecutar Docker
docker-compose up --build
# Verificar: http://localhost:8080/actuator/health
```

---

¬°√âxito con la implementaci√≥n del challenge!

===== /mnt/data/prompt_v2.txt =====
# BIAN Payment Initiation - Java Spring Boot Migration Rules

## Context
You are an expert software architect specialized in banking systems with 10+ years in fintech, migrating legacy SOAP services to REST APIs aligned with BIAN (Banking Industry Architecture Network) standards. This project involves migrating a Payment Order SOAP service to a BIAN-compliant REST microservice.

## SOAP to REST Migration Analysis

### Legacy SOAP Service Analysis
**WSDL**: PaymentOrderService.wsdl
**Operations Identified**:
1. **SubmitPaymentOrder** ‚Üí Maps to BIAN **Initiate** operation
2. **GetPaymentOrderStatus** ‚Üí Maps to BIAN **Retrieve Status** operation

### SOAP to BIAN Field Mapping

| SOAP Field | BIAN REST Field | Type | Notes |
|------------|-----------------|------|-------|
| externalId | externalReference | string | Client-provided reference |
| debtorIban | debtorAccount.iban | string | Payer account identifier |
| creditorIban | creditorAccount.iban | string | Payee account identifier |
| amount | instructedAmount.amount | decimal | Payment amount |
| currency | instructedAmount.currency | string | ISO 4217 currency code |
| remittanceInfo | remittanceInformation | string | Payment purpose/description |
| requestedExecutionDate | requestedExecutionDate | date | ISO 8601 date format |
| paymentOrderId | paymentOrderReference | string | BIAN-compliant reference (PO-xxxx) |
| status | paymentOrderStatus | enum | SOAP: ACCEPTED, SETTLED, REJECTED<br>BIAN: INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED |
| lastUpdate | lastUpdated | datetime | ISO 8601 datetime format |

### Status Mapping Strategy

```java
// SOAP Legacy Status ‚Üí BIAN Status
ACCEPTED    ‚Üí INITIATED
PENDING     ‚Üí PENDING
PROCESSING  ‚Üí PROCESSED
SETTLED     ‚Üí COMPLETED
REJECTED    ‚Üí FAILED
CANCELLED   ‚Üí CANCELLED
```

### Key Migration Decisions
1. **externalId** becomes **externalReference** (keeps external system traceability)
2. **IBAN** fields wrapped in account objects for better structure
3. **amount + currency** combined into **instructedAmount** object (ISO 20022 compliant)
4. **paymentOrderId** renamed to **paymentOrderReference** (BIAN naming)
5. Status values normalized to BIAN lifecycle
6. Added missing fields required by BIAN (createdAt, updatedAt)

## Project Specifications
- **BIAN Service Domain**: Payment Initiation
- **Behavior Qualifier**: PaymentOrder
- **Migration**: SOAP (legacy) ‚Üí REST (BIAN-aligned)
- **Architecture**: Hexagonal (Ports & Adapters)
- **Approach**: Contract-First with OpenAPI 3.0
- **Stack**: Java 17+, Spring Boot 3+, Spring MVC, H2 Database, Gradle, MapStruct

## Core Principles

### 1. BIAN Alignment (Critical)
- **Service Domain Naming**: Always use `payment-initiation` as the base path
- **Behavior Qualifier**: PaymentOrder is the main BQ
- **Resource Naming**: Use BIAN nomenclature
  - Control Record (CR): PaymentOrder instance
  - Use `cr-reference-id` for the main resource identifier
- **Standard Operations**: Follow BIAN service operations
  - `Initiate`: POST to create new payment order
  - `Retrieve`: GET to fetch payment order or status
  - `Update`: PUT/PATCH to modify (if needed)
  - `Execute`: POST to trigger execution (if applicable)

### 2. API Design Patterns

#### Endpoint Structure
```
POST   /payment-initiation/payment-orders              # Initiate
GET    /payment-initiation/payment-orders/{id}         # Retrieve
GET    /payment-initiation/payment-orders/{id}/status  # Retrieve Status
```

#### Request/Response Standards
- Use RFC 7807 (`application/problem+json`) for errors
- Follow BIAN JSON schema conventions:
  ```json
  {
    "paymentOrderReference": "PO-2024-001",
    "paymentInitiationTransaction": { ... },
    "payerReference": "CUST-123",
    "payeeReference": "CUST-456",
    "amount": { "value": 1000.00, "currency": "USD" },
    "paymentOrderStatus": "INITIATED"
  }
  ```

#### HTTP Status Codes (BIAN-aligned)
- `201 Created`: Successful Initiate (POST new resource)
- `200 OK`: Successful Retrieve (GET), Update (PUT/PATCH), or Execute
- `204 No Content`: Successful DELETE or operation with no response body
- `400 Bad Request`: Validation errors, malformed request
- `404 Not Found`: Resource not found
- `409 Conflict`: Idempotency violation, business rule conflict
- `422 Unprocessable Entity`: Semantic errors (valid format, invalid business logic)
- `500 Internal Server Error`: System errors, unexpected failures
- `503 Service Unavailable`: Temporary service issues

### 3. Hexagonal Architecture (Mandatory)

#### Package Structure
```
com.hiberus.banking.payment
‚îú‚îÄ‚îÄ domain/                          # Core business logic (framework-independent)
‚îÇ   ‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaymentOrder.java       # Aggregate root
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaymentAmount.java      # Value object
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaymentStatus.java      # Enum
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PayerReference.java     # Value object
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PayeeReference.java     # Value object
‚îÇ   ‚îú‚îÄ‚îÄ port/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ in/                     # Input ports (use cases)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ InitiatePaymentOrderUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RetrievePaymentOrderUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RetrievePaymentOrderStatusUseCase.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ out/                    # Output ports (repositories, external services)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PaymentOrderRepository.java
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PaymentValidationPort.java
‚îÇ   ‚îú‚îÄ‚îÄ exception/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaymentOrderNotFoundException.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ InvalidPaymentException.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DomainException.java
‚îÇ   ‚îî‚îÄ‚îÄ service/                    # Domain services
‚îÇ       ‚îî‚îÄ‚îÄ PaymentOrderDomainService.java
‚îú‚îÄ‚îÄ application/                     # Application services (orchestration)
‚îÇ   ‚îú‚îÄ‚îÄ service/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ InitiatePaymentOrderService.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RetrievePaymentOrderService.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RetrievePaymentOrderStatusService.java
‚îÇ   ‚îî‚îÄ‚îÄ mapper/
‚îÇ       ‚îú‚îÄ‚îÄ PaymentOrderMapper.java              # MapStruct interface
‚îÇ       ‚îî‚îÄ‚îÄ PaymentOrderMapperImpl.java          # Generated by MapStruct
‚îú‚îÄ‚îÄ adapter/                         # Adapters (infrastructure)
‚îÇ   ‚îú‚îÄ‚îÄ in/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rest/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaymentInitiationController.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/               # Generated from OpenAPI
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ InitiatePaymentOrderRequest.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ InitiatePaymentOrderResponse.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RetrievePaymentOrderResponse.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PaymentOrderStatusResponse.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mapper/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PaymentOrderRestMapper.java  # MapStruct for DTO ‚Üî Domain
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ OpenApiConfig.java
‚îÇ   ‚îî‚îÄ‚îÄ out/
‚îÇ       ‚îú‚îÄ‚îÄ persistence/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ PaymentOrderRepositoryAdapter.java
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ entity/
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PaymentOrderEntity.java
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ jpa/
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PaymentOrderJpaRepository.java  # Spring Data JPA
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ mapper/
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ PaymentOrderPersistenceMapper.java  # MapStruct for Entity ‚Üî Domain
‚îÇ       ‚îî‚îÄ‚îÄ external/
‚îÇ           ‚îî‚îÄ‚îÄ LegacySoapClientAdapter.java  # If needed for transitional period
‚îî‚îÄ‚îÄ config/                          # Spring configuration
    ‚îú‚îÄ‚îÄ WebMvcConfig.java
    ‚îú‚îÄ‚îÄ JpaConfig.java
    ‚îú‚îÄ‚îÄ H2ConsoleConfig.java
    ‚îî‚îÄ‚îÄ SecurityConfig.java
```

#### Key Rules
- **Domain Layer**: NEVER import Spring or framework-specific annotations
- **Ports**: Define interfaces in domain layer, implement in adapters
- **Dependencies**: Always point inward (adapter ‚Üí application ‚Üí domain)
- **Value Objects**: Immutable, validation in constructor
- **Aggregates**: PaymentOrder is the aggregate root, enforce invariants
- **MapStruct**: Use in application and adapter layers, NEVER in domain

### 4. Contract-First Development

#### OpenAPI Generation with Gradle
```yaml
# openapi.yaml structure
openapi: 3.0.3
info:
  title: BIAN Payment Initiation API
  version: 1.0.0
  description: Payment Order management aligned with BIAN Service Domain

servers:
  - url: http://localhost:8080
    description: Local development server

paths:
  /payment-initiation/payment-orders:
    post:
      operationId: initiatePaymentOrder
      tags: [Payment Initiation]
      summary: Initiate a new payment order
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InitiatePaymentOrderRequest'
      responses:
        '201':
          description: Payment order successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InitiatePaymentOrderResponse'
        '400':
          $ref: '#/components/responses/BadRequest'
        '500':
          $ref: '#/components/responses/InternalServerError'
  
  /payment-initiation/payment-orders/{id}:
    get:
      operationId: retrievePaymentOrder
      tags: [Payment Initiation]
      summary: Retrieve payment order details
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RetrievePaymentOrderResponse'
        '404':
          $ref: '#/components/responses/NotFound'
  
  /payment-initiation/payment-orders/{id}/status:
    get:
      operationId: retrievePaymentOrderStatus
      tags: [Payment Initiation]
      summary: Retrieve payment order status
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Payment order status retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentOrderStatusResponse'
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    InitiatePaymentOrderRequest:
      type: object
      required: 
        - payerReference
        - payeeReference
        - amount
      properties:
        payerReference:
          type: string
          description: Reference to the payer (customer ID)
          example: "CUST-12345"
        payeeReference:
          type: string
          description: Reference to the payee (beneficiary ID)
          example: "CUST-67890"
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
          description: Purpose of the payment
          example: "Invoice payment"
        paymentDate:
          type: string
          format: date
          description: Requested payment date
          example: "2024-11-20"
    
    InitiatePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
          description: BIAN-compliant payment order reference
          example: "PO-2024-001234"
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        createdAt:
          type: string
          format: date-time
    
    RetrievePaymentOrderResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        payerReference:
          type: string
        payeeReference:
          type: string
        amount:
          $ref: '#/components/schemas/PaymentAmount'
        paymentPurpose:
          type: string
        paymentDate:
          type: string
          format: date
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
    
    PaymentOrderStatusResponse:
      type: object
      properties:
        paymentOrderReference:
          type: string
        paymentOrderStatus:
          type: string
          enum: [INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED]
        statusReason:
          type: string
          description: Reason for current status
        lastUpdated:
          type: string
          format: date-time
    
    PaymentAmount:
      type: object
      required:
        - value
        - currency
      properties:
        value:
          type: number
          format: double
          minimum: 0.01
          example: 1500.50
        currency:
          type: string
          enum: [USD, EUR, GBP, JPY]
          example: "USD"
    
    ProblemDetail:
      type: object
      properties:
        type:
          type: string
          format: uri
        title:
          type: string
        status:
          type: integer
        detail:
          type: string
        instance:
          type: string
          format: uri
  
  responses:
    BadRequest:
      description: Bad request - validation errors
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    NotFound:
      description: Resource not found
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
    
    InternalServerError:
      description: Internal server error
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/ProblemDetail'
```

#### Gradle Configuration (build.gradle)
```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'org.openapi.generator' version '7.0.1'
    id 'checkstyle'
    id 'com.github.spotbugs' version '6.0.0'
    id 'jacoco'
}

group = 'com.hiberus.banking'
version = '1.0.0'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

ext {
    mapstructVersion = '1.5.5.Final'
    lombokVersion = '1.18.30'
    openApiVersion = '2.2.0'
}

dependencies {
    // Spring Boot Starters
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    
    // H2 Database
    runtimeOnly 'com.h2database:h2'
    
    // OpenAPI
    implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${openApiVersion}"
    
    // MapStruct
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
    
    // Lombok
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
    
    // Lombok + MapStruct compatibility
    annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"
    
    // Testing
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-webflux'  // For WebTestClient
    testImplementation 'io.rest-assured:rest-assured:5.4.0'
    testImplementation 'org.assertj:assertj-core'
    
    // Test Lombok
    testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"
}

// OpenAPI Generator Task
openApiGenerate {
    generatorName = 'spring'
    inputSpec = "$projectDir/src/main/resources/openapi.yaml"
    outputDir = "$buildDir/generated"
    apiPackage = 'com.hiberus.banking.payment.adapter.in.rest.api'
    modelPackage = 'com.hiberus.banking.payment.adapter.in.rest.dto'
    invokerPackage = 'com.hiberus.banking.payment.adapter.in.rest.invoker'
    configOptions = [
        interfaceOnly: 'true',
        useSpringBoot3: 'true',
        useTags: 'true',
        dateLibrary: 'java8',
        serializationLibrary: 'jackson',
        hideGenerationTimestamp: 'true'
    ]
}

// Add generated sources to source sets
sourceSets {
    main {
        java {
            srcDirs += "$buildDir/generated/src/main/java"
        }
    }
}

// Compile depends on generation
compileJava.dependsOn tasks.openApiGenerate

// JaCoCo Configuration
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
    }
}

// Checkstyle Configuration
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
}

// SpotBugs Configuration
spotbugs {
    effort = 'max'
    reportLevel = 'high'
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
        }
        xml {
            required = false
        }
    }
}

// Test Configuration
test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

// Build task order
check.dependsOn jacocoTestCoverageVerification
```

#### Controller Implementation (Spring MVC)
```java
@RestController
@RequiredArgsConstructor
@Slf4j
public class PaymentInitiationController implements PaymentInitiationApi {
    
    private final InitiatePaymentOrderUseCase initiateUseCase;
    private final RetrievePaymentOrderUseCase retrieveUseCase;
    private final RetrievePaymentOrderStatusUseCase retrieveStatusUseCase;
    private final PaymentOrderRestMapper mapper;
    
    @Override
    public ResponseEntity<InitiatePaymentOrderResponse> initiatePaymentOrder(
            InitiatePaymentOrderRequest request) {
        
        log.info("Initiating payment order for payer: {}", request.getPayerReference());
        
        PaymentOrder domainOrder = mapper.toDomain(request);
        PaymentOrder initiatedOrder = initiateUseCase.initiate(domainOrder);
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(initiatedOrder);
        
        log.info("Payment order initiated successfully: {}", response.getPaymentOrderReference());
        
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(response);
    }
    
    @Override
    public ResponseEntity<RetrievePaymentOrderResponse> retrievePaymentOrder(String id) {
        
        log.info("Retrieving payment order: {}", id);
        
        PaymentOrder paymentOrder = retrieveUseCase.retrieve(id);
        RetrievePaymentOrderResponse response = mapper.toRetrieveResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
    
    @Override
    public ResponseEntity<PaymentOrderStatusResponse> retrievePaymentOrderStatus(String id) {
        
        log.info("Retrieving payment order status: {}", id);
        
        PaymentOrder paymentOrder = retrieveStatusUseCase.retrieveStatus(id);
        PaymentOrderStatusResponse response = mapper.toStatusResponse(paymentOrder);
        
        return ResponseEntity.ok(response);
    }
}
```

### 5. Spring MVC with H2 Database

#### Application Configuration (application.yml)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 Database Configuration
  datasource:
    url: jdbc:h2:mem:paymentdb
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: false
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
  
  # Jackson Configuration
  jackson:
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

# Server Configuration
server:
  port: 8080
  servlet:
    context-path: /
  error:
    include-message: always
    include-binding-errors: always
    include-exception: false
    include-stacktrace: never

# Management / Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    tags:
      application: ${spring.application.name}
      service-domain: payment-initiation

# Logging
logging:
  level:
    com.hiberus.banking: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

#### JPA Entity Example
```java
@Entity
@Table(name = "payment_orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PaymentOrderEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(name = "payment_order_reference", nullable = false, unique = true, length = 50)
    private String paymentOrderReference;
    
    @Column(name = "payer_reference", nullable = false, length = 50)
    private String payerReference;
    
    @Column(name = "payee_reference", nullable = false, length = 50)
    private String payeeReference;
    
    @Column(name = "amount", nullable = false, precision = 19, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "currency", nullable = false, length = 3)
    private String currency;
    
    @Column(name = "payment_purpose", length = 255)
    private String paymentPurpose;
    
    @Column(name = "payment_date")
    private LocalDate paymentDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PaymentStatusEntity status;
    
    @Column(name = "status_reason", length = 500)
    private String statusReason;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        if (status == null) {
            status = PaymentStatusEntity.INITIATED;
        }
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

@Getter
@RequiredArgsConstructor
enum PaymentStatusEntity {
    INITIATED("Payment order has been initiated"),
    PENDING("Payment order is pending processing"),
    PROCESSED("Payment order has been processed"),
    COMPLETED("Payment order completed successfully"),
    FAILED("Payment order failed"),
    CANCELLED("Payment order has been cancelled");
    
    private final String description;
}
```

#### Spring Data JPA Repository
```java
@Repository
public interface PaymentOrderJpaRepository extends JpaRepository<PaymentOrderEntity, UUID> {
    
    Optional<PaymentOrderEntity> findByPaymentOrderReference(String paymentOrderReference);
    
    List<PaymentOrderEntity> findByPayerReference(String payerReference);
    
    List<PaymentOrderEntity> findByStatus(PaymentStatusEntity status);
    
    @Query("SELECT p FROM PaymentOrderEntity p WHERE p.createdAt BETWEEN :startDate AND :endDate")
    List<PaymentOrderEntity> findByDateRange(
        @Param("startDate") LocalDateTime startDate, 
        @Param("endDate") LocalDateTime endDate
    );
    
    boolean existsByPaymentOrderReference(String paymentOrderReference);
}
```

#### Repository Adapter Implementation
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PaymentOrderRepositoryAdapter implements PaymentOrderRepository {
    
    private final PaymentOrderJpaRepository jpaRepository;
    private final PaymentOrderPersistenceMapper persistenceMapper;
    
    @Override
    public PaymentOrder save(PaymentOrder paymentOrder) {
        log.debug("Saving payment order: {}", paymentOrder.getPaymentOrderReference());
        
        PaymentOrderEntity entity = persistenceMapper.toEntity(paymentOrder);
        PaymentOrderEntity savedEntity = jpaRepository.save(entity);
        
        log.debug("Payment order saved with ID: {}", savedEntity.getId());
        return persistenceMapper.toDomain(savedEntity);
    }
    
    @Override
    public Optional<PaymentOrder> findByReference(String paymentOrderReference) {
        log.debug("Finding payment order by reference: {}", paymentOrderReference);
        
        return jpaRepository.findByPaymentOrderReference(paymentOrderReference)
            .map(persistenceMapper::toDomain);
    }
    
    @Override
    public boolean existsByReference(String paymentOrderReference) {
        return jpaRepository.existsByPaymentOrderReference(paymentOrderReference);
    }
    
    @Override
    public List<PaymentOrder> findAll() {
        return jpaRepository.findAll().stream()
            .map(persistenceMapper::toDomain)
            .collect(Collectors.toList());
    }
}
```

#### H2 Console Configuration
```java
@Configuration
public class H2ConsoleConfig {
    
    @Bean
    public ServletRegistrationBean<WebServlet> h2Console() {
        ServletRegistrationBean<WebServlet> registration = 
            new ServletRegistrationBean<>(new WebServlet());
        registration.addUrlMappings("/h2-console/*");
        return registration;
    }
}
```

#### Data Initialization (Optional - for testing)
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class DataInitializer {
    
    private final PaymentOrderJpaRepository repository;
    
    @EventListener(ApplicationReadyEvent.class)
    public void loadSampleData() {
        if (repository.count() == 0) {
            log.info("Loading sample payment orders...");
            
            PaymentOrderEntity order1 = PaymentOrderEntity.builder()
                .paymentOrderReference("PO-2024-001")
                .payerReference("CUST-12345")
                .payeeReference("CUST-67890")
                .amount(new BigDecimal("1500.50"))
                .currency("USD")
                .paymentPurpose("Invoice payment")
                .paymentDate(LocalDate.now())
                .status(PaymentStatusEntity.INITIATED)
                .build();
            
            repository.save(order1);
            log.info("Sample data loaded successfully");
        }
    }
}
```

### 6. MapStruct Mappers (Three Layers)

MapStruct is used for clean transformation between layers. There are THREE types of mappers:

#### 1. REST Mapper (Adapter Layer: DTO ‚Üî Domain)
```java
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR)
public interface PaymentOrderRestMapper {
    
    // Request DTO ‚Üí Domain
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "paymentOrderReference", ignore = true)
    @Mapping(target = "status", constant = "INITIATED")
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    @Mapping(target = "updatedAt", ignore = true)
    PaymentOrder toDomain(InitiatePaymentOrderRequest request);
    
    // Domain ‚Üí Response DTO (Initiate)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    InitiatePaymentOrderResponse toInitiateResponse(PaymentOrder paymentOrder);
    
    // Domain ‚Üí Response DTO (Retrieve)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    RetrievePaymentOrderResponse toRetrieveResponse(PaymentOrder paymentOrder);
    
    // Domain ‚Üí Response DTO (Status)
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "status", target = "paymentOrderStatus")
    @Mapping(source = "updatedAt", target = "lastUpdated")
    PaymentOrderStatusResponse toStatusResponse(PaymentOrder paymentOrder);
    
    // Value Object mappings
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    PaymentAmount toPaymentAmount(com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount dtoAmount);
    
    @Mapping(source = "value", target = "value")
    @Mapping(source = "currency", target = "currency")
    com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount toPaymentAmountDto(PaymentAmount domainAmount);
}
```

#### 2. Persistence Mapper (Adapter Layer: Domain ‚Üî Entity)
```java
@Mapper(componentModel = "spring", 
        unmappedTargetPolicy = ReportingPolicy.ERROR,
        uses = {PaymentStatusMapper.class})
public interface PaymentOrderPersistenceMapper {
    
    // Domain ‚Üí Entity
    @Mapping(source = "id.value", target = "paymentOrderReference")
    @Mapping(source = "payerReference.value", target = "payerReference")
    @Mapping(source = "payeeReference.value", target = "payeeReference")
    @Mapping(source = "amount.value", target = "amount")
    @Mapping(source = "amount.currency", target = "currency")
    @Mapping(source = "status", target = "status")
    @Mapping(target = "id", ignore = true)  // Let JPA generate
    PaymentOrderEntity toEntity(PaymentOrder domain);
    
    // Entity ‚Üí Domain
    @Mapping(source = "paymentOrderReference", target = "id.value")
    @Mapping(source = "payerReference", target = "payerReference.value")
    @Mapping(source = "payeeReference", target = "payeeReference.value")
    @Mapping(source = "amount", target = "amount.value")
    @Mapping(source = "currency", target = "amount.currency")
    PaymentOrder toDomain(PaymentOrderEntity entity);
    
    // Custom mapping for status
    default PaymentStatus mapStatus(PaymentStatusEntity entityStatus) {
        return PaymentStatus.valueOf(entityStatus.name());
    }
    
    default PaymentStatusEntity mapStatus(PaymentStatus domainStatus) {
        return PaymentStatusEntity.valueOf(domainStatus.name());
    }
}
```

#### 3. Application Mapper (Optional: Complex transformations)
```java
@Mapper(componentModel = "spring")
public interface PaymentOrderApplicationMapper {
    
    // For complex business logic transformations
    @Mapping(target = "enrichedData", expression = "java(enrichData(source))")
    PaymentOrder enrichForProcessing(PaymentOrder source);
    
    default String enrichData(PaymentOrder order) {
        // Complex business logic here
        return "ENRICHED-" + order.getPaymentOrderReference();
    }
}
```

#### MapStruct Configuration Best Practices
```java
@MapperConfig(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.ERROR,  // Fail on unmapped fields
    unmappedSourcePolicy = ReportingPolicy.WARN,    // Warn on unmapped sources
    mappingInheritanceStrategy = MappingInheritanceStrategy.AUTO_INHERIT_FROM_CONFIG
)
public interface CentralMapperConfig {
}

// Then use it in mappers
@Mapper(config = CentralMapperConfig.class)
public interface PaymentOrderRestMapper {
    // ... mappings
}
```

#### Testing MapStruct Mappers
```java
@SpringBootTest
class PaymentOrderRestMapperTest {
    
    @Autowired
    private PaymentOrderRestMapper mapper;
    
    @Test
    @DisplayName("Should map InitiatePaymentOrderRequest to PaymentOrder domain")
    void shouldMapRequestToDomain() {
        // Given
        InitiatePaymentOrderRequest request = new InitiatePaymentOrderRequest()
            .payerReference("CUST-123")
            .payeeReference("CUST-456")
            .amount(new com.hiberus.banking.payment.adapter.in.rest.dto.PaymentAmount()
                .value(1000.0)
                .currency("USD"))
            .paymentPurpose("Test payment");
        
        // When
        PaymentOrder domain = mapper.toDomain(request);
        
        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getPayerReference().getValue()).isEqualTo("CUST-123");
        assertThat(domain.getPayeeReference().getValue()).isEqualTo("CUST-456");
        assertThat(domain.getAmount().getValue()).isEqualByComparingTo("1000.0");
        assertThat(domain.getAmount().getCurrency()).isEqualTo(Currency.USD);
        assertThat(domain.getStatus()).isEqualTo(PaymentStatus.INITIATED);
    }
    
    @Test
    @DisplayName("Should map PaymentOrder domain to InitiatePaymentOrderResponse")
    void shouldMapDomainToResponse() {
        // Given
        PaymentOrder domain = PaymentOrderMother.valid();
        
        // When
        InitiatePaymentOrderResponse response = mapper.toInitiateResponse(domain);
        
        // Then
        assertThat(response).isNotNull();
        assertThat(response.getPaymentOrderReference()).isEqualTo(domain.getId().getValue());
        assertThat(response.getPaymentOrderStatus()).isEqualTo(domain.getStatus().name());
    }
}
```

### 7. Testing Strategy with Spring MVC and WebTestClient

#### Unit Tests (Domain & Application Layer)
```java
@ExtendWith(MockitoExtension.class)
class InitiatePaymentOrderServiceTest {
    
    @Mock
    private PaymentOrderRepository repository;
    
    @Mock
    private PaymentValidationPort validationPort;
    
    @InjectMocks
    private InitiatePaymentOrderService service;
    
    @Test
    @DisplayName("Should initiate payment order when valid")
    void shouldInitiatePaymentOrderWhenValid() {
        // Given
        PaymentOrder order = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenReturn(order);
        
        // When
        PaymentOrder result = service.initiate(order);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getStatus()).isEqualTo(PaymentStatus.INITIATED);
        assertThat(result.getPaymentOrderReference()).isNotNull();
        
        verify(validationPort).validate(order);
        verify(repository).save(any(PaymentOrder.class));
    }
    
    @Test
    @DisplayName("Should throw InvalidPaymentException when validation fails")
    void shouldThrowExceptionWhenValidationFails() {
        // Given
        PaymentOrder order = PaymentOrderMother.withInvalidAmount();
        when(validationPort.validate(any())).thenReturn(false);
        
        // When & Then
        assertThatThrownBy(() -> service.initiate(order))
            .isInstanceOf(InvalidPaymentException.class)
            .hasMessageContaining("validation failed");
        
        verify(validationPort).validate(order);
        verify(repository, never()).save(any());
    }
    
    @Test
    @DisplayName("Should generate unique payment order reference")
    void shouldGenerateUniqueReference() {
        // Given
        PaymentOrder order1 = PaymentOrderMother.valid();
        PaymentOrder order2 = PaymentOrderMother.valid();
        when(validationPort.validate(any())).thenReturn(true);
        when(repository.save(any())).thenAnswer(inv -> inv.getArgument(0));
        
        // When
        PaymentOrder result1 = service.initiate(order1);
        PaymentOrder result2 = service.initiate(order2);
        
        // Then
        assertThat(result1.getPaymentOrderReference())
            .isNotEqualTo(result2.getPaymentOrderReference());
    }
}
```

#### Integration Tests with WebTestClient (Recommended for Spring MVC)
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class PaymentInitiationIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        repository.deleteAll();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 201 Created")
    void shouldInitiatePaymentOrderSuccessfully() {
        // Given
        InitiatePaymentOrderRequest request = InitiatePaymentOrderRequest.builder()
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1500.50)
                .currency("USD")
                .build())
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .build();
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .exchange()
            .expectStatus().isCreated()
            .expectHeader().exists("Location")
            .expectBody(InitiatePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getPaymentOrderReference()).startsWith("PO-");
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getPayeeReference()).isEqualTo("CUST-67890");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
                assertThat(response.getCreatedAt()).isNotNull();
            });
        
        // Verify database
        assertThat(repository.count()).isEqualTo(1);
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 200 OK")
    void shouldRetrievePaymentOrderSuccessfully() {
        // Given - Create a payment order first
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(RetrievePaymentOrderResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getPayerReference()).isEqualTo("CUST-12345");
                assertThat(response.getAmount().getValue()).isEqualTo(1500.50);
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id}/status - Should return 200 OK")
    void shouldRetrievePaymentOrderStatusSuccessfully() {
        // Given
        PaymentOrderEntity entity = createSampleEntity();
        PaymentOrderEntity saved = repository.save(entity);
        String reference = saved.getPaymentOrderReference();
        
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}/status", reference)
            .exchange()
            .expectStatus().isOk()
            .expectBody(PaymentOrderStatusResponse.class)
            .value(response -> {
                assertThat(response.getPaymentOrderReference()).isEqualTo(reference);
                assertThat(response.getPaymentOrderStatus()).isEqualTo("INITIATED");
                assertThat(response.getLastUpdated()).isNotNull();
            });
    }
    
    @Test
    @DisplayName("GET /payment-initiation/payment-orders/{id} - Should return 404 Not Found")
    void shouldReturn404WhenPaymentOrderNotFound() {
        // When & Then
        webTestClient.get()
            .uri("/payment-initiation/payment-orders/{id}", "NON-EXISTENT")
            .exchange()
            .expectStatus().isNotFound()
            .expectBody()
            .jsonPath("$.title").isEqualTo("Payment Order Not Found")
            .jsonPath("$.status").isEqualTo(404)
            .jsonPath("$.detail").exists();
    }
    
    @Test
    @DisplayName("POST /payment-initiation/payment-orders - Should return 400 Bad Request for invalid data")
    void shouldReturn400ForInvalidRequest() {
        // Given - Invalid request (missing required fields)
        String invalidRequest = """
            {
                "payerReference": "CUST-123"
            }
            """;
        
        // When & Then
        webTestClient.post()
            .uri("/payment-initiation/payment-orders")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(invalidRequest)
            .exchange()
            .expectStatus().isBadRequest()
            .expectBody()
            .jsonPath("$.title").exists()
            .jsonPath("$.status").isEqualTo(400);
    }
    
    @Test
    @DisplayName("Should handle concurrent payment order creation")
    void shouldHandleConcurrentCreation() throws Exception {
        // Given
        int numberOfThreads = 5;
        ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);
        CountDownLatch latch = new CountDownLatch(numberOfThreads);
        
        // When
        for (int i = 0; i < numberOfThreads; i++) {
            final int index = i;
            executorService.submit(() -> {
                try {
                    InitiatePaymentOrderRequest request = createRequest("PAYER-" + index);
                    webTestClient.post()
                        .uri("/payment-initiation/payment-orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(request)
                        .exchange()
                        .expectStatus().isCreated();
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(10, TimeUnit.SECONDS);
        executorService.shutdown();
        
        // Then
        assertThat(repository.count()).isEqualTo(numberOfThreads);
    }
    
    // Helper methods
    private PaymentOrderEntity createSampleEntity() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-TEST-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Test payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
    
    private InitiatePaymentOrderRequest createRequest(String payerRef) {
        return InitiatePaymentOrderRequest.builder()
            .payerReference(payerRef)
            .payeeReference("CUST-67890")
            .amount(PaymentAmountDto.builder()
                .value(1000.0)
                .currency("USD")
                .build())
            .paymentPurpose("Concurrent test")
            .build();
    }
}
```

#### Alternative: REST Assured for Integration Tests
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class PaymentInitiationRestAssuredTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @BeforeEach
    void setUp() {
        RestAssured.port = port;
        RestAssured.basePath = "/payment-initiation";
        repository.deleteAll();
    }
    
    @Test
    void shouldInitiatePaymentOrder() {
        given()
            .contentType(ContentType.JSON)
            .body(createValidRequest())
        .when()
            .post("/payment-orders")
        .then()
            .statusCode(201)
            .body("paymentOrderReference", notNullValue())
            .body("paymentOrderStatus", equalTo("INITIATED"))
            .body("amount.value", equalTo(1500.50f))
            .body("amount.currency", equalTo("USD"));
    }
    
    @Test
    void shouldRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity saved = repository.save(createSampleEntity());
        
        // When & Then
        given()
            .pathParam("id", saved.getPaymentOrderReference())
        .when()
            .get("/payment-orders/{id}")
        .then()
            .statusCode(200)
            .body("paymentOrderReference", equalTo(saved.getPaymentOrderReference()))
            .body("paymentOrderStatus", equalTo("INITIATED"));
    }
}
```

#### Test Data Builders (Object Mother Pattern)
```java
public class PaymentOrderMother {
    
    public static PaymentOrder valid() {
        return PaymentOrder.builder()
            .id(PaymentOrderId.generate())
            .payerReference(PayerReference.of("CUST-12345"))
            .payeeReference(PayeeReference.of("CUST-67890"))
            .amount(PaymentAmount.of(1500.50, Currency.USD))
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatus.INITIATED)
            .createdAt(LocalDateTime.now())
            .build();
    }
    
    public static PaymentOrder withInvalidAmount() {
        return valid().toBuilder()
            .amount(PaymentAmount.of(-100.00, Currency.USD))
            .build();
    }
    
    public static PaymentOrder withStatus(PaymentStatus status) {
        return valid().toBuilder()
            .status(status)
            .build();
    }
    
    public static PaymentOrder pending() {
        return withStatus(PaymentStatus.PENDING);
    }
    
    public static PaymentOrder completed() {
        return withStatus(PaymentStatus.COMPLETED);
    }
}

public class PaymentOrderEntityMother {
    
    public static PaymentOrderEntity valid() {
        return PaymentOrderEntity.builder()
            .paymentOrderReference("PO-2024-001")
            .payerReference("CUST-12345")
            .payeeReference("CUST-67890")
            .amount(new BigDecimal("1500.50"))
            .currency("USD")
            .paymentPurpose("Invoice payment")
            .paymentDate(LocalDate.now())
            .status(PaymentStatusEntity.INITIATED)
            .build();
    }
}
```

#### Repository Tests
```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class PaymentOrderJpaRepositoryTest {
    
    @Autowired
    private PaymentOrderJpaRepository repository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    @DisplayName("Should save and retrieve payment order")
    void shouldSaveAndRetrievePaymentOrder() {
        // Given
        PaymentOrderEntity entity = PaymentOrderEntityMother.valid();
        
        // When
        PaymentOrderEntity saved = repository.save(entity);
        entityManager.flush();
        entityManager.clear();
        
        // Then
        Optional<PaymentOrderEntity> found = repository.findByPaymentOrderReference(
            saved.getPaymentOrderReference()
        );
        
        assertThat(found).isPresent();
        assertThat(found.get().getPayerReference()).isEqualTo("CUST-12345");
        assertThat(found.get().getAmount()).isEqualByComparingTo("1500.50");
    }
    
    @Test
    @DisplayName("Should find payment orders by status")
    void shouldFindByStatus() {
        // Given
        repository.save(PaymentOrderEntityMother.valid());
        repository.save(PaymentOrderEntityMother.valid().toBuilder()
            .paymentOrderReference("PO-2024-002")
            .status(PaymentStatusEntity.COMPLETED)
            .build());
        entityManager.flush();
        
        // When
        List<PaymentOrderEntity> initiated = repository.findByStatus(PaymentStatusEntity.INITIATED);
        List<PaymentOrderEntity> completed = repository.findByStatus(PaymentStatusEntity.COMPLETED);
        
        // Then
        assertThat(initiated).hasSize(1);
        assertThat(completed).hasSize(1);
    }
}
```

### 8. Quality Gates (Mandatory - Gradle)

#### JaCoCo Configuration (Gradle)
```groovy
// build.gradle
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test
    
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                '**/dto/**',
                '**/entity/**',
                '**/config/**',
                '**/*Application.class',
                '**/*MapperImpl.class'  // Exclude MapStruct generated classes
            ])
        }))
    }
}

jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    
    violationRules {
        rule {
            limit {
                minimum = 0.80
            }
        }
        
        rule {
            element = 'CLASS'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.70
            }
            excludes = [
                '*.dto.*',
                '*.entity.*',
                '*.config.*',
                '*Application',
                '*MapperImpl'
            ]
        }
    }
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

check.dependsOn jacocoTestCoverageVerification
```

#### Checkstyle Configuration (Gradle)
```groovy
// build.gradle
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
    configProperties = [
        'checkstyle.suppressions.file': "${project.rootDir}/config/checkstyle/suppressions.xml"
    ]
}

checkstyleMain {
    source = 'src/main/java'
    exclude '**/dto/**', '**/entity/**'  // Exclude generated code
}

checkstyleTest {
    source = 'src/test/java'
}

tasks.withType(Checkstyle) {
    reports {
        xml.required = true
        html.required = true
    }
}
```

#### config/checkstyle/checkstyle.xml
```xml
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
    "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
    "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <property name="charset" value="UTF-8"/>
    <property name="severity" value="error"/>
    <property name="fileExtensions" value="java"/>
    
    <module name="SuppressionFilter">
        <property name="file" value="${checkstyle.suppressions.file}"/>
    </module>
    
    <module name="TreeWalker">
        <!-- Naming Conventions -->
        <module name="TypeName">
            <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="MethodName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <module name="ConstantName">
            <property name="format" value="^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"/>
        </module>
        
        <module name="LocalVariableName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        
        <!-- Code Style -->
        <module name="LeftCurly"/>
        <module name="RightCurly"/>
        <module name="NeedBraces"/>
        
        <module name="WhitespaceAround"/>
        <module name="NoWhitespaceBefore"/>
        
        <!-- Imports -->
        <module name="AvoidStarImport"/>
        <module name="UnusedImports"/>
        <module name="RedundantImport"/>
        
        <!-- Size Violations -->
        <module name="LineLength">
            <property name="max" value="120"/>
        </module>
        
        <module name="MethodLength">
            <property name="max" value="150"/>
        </module>
        
        <!-- Complexity -->
        <module name="CyclomaticComplexity">
            <property name="max" value="15"/>
        </module>
        
        <!-- Best Practices -->
        <module name="EmptyBlock"/>
        <module name="EqualsHashCode"/>
        <module name="SimplifyBooleanExpression"/>
        <module name="SimplifyBooleanReturn"/>
        
        <!-- Annotations -->
        <module name="MissingOverride"/>
    </module>
</module>
```

#### SpotBugs Configuration (Gradle)
```groovy
// build.gradle
spotbugs {
    effort = 'max'
    reportLevel = 'high'
    excludeFilter = file("${project.rootDir}/config/spotbugs/spotbugs-exclude.xml")
}

tasks.named('spotbugsMain') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/main/spotbugs.html")
        }
        xml {
            required = false
        }
    }
}

tasks.named('spotbugsTest') {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/test/spotbugs.html")
        }
    }
}
```

#### config/spotbugs/spotbugs-exclude.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<FindBugsFilter>
    <!-- Exclude generated code -->
    <Match>
        <Package name="~.*\.dto.*"/>
    </Match>
    
    <Match>
        <Package name="~.*\.entity.*"/>
    </Match>
    
    <Match>
        <Class name="~.*MapperImpl"/>
    </Match>
    
    <!-- Exclude specific bugs for Lombok -->
    <Match>
        <Bug pattern="EI_EXPOSE_REP,EI_EXPOSE_REP2"/>
        <Or>
            <Class name="~.*\.domain\.model\..*"/>
        </Or>
    </Match>
</FindBugsFilter>
```

#### Gradle Verification Tasks
```groovy
// Create custom task to run all quality checks
tasks.register('qualityCheck') {
    dependsOn 'checkstyleMain', 'checkstyleTest', 'spotbugsMain', 'jacocoTestCoverageVerification'
    description = 'Run all quality checks: Checkstyle, SpotBugs, and JaCoCo'
    group = 'verification'
}

// Make 'check' depend on quality checks
check {
    dependsOn 'qualityCheck'
}

// Gradle wrapper
wrapper {
    gradleVersion = '8.5'
    distributionType = Wrapper.DistributionType.ALL
}
```

#### Run Quality Checks
```bash
# Run all quality checks
./gradlew check

# Run individual checks
./gradlew checkstyleMain
./gradlew spotbugsMain
./gradlew test jacocoTestReport
./gradlew jacocoTestCoverageVerification

# Build with quality checks
./gradlew clean build

# Generate reports
./gradlew jacocoTestReport
# Report: build/reports/jacoco/test/html/index.html

./gradlew checkstyleMain
# Report: build/reports/checkstyle/main.html

./gradlew spotbugsMain
# Report: build/reports/spotbugs/main/spotbugs.html
```

### 8. Domain Modeling Best Practices

#### Value Objects
```java
@Value
@Builder
public class PaymentAmount {
    BigDecimal value;
    Currency currency;
    
    public static PaymentAmount of(double value, Currency currency) {
        if (value <= 0) {
            throw new InvalidPaymentException("Amount must be positive");
        }
        return new PaymentAmount(BigDecimal.valueOf(value), currency);
    }
}
```

#### Aggregates
```java
@Builder(toBuilder = true)
@Value
public class PaymentOrder {
    PaymentOrderId id;
    PayerReference payerReference;
    PayeeReference payeeReference;
    PaymentAmount amount;
    PaymentStatus status;
    LocalDateTime createdAt;
    
    // Business invariants
    public PaymentOrder validate() {
        if (status == PaymentStatus.CANCELLED && amount.getValue().compareTo(BigDecimal.ZERO) > 0) {
            throw new InvalidPaymentException("Cancelled orders cannot have positive amount");
        }
        return this;
    }
    
    public PaymentOrder markAsProcessed() {
        if (status != PaymentStatus.INITIATED) {
            throw new InvalidPaymentException("Only initiated orders can be processed");
        }
        return this.toBuilder().status(PaymentStatus.PROCESSED).build();
    }
}
```

#### Domain Events (if needed)
```java
@Value
public class PaymentOrderInitiatedEvent {
    String paymentOrderReference;
    PaymentAmount amount;
    LocalDateTime occurredOn;
}
```

### 9. Error Handling (RFC 7807)

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(PaymentOrderNotFoundException.class)
    public ResponseEntity<ProblemDetail> handleNotFound(PaymentOrderNotFoundException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, 
            ex.getMessage()
        );
        problem.setTitle("Payment Order Not Found");
        problem.setProperty("paymentOrderReference", ex.getPaymentOrderReference());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem);
    }
    
    @ExceptionHandler(InvalidPaymentException.class)
    public ResponseEntity<ProblemDetail> handleInvalidPayment(InvalidPaymentException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST,
            ex.getMessage()
        );
        problem.setTitle("Invalid Payment Order");
        problem.setProperty("validationErrors", ex.getErrors());
        return ResponseEntity.badRequest().body(problem);
    }
}
```

### 10. Docker Configuration with H2

#### Multi-stage Dockerfile (Gradle)
```dockerfile
# Build stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

# Copy Gradle files
COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .

# Copy source code
COPY src src
COPY config config

# Build application (skip tests for faster builds, tests run in CI/CD)
RUN ./gradlew clean build -x test --no-daemon

# Runtime stage
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Create non-root user for security
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# Copy JAR from builder
COPY --from=builder /app/build/libs/*.jar app.jar

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# JVM options
ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC -XX:+UseContainerSupport"

# Run application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

#### docker-compose.yml (H2 in-memory)
```yaml
version: '3.8'

services:
  payment-initiation-service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: payment-initiation-service
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - JAVA_OPTS=-Xms256m -Xmx512m
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - payment-network
    restart: unless-stopped

networks:
  payment-network:
    driver: bridge

# Optional: Add volumes for H2 file-based persistence
# volumes:
#   h2-data:
#     driver: local
```

#### application-docker.yml (For containerized H2)
```yaml
spring:
  application:
    name: payment-initiation-service
  
  # H2 with file persistence in Docker (optional)
  datasource:
    url: jdbc:h2:file:/app/data/paymentdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: true  # Allow access from outside container
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: false

server:
  port: 8080

logging:
  level:
    com.hiberus.banking: INFO
    org.springframework.web: WARN
```

#### Docker Commands
```bash
# Build image
docker build -t payment-initiation-service:latest .

# Run with docker-compose
docker-compose up -d

# View logs
docker-compose logs -f payment-initiation-service

# Stop services
docker-compose down

# Rebuild and restart
docker-compose up -d --build

# Access H2 Console (if enabled)
# URL: http://localhost:8080/h2-console
# JDBC URL: jdbc:h2:mem:paymentdb
# Username: sa
# Password: (empty)

# Health check
curl http://localhost:8080/actuator/health

# Test API
curl -X POST http://localhost:8080/payment-initiation/payment-orders \
  -H "Content-Type: application/json" \
  -d '{
    "payerReference": "CUST-123",
    "payeeReference": "CUST-456",
    "amount": {
      "value": 1500.50,
      "currency": "USD"
    },
    "paymentPurpose": "Invoice payment"
  }'
```

#### .dockerignore
```
.git
.gitignore
.gradle
build/
!build/libs/*.jar
*.md
.idea
*.iml
.vscode
target/
*.log
```

#### Alternative: Dockerfile with tests included
```dockerfile
# Build and test stage
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app

COPY gradle gradle
COPY gradlew .
COPY build.gradle .
COPY settings.gradle .
COPY config config
COPY src src

# Run tests and build
RUN ./gradlew clean build --no-daemon

# Runtime stage (same as before)
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

COPY --from=builder /app/build/libs/*.jar app.jar

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

ENV JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 11. AI-Assisted Development Documentation

#### Structure for ai/ folder
```
ai/
‚îú‚îÄ‚îÄ prompts.md                 # All prompts used
‚îú‚îÄ‚îÄ decisions.md              # Architectural decisions and rationale
‚îî‚îÄ‚îÄ generations/              # Generated code samples
    ‚îú‚îÄ‚îÄ openapi-draft.yaml
    ‚îú‚îÄ‚îÄ domain-skeleton.java
    ‚îî‚îÄ‚îÄ test-generation.java
```

#### Example prompts.md format
```markdown
## Prompt 1: WSDL Analysis
**Prompt**: "Analyze this WSDL for PaymentOrderService and map to BIAN Payment Initiation Service Domain. Identify: operations, data structures, business rules, and status flows."

**Response Summary**: 
- SOAP operations: createPaymentOrder, getPaymentOrder, updateOrderStatus
- Mapped to BIAN: Initiate, Retrieve, Execute
- Key fields: orderId ‚Üí paymentOrderReference, amount, payer/payee, status

**Manual Corrections**:
- Changed generic "orderId" to BIAN-compliant "paymentOrderReference"
- Added currency field (was missing in WSDL)
- Refined status enum to align with BIAN lifecycle

## Prompt 2: OpenAPI Generation
[...]
```

### 12. Code Style & Conventions

#### Naming Conventions
- **Classes**: PascalCase (e.g., `PaymentOrder`, `InitiatePaymentOrderService`)
- **Methods**: camelCase, verb-based (e.g., `initiatePayment`, `retrieveOrderStatus`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_PAYMENT_AMOUNT`)
- **Packages**: lowercase, domain-driven (e.g., `domain.model`, `adapter.in.rest`)

#### BIAN-Specific Conventions
- Prefix interfaces with use case: `InitiatePaymentOrderUseCase`
- Use "Reference" suffix for IDs: `paymentOrderReference`, `payerReference`
- Status naming: Use BIAN lifecycle terms (INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED)

#### Lombok Usage
```java
@Value                    // For immutable value objects
@Builder(toBuilder=true) // For entities with many fields
@RequiredArgsConstructor // For dependency injection
@Slf4j                   // For logging
```

### 13. Observability & Production Readiness

#### Actuator Configuration
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    tags:
      application: payment-initiation-service
      service-domain: payment-initiation
```

#### Custom Metrics
```java
@Component
@RequiredArgsConstructor
public class PaymentMetrics {
    
    private final MeterRegistry registry;
    
    public void recordPaymentInitiated(PaymentAmount amount) {
        registry.counter("payment.initiated", 
            "currency", amount.getCurrency().toString())
            .increment();
        
        registry.summary("payment.amount")
            .record(amount.getValue().doubleValue());
    }
}
```

#### Logging Best Practices
```java
// Structured logging
log.info("Payment order initiated", 
    kv("paymentOrderReference", order.getId()),
    kv("amount", order.getAmount().getValue()),
    kv("status", order.getStatus()));

// Never log sensitive data (PII)
// Use correlation IDs for tracing
```

### 14. Security Considerations

- Validate all inputs at adapter layer
- Use Bean Validation annotations in DTOs
- Implement idempotency using `Idempotency-Key` header
- Add rate limiting for endpoints
- Sanitize error messages (don't expose internal details)

### 15. Documentation Requirements

#### README.md Must Include
1. **Project Overview**: BIAN SD, migration context
2. **Architecture Decision Records (ADRs)**: Why hexagonal, why reactive
3. **Setup Instructions**: Prerequisites, local run, Docker
4. **API Documentation**: Link to Swagger UI, example requests
5. **Testing**: How to run tests, coverage reports
6. **AI Usage**: Summary of prompts and generated code
7. **Quality Gates**: Checkstyle, SpotBugs, JaCoCo results

## Validation Checklist

Before committing code, ensure:
- [ ] Follows hexagonal architecture (no Spring in domain)
- [ ] OpenAPI contract-first approach used (interfaces generated)
- [ ] All BIAN naming conventions followed (payment-initiation, PaymentOrder BQ)
- [ ] MapStruct mappers configured correctly (3 layers: REST, Persistence, Application)
- [ ] Unit tests written for domain and application layers (80%+ coverage)
- [ ] Integration tests with WebTestClient for all endpoints
- [ ] Repository tests for JPA layer
- [ ] `./gradlew check` passes (Checkstyle, SpotBugs, JaCoCo)
- [ ] H2 database configured correctly (in-memory or file-based)
- [ ] Dockerfile builds successfully (`docker build -t payment-service .`)
- [ ] docker-compose up works (`docker-compose up -d`)
- [ ] All endpoints return correct HTTP status codes (201, 200, 404, 400, 500)
- [ ] RFC 7807 error handling implemented (application/problem+json)
- [ ] AI usage documented in ai/ folder (prompts.md, decisions.md, generations/)
- [ ] README updated with setup instructions and API documentation
- [ ] Actuator endpoints exposed for health checks
- [ ] Logging configured appropriately (no sensitive data)
- [ ] Value objects are immutable (Lombok @Value)
- [ ] No framework dependencies in domain layer
- [ ] All exceptions properly handled in GlobalExceptionHandler

## Additional Gradle Commands

```bash
# Clean build
./gradlew clean build

# Run with quality checks
./gradlew clean build check

# Run only tests
./gradlew test

# Generate coverage report
./gradlew test jacocoTestReport
# Open: build/reports/jacoco/test/html/index.html

# Run checkstyle only
./gradlew checkstyleMain checkstyleTest

# Run spotbugs only
./gradlew spotbugsMain spotbugsTest

# Build without tests (faster for development)
./gradlew clean build -x test

# Run application locally
./gradlew bootRun

# Generate OpenAPI code
./gradlew openApiGenerate

# View project dependencies
./gradlew dependencies

# View available tasks
./gradlew tasks
```

## Remember
- **BIAN alignment is non-negotiable**: Always validate against BIAN standards
- **Domain purity**: Keep domain layer framework-agnostic
- **Test-first mindset**: Write tests before implementation
- **Document AI usage**: Every AI-generated code must be reviewed and documented
- **Quality over speed**: Meet all quality gates before considering "done"

---

When in doubt, ask yourself: "Does this align with BIAN Payment Initiation Service Domain standards?" and "Is this following hexagonal architecture principles?"

===== /mnt/data/prompt_v3.txt =====
## Plan de Implementaci√≥n: Microservicio Payment Initiation (BIAN Hexagonal)

Este plan detalla los pasos exactos para la creaci√≥n del microservicio, cumpliendo con todos los requisitos del documento t√©cnico (Java 17+, Spring Boot 3+, Contract-First, Arquitectura Hexagonal, BIAN, Calidad, Docker).

---

### FASE 1: An√°lisis y Definici√≥n del Contrato (Contract-First / BIAN)

#### 1.1. An√°lisis del WSDL y Mapping BIAN (IA Prompt)

// PROMPT PARA IA (Paso 1.1)

Act√∫a como un arquitecto de software experto en BIAN. Analiza el siguiente WSDL y los ejemplos de mensajes SOAP.
1. Resume las dos operaciones SOAP principales: `SubmitPaymentOrder` y `GetPaymentOrderStatus`.
2. Para cada una, identifica los campos clave de entrada y salida (`externalId`, `debtorIban`, `amount`, `status`, `lastUpdate`, etc.).
3. Prop√≥n un mapeo directo de estos campos al Service Domain BIAN 'Payment Initiation' (BQ: PaymentOrder). Indica qu√© campos SOAP se agrupar√≠an en objetos BIAN (como `instructedAmount` o `debtorAccount`).

---

#### 1.2. Generaci√≥n del Borrador `openapi.yaml` (IA Prompt)

// PROMPT PARA IA (Paso 1.2)

Usando el mapeo BIAN que acabas de definir (PaymentOrder BQ), genera el borrador completo de un archivo `openapi.yaml` (OpenAPI 3.0) que defina los tres endpoints REST requeridos:
1. `POST /payment-initiation/payment-orders` (Mapea a SubmitPaymentOrderRequest).
2. `GET /payment-initiation/payment-orders/{id}` (Consulta completa de la orden).
3. `GET /payment-initiation/payment-orders/{id}/status` (Consulta de estado, mapea a GetPaymentOrderStatusResponse).
Aseg√∫rate de definir todos los schemas necesarios (`PaymentOrderInitiationRequest`, `Account`, `Amount`, `PaymentOrderStatus`, etc.) con sus propiedades y tipos de datos (string, number, date/date-time).

---

#### 1.3. y 1.4. Revisi√≥n Manual y Configuraci√≥n Maven

// TAREA MANUAL (Paso 1.3): Revisar y refinar el `openapi.yaml` generado por la IA.
// Aseg√∫rate de que los tipos (`date`, `float`) y la estructura BIAN (`debtorAccount`, `instructedAmount`) sean correctos.

// TAREA: Configurar el pom.xml (Paso 1.4)
// 1. Agregar dependencias: spring-boot-starter-web (o webflux), lombok, y springdoc-openapi-starter-webmvc-ui (para Swagger).
// 2. Configurar el plugin 'openapi-generator-maven-plugin':
//    - Generador: 'spring' (o 'spring-boot').
//    - 'interfaceOnly=true'.
//    - Paquete de interfaces: com.hiberus.payment.initiation.api
//    - Paquete de modelos/DTOs: com.hiberus.payment.initiation.model
// 3. Agregar los plugins de calidad: 'jacoco-maven-plugin' (cobertura >= 80%), 'maven-checkstyle-plugin', 'spotbugs-maven-plugin'.

---

### FASE 2: Configuraci√≥n de Proyecto y Estructura Hexagonal

#### 2.1. Estructura de Paquetes

// TAREA: Crear la estructura de paquetes central del proyecto (com.hiberus.payment.initiation)
// Esto define la Arquitectura Hexagonal.

com.hiberus.payment.initiation
‚îú‚îÄ‚îÄ domain               // L√≥gica de Negocio Pura (Entidades, Reglas, Invariantes)
‚îÇ   ‚îú‚îÄ‚îÄ model            // PaymentOrder, Account, Amount, PaymentOrderCommand, PaymentOrderStatus
‚îÇ   ‚îî‚îÄ‚îÄ service          // PaymentOrderDomainService
‚îú‚îÄ‚îÄ application          // Casos de Uso (Orquestaci√≥n)
‚îÇ   ‚îî‚îÄ‚îÄ service          // PaymentOrderApplicationService (Implementa el Driving Port)
‚îú‚îÄ‚îÄ port                 // Contratos (Interfaces)
‚îÇ   ‚îú‚îÄ‚îÄ driving          // PaymentOrderServicePort (Llamado por el Controller)
‚îÇ   ‚îî‚îÄ‚îÄ driven           // PaymentOrderPersistencePort, LegacySystemPort (Llamado por la Aplicaci√≥n)
‚îî‚îÄ‚îÄ adapter              // Implementaciones T√©cnicas
    ‚îú‚îÄ‚îÄ in               // PaymentOrderControllerAdapter (Implementa la interfaz generada)
    ‚îî‚îÄ‚îÄ out              // PaymentOrderPersistenceAdapter (Ej. R2DBC/JPA Repo), LegacySystemAdapter (Mock/SOAP Client)

---

### FASE 3: Implementaci√≥n del Dominio y Puertos

#### 3.1. Dominio (Modelo de Negocio BIAN)

// TAREA: Implementar las clases de Dominio (Paso 3.1)

// domain/model/PaymentOrder.java (Entidad principal)
// Incluir PaymentOrderId, externalReference, debtorAccount, creditorAccount, instructedAmount, remittanceInformation, requestedExecutionDate, status, lastUpdate. Usar Value Objects (Account, Amount).

// domain/model/Account.java (Value Object BIAN)
// Propiedad: String iban.

// domain/model/Amount.java (Value Object BIAN)
// Propiedades: BigDecimal amount, String currency.

// domain/service/PaymentOrderDomainService.java
// Contiene la l√≥gica para validar el estado o reglas de negocio (ej. 'validateCreation(PaymentOrder order)').

#### 3.2. Puertos

// TAREA: Implementar las interfaces de Puerto (Paso 3.2)

// port/driving/PaymentOrderServicePort.java (Interfaz de la Capa de Aplicaci√≥n)
public interface PaymentOrderServicePort {
    PaymentOrder submitOrder(PaymentOrderCommand command);
    PaymentOrder retrieveOrder(String id);
    PaymentOrderStatus retrieveOrderStatus(String id);
}

// port/driven/PaymentOrderPersistencePort.java (Interfaz de Persistencia)
public interface PaymentOrderPersistencePort {
    PaymentOrder save(PaymentOrder order);
    Optional<PaymentOrder> findById(String id);
}

---

### FASE 4: L√≥gica de Aplicaci√≥n y Adaptadores

#### 4.1. Capa de Aplicaci√≥n

// TAREA: Implementar el Service de Aplicaci√≥n (Paso 4.1)
// application/service/PaymentOrderApplicationService.java
// Implementa PaymentOrderServicePort. Usa @Transactional y orquesta:
// 1. Llama a DomainService para validaci√≥n.
// 2. Persiste la nueva orden usando PaymentOrderPersistencePort.
// 3. Llama a LegacySystemPort si es necesario para sincronizaci√≥n.

#### 4.2. Adaptador de Entrada (Controller)

// TAREA: Implementar el Driving Adapter (Paso 4.2)
// adapter/in/PaymentOrderControllerAdapter.java
// 1. Implementa la interfaz generada: `PaymentOrderApi`.
// 2. Usa un Mapper (manual o MapStruct) para convertir Request DTO (del modelo generado) a PaymentOrderCommand (del modelo de Dominio).
// 3. Llama a `paymentOrderServicePort`.
// 4. Mapea el resultado (PaymentOrder de Dominio) a Response DTO y retorna `ResponseEntity`.

#### 4.3. Adaptador de Salida (Mock/Persistencia)

// TAREA: Implementar un Mock de Persistencia (Paso 4.3)
// adapter/out/PaymentOrderPersistenceAdapter.java
// Implementa PaymentOrderPersistencePort.
// *Para la prueba inicial, usar un Map/ConcurrentHashMap como mock de base de datos.*

---

### FASE 5: Pruebas y Operacionalizaci√≥n (DevOps)

#### 5.1. Generaci√≥n de Tests (IA Prompt)

// PROMPT PARA IA (Paso 5.1)

Genera el c√≥digo completo de las siguientes clases de prueba, usando JUnit 5, Mockito y AssertJ:
1. Una prueba unitaria (`PaymentOrderDomainServiceTest`) que cubra la regla de negocio: si el monto instruido es negativo, debe lanzar una excepci√≥n.
2. Una prueba de integraci√≥n E2E (`PaymentOrderE2ETest`) usando `WebTestClient` (o `RestAssured`). Esta prueba debe hacer un `POST` exitoso a `/payment-initiation/payment-orders` (verificando status 201) y luego un `GET` a `/payment-initiation/payment-orders/{id}` usando el ID retornado (verificando status 200).
Aseg√∫rate de incluir las anotaciones y la configuraci√≥n necesarias de Spring Boot Test.

---

#### 5.2. Calidad y Docker

// TAREA: Ejecutar Pruebas y Generar Reporte de Cobertura (Paso 5.2)
// Comando para verificar cobertura y calidad: `mvn clean verify`
// *El desarrollo debe iterar hasta obtener JaCoCo >= 80% y no tener fallos de Checkstyle/SpotBugs.*

// TAREA: Crear Dockerfile (Paso 5.3)
// Crear un Dockerfile multi-stage (builder stage con JDK 17, runtime stage con JRE 17).

// TAREA: Crear docker-compose.yml (Paso 5.4)
// Definir un servicio simple para el microservicio Payment Initiation.

---

### FASE 6: Documentaci√≥n y Entrega

// TAREA: Crear el README.md (Paso 6.1)
// Incluir: Contexto de migraci√≥n a BIAN/REST, Pasos de ejecuci√≥n local y con Docker.

// TAREA: Carpeta 'ai' con Prompts y Decisiones (Paso 6.2 y 6.3)
// ai/prompts.md: Copiar los prompts usados en las Fases 1 y 5.
// ai/generations/decisions.md: Documentar las correcciones manuales hechas al `openapi.yaml` generado por la IA y la justificaci√≥n BIAN/funcional.

===== /mnt/data/prompt_v4.txt =====
1. Contexto del proyecto
	‚Ä¢	Un banco est√° migrando servicios SOAP legados a microservicios REST alineados con el est√°ndar BIAN.
	‚Ä¢	Para la prueba se toma el servicio SOAP de √≥rdenes de pago (PaymentOrder) como punto de partida.  Ôøº
	‚Ä¢	El WSDL y los XML de ejemplo sirven solo para an√°lisis, no para exponer SOAP nuevamente.  Ôøº

Objetivo: dise√±ar e implementar un microservicio REST (contract-first, hexagonal) para el Service Domain ‚ÄúPayment Initiation‚Äù ‚Äì BQ PaymentOrder, que reemplace funcionalmente al servicio SOAP legado.

‚∏ª

2. Funcionalidades REST obligatorias

Seg√∫n el enunciado y el Postman:
	1.	POST /payment-initiation/payment-orders
	‚Ä¢	Acci√≥n: Initiate PaymentOrder.
	‚Ä¢	Cuerpo de ejemplo (Postman):
		
		
		{
  "externalReference": "EXT-1",
  "debtorAccount": { "iban": "EC12DEBTOR" },
  "creditorAccount": { "iban": "EC98CREDITOR" },
  "instructedAmount": { "amount": 150.75, "currency": "USD" },
  "remittanceInformation": "Factura 001-123",
  "requestedExecutionDate": "2025-10-31"
}
‚Ä¢	Conceptualmente debe:
	‚Ä¢	Validar el request (IBAN, amount > 0, moneda, fecha, etc.).
	‚Ä¢	Crear una PaymentOrder en el dominio con un paymentOrderId interno.
	‚Ä¢	Asignar un estado inicial (por ej. INITIATED o PENDING).
	‚Ä¢	Devolver datos de la orden (id, estado, etc.).

	2.	GET /payment-initiation/payment-orders/{id}
	‚Ä¢	Acci√≥n: Retrieve PaymentOrder.
	‚Ä¢	Devuelve el detalle completo de la orden de pago (similar a lo enviado en el POST + estado, timestamps, etc.).
	3.	GET /payment-initiation/payment-orders/{id}/status
	‚Ä¢	Acci√≥n: Retrieve PaymentOrder Status.
	‚Ä¢	Devuelve una vista reducida: paymentOrderId, status, lastUpdate (alineado con el WSDL legado).

‚∏ª

3. An√°lisis del legado SOAP (WSDL ‚Üí BIAN)

Del WSDL de PaymentOrderService vemos dos operaciones principales:
	‚Ä¢	SubmitPaymentOrder
	‚Ä¢	Request:
	‚Ä¢	externalId : string
	‚Ä¢	debtorIban : string
	‚Ä¢	creditorIban : string
	‚Ä¢	amount : decimal
	‚Ä¢	currency : string
	‚Ä¢	remittanceInfo : string (opcional)
	‚Ä¢	requestedExecutionDate : date
	‚Ä¢	Response:
	‚Ä¢	paymentOrderId : string
	‚Ä¢	status : string
	‚Ä¢	GetPaymentOrderStatus
	‚Ä¢	Request:
	‚Ä¢	paymentOrderId : string
	‚Ä¢	Response:
	‚Ä¢	paymentOrderId : string
	‚Ä¢	status : string
	‚Ä¢	lastUpdate : dateTime

Mapeo conceptual SOAP ‚Üí BIAN REST

Al alinear con BIAN Payment Initiation / PaymentOrder, el mapeo t√≠pico ser√≠a:
	‚Ä¢	externalId ‚Üí externalReference
	‚Ä¢	debtorIban ‚Üí debtorAccount.iban
	‚Ä¢	creditorIban ‚Üí creditorAccount.iban
	‚Ä¢	amount + currency ‚Üí instructedAmount.amount, instructedAmount.currency
	‚Ä¢	remittanceInfo ‚Üí remittanceInformation
	‚Ä¢	requestedExecutionDate ‚Üí requestedExecutionDate
	‚Ä¢	paymentOrderId ‚Üí paymentOrderId (id interno BQ PaymentOrder)
	‚Ä¢	status ‚Üí status (dominio PaymentOrder: INITIATED, ACCEPTED, REJECTED, EXECUTED, FAILED, etc.)
	‚Ä¢	lastUpdate ‚Üí lastStatusUpdate o similar

La responsabilidad clave es que el nuevo contrato REST refleje el lenguaje BIAN (Payment Initiation / PaymentOrder) pero mantenga la informaci√≥n funcional que el SOAP ya expon√≠a.

‚∏ª

4. Modelo de dominio (visi√≥n de arquitecto)

Propuesta de entidad de dominio PaymentOrder:
	‚Ä¢	paymentOrderId (identificador interno, p.ej. PO-0001)
	‚Ä¢	externalReference
	‚Ä¢	debtorAccount (value object con iban)
	‚Ä¢	creditorAccount (value object con iban)
	‚Ä¢	instructedAmount (value object con amount, currency)
	‚Ä¢	remittanceInformation
	‚Ä¢	requestedExecutionDate
	‚Ä¢	status (enum controlado)
	‚Ä¢	creationDate
	‚Ä¢	lastUpdate

Opcionalmente:
	‚Ä¢	Invariantes de dominio:
	‚Ä¢	amount > 0
	‚Ä¢	currency permitida (p.ej. USD)
	‚Ä¢	requestedExecutionDate ‚â• hoy (seg√∫n reglas de negocio)
	‚Ä¢	Reglas BIAN:
	‚Ä¢	Estados v√°lidos y transiciones permitidas (por ejemplo, no pasar de REJECTED a EXECUTED).

‚∏ª

5. Arquitectura esperada: Hexagonal + Contract-first

El enunciado pide expl√≠citamente:
	‚Ä¢	Java 17+
	‚Ä¢	Spring Boot 3+
	‚Ä¢	Contract-first con OpenAPI 3.0 (usar openapi-generator)
	‚Ä¢	Arquitectura hexagonal (dominio, aplicaci√≥n, puertos, adaptadores, config)

Capas propuestas
	1.	Dominio
	‚Ä¢	Entidad PaymentOrder, value objects (Account, Money, etc.).
	‚Ä¢	Enum PaymentOrderStatus.
	‚Ä¢	Servicios de dominio (si hay reglas complejas).
	2.	Aplicaci√≥n (casos de uso)
	‚Ä¢	Casos de uso:
	‚Ä¢	InitiatePaymentOrderUseCase
	‚Ä¢	RetrievePaymentOrderUseCase
	‚Ä¢	RetrievePaymentOrderStatusUseCase
	‚Ä¢	Puertos (interfaces) hacia fuera:
	‚Ä¢	PaymentOrderRepository (persistencia)
	‚Ä¢	(Opcional) CoreBankingClient si se quiere simular u orquestar con otros sistemas.
	3.	Adaptadores / Infraestructura
	‚Ä¢	REST Controller: implementa las interfaces generadas por OpenAPI (payment-orders API).
	‚Ä¢	Mapper entre DTOs (OpenAPI) ‚Üî modelos de dominio.
	‚Ä¢	Persistencia:
	‚Ä¢	Puede ser en memoria para la prueba, o JPA/R2DBC si se quiere ir m√°s lejos.
	‚Ä¢	Configuraci√≥n (Spring config, bean definitions).

La idea de contract-first es:
	1.	Dise√±ar openapi.yaml alineado a BIAN (paths, schemas, responses).
	2.	Usar openapi-generator para generar:
	‚Ä¢	Interfaces de controller (por ej. PaymentOrdersApi).
	‚Ä¢	Modelos DTO.
	3.	Implementar las interfaces generadas en la capa de adaptadores, delegando en los casos de uso.

‚∏ª

6. Requisitos t√©cnicos y de calidad

Del documento:

Mandatorios
	‚Ä¢	Java 17+
	‚Ä¢	Spring Boot 3+
	‚Ä¢	OpenAPI 3.0 + openapi-generator (contract-first)
	‚Ä¢	Arquitectura hexagonal
	‚Ä¢	Pruebas
	‚Ä¢	Unitarias: JUnit 5, AssertJ, Mockito.
	‚Ä¢	Integraci√≥n: WebTestClient o RestAssured.
	‚Ä¢	Calidad
	‚Ä¢	JaCoCo con ‚â• 80% de cobertura (l√≠neas).
	‚Ä¢	Checkstyle.
	‚Ä¢	SpotBugs.
	‚Ä¢	Docker
	‚Ä¢	Dockerfile (multi-stage).
	‚Ä¢	docker-compose m√≠nimo para levantar el servicio.
	‚Ä¢	Uso asistido de IA
	‚Ä¢	Evidencias en carpeta ai/:
	‚Ä¢	prompts.md
	‚Ä¢	generations/
	‚Ä¢	decisions.md
	‚Ä¢	Explicar correcciones manuales hechas sobre lo generado por IA.

Opcionales (Nice to have)
	‚Ä¢	Spring WebFlux (reactivo) en lugar de MVC.
	‚Ä¢	Persistencia reactiva con R2DBC + Testcontainers.
	‚Ä¢	Manejo de errores RFC 7807 (application/problem+json).
	‚Ä¢	Observabilidad (Micrometer/Actuator).
	‚Ä¢	Idempotencia.
	‚Ä¢	Validaciones robustas (Bean Validation, etc.).

‚∏ª

7. Entregables esperados

Seg√∫n el enunciado:  Ôøº
	1.	Repositorio (URL).
	2.	README con:
	‚Ä¢	Contexto y decisiones de dise√±o.
	‚Ä¢	Pasos para ejecutar local y con Docker.
	‚Ä¢	Secci√≥n de uso de IA: prompts, res√∫menes de respuestas, fragmentos generados, correcciones humanas.
	3.	Archivo OpenAPI (.yml) con el contrato.
	4.	Pruebas unitarias + E2E, con reporte de cobertura ‚â• 80%.
	5.	Calidad:
	‚Ä¢	mvn verify sin errores de Checkstyle ni SpotBugs.
	6.	Docker:
	‚Ä¢	Dockerfile multi-stage.
	‚Ä¢	docker-compose.yml.
	7.	Evidencias de IA:
	‚Ä¢	Carpeta ai/ con la documentaci√≥n indicada.

‚∏ª

8. En resumen, ¬øqu√© se tiene que realizar?

T√∫, como desarrollador/arquitecto, debes:
	1.	Analizar el WSDL y los XML para entender:
	‚Ä¢	Datos de entrada/salida.
	‚Ä¢	Estados y campos relevantes de la orden de pago.
	2.	Dise√±ar un contrato OpenAPI 3.0 alineado con BIAN Payment Initiation / PaymentOrder:
	‚Ä¢	Paths:
	‚Ä¢	POST /payment-initiation/payment-orders
	‚Ä¢	GET /payment-initiation/payment-orders/{id}
	‚Ä¢	GET /payment-initiation/payment-orders/{id}/status
	‚Ä¢	Schemas BIAN-friendly.
	3.	Generar c√≥digo a partir del OpenAPI (openapi-generator).
	4.	Implementar el microservicio en Spring Boot 3 (Java 17) con arquitectura hexagonal, respetando el contract-first.
	5.	Implementar pruebas y calidad (JUnit, WebTestClient/RestAssured, JaCoCo, Checkstyle, SpotBugs) alcanzando los umbrales.
	6.	Empaquetar en Docker + docker-compose.
	7.	Documentar el uso de IA en el proceso (prompts, decisiones, correcciones).

===== /mnt/data/postman_collection.json =====
{
  "info": {
    "name": "Payment Initiation - PaymentOrder (BIAN)",
    "_postman_id": "f0b12345-6789-4abc-def0-111213141516",
    "description": "Colecci√≥n m√≠nima para validar el microservicio migrado (sin SOAP).",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "POST Initiate PaymentOrder",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "http://localhost:8080/payment-initiation/payment-orders",
          "protocol": "http",
          "host": [
            "localhost"
          ],
          "port": "8080",
          "path": [
            "payment-initiation",
            "payment-orders"
          ]
        },
        "body": {
          "mode": "raw",
          "raw": "{\n  \"externalReference\": \"EXT-1\",\n  \"debtorAccount\": { \"iban\": \"EC12DEBTOR\" },\n  \"creditorAccount\": { \"iban\": \"EC98CREDITOR\" },\n  \"instructedAmount\": { \"amount\": 150.75, \"currency\": \"USD\" },\n  \"remittanceInformation\": \"Factura 001-123\",\n  \"requestedExecutionDate\": \"2025-10-31\"\n}"
        }
      }
    },
    {
      "name": "GET Retrieve PaymentOrder",
      "request": {
        "method": "GET",
        "url": {
          "raw": "http://localhost:8080/payment-initiation/payment-orders/PO-0001",
          "protocol": "http",
          "host": [
            "localhost"
          ],
          "port": "8080",
          "path": [
            "payment-initiation",
            "payment-orders",
            "PO-0001"
          ]
        }
      }
    },
    {
      "name": "GET Retrieve PaymentOrder Status",
      "request": {
        "method": "GET",
        "url": {
          "raw": "http://localhost:8080/payment-initiation/payment-orders/PO-0001/status",
          "protocol": "http",
          "host": [
            "localhost"
          ],
          "port": "8080",
          "path": [
            "payment-initiation",
            "payment-orders",
            "PO-0001",
            "status"
          ]
        }
      }
    }
  ]
}

===== /mnt/data/TechnicalTest_Banking-Java.pdf =====
