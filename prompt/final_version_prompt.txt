

===== /mnt/data/prompt_v1.txt =====
BIAN PAYMENT INITIATION ‚Äì CURSOR PRO PLAYBOOK (JAVA 21)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

NOTA IMPORTANTE: Este playbook ha sido refinado y ajustado bas√°ndose en la implementaci√≥n 
exitosa del challenge. Incluye todas las correcciones y mejoras identificadas durante el 
desarrollo, incluyendo soluciones a problemas comunes con SpotBugs, MapStruct, Checkstyle, 
JaCoCo y configuraci√≥n de Docker.

Versi√≥n: 1.4 (Refinada post-implementaci√≥n completa con todas las lecciones aprendidas)
√öltima actualizaci√≥n: Diciembre 2024

MEJORAS EN ESTA VERSI√ìN:
- ‚úÖ Gu√≠a completa y detallada sobre orden de imports en Checkstyle (PASO 0 y PASO 14)
- ‚úÖ Ejemplos concretos de orden correcto e incorrecto de imports con c√≥digo completo
- ‚úÖ Instrucciones mejoradas sobre manejo de logs completos (sin grep/tail)
- ‚úÖ Soluciones detalladas para errores comunes de ImportOrder con mensajes espec√≠ficos
- ‚úÖ Verificaci√≥n paso a paso antes de continuar al siguiente paso
- ‚úÖ Advertencias sobre IBANs en tests (deben cumplir minLength: 15 de OpenAPI)
- ‚úÖ Ejemplos actualizados en Postman collection con IBANs v√°lidos
- ‚úÖ PASO 8 expandido y mejorado: especifica claramente que la persistencia DEBE completarse completamente (entidad, repositorio, mapper, adaptador)
- ‚úÖ Advertencias cr√≠ticas sobre dependencias entre pasos (persistencia antes de tests de integraci√≥n)
- ‚úÖ Instrucciones de verificaci√≥n obligatorias despu√©s del PASO 8
- ‚úÖ Ejemplos de c√≥digo completos para PaymentOrderRepositoryAdapter y PaymentOrderReferenceGenerator
- ‚úÖ Correcci√≥n cr√≠tica: PaymentOrderReferenceGenerator debe generar IDs num√©ricos (^PO-[0-9]+$) seg√∫n OpenAPI, no UUIDs
- ‚úÖ Instrucciones para tests adicionales necesarios para alcanzar 85% de cobertura (PASO 12 y PASO 14)
- ‚úÖ Advertencias sobre fechas en tests (deben ser futuras para pasar validaci√≥n del dominio)
- ‚úÖ Instrucciones mejoradas sobre manejo de actualizaciones en PaymentOrderRepositoryAdapter (preservar ID)
- ‚úÖ Correcci√≥n de maxWarnings en Checkstyle (100 en lugar de 10 para permitir warnings aceptables)

======================================================
SECCI√ìN A ‚Äì PASOS PARA IMPLEMENTAR EL CHALLENGE CON CURSOR
======================================================

Contexto r√°pido
---------------
- Dominio BIAN: Payment Initiation
- BQ principal: PaymentOrder
- Migraci√≥n: SOAP ‚Üí REST (BIAN-aligned)
- Arquitectura: Hexagonal (Ports & Adapters)
- Enfoque: Contract-First con OpenAPI 3.0
- Stack:
  - Java 21
  - Spring Boot 3 (Spring MVC, NO WebFlux en runtime)
  - H2 como base de datos
  - Gradle (Groovy DSL)
  - MapStruct para mapeos
  - WebTestClient para tests de integraci√≥n
- Artefactos de soporte:
  - WSDL legacy: PaymentOrderService.wsdl
  - XML ejemplos: SubmitPaymentOrder / GetPaymentOrderStatus (request/response)
  - Colecci√≥n Postman: postman_collection.json (endpoints REST a validar)

Los siguientes pasos est√°n pensados para copiarlos en Cursor Pro por bloques y dejar que genere el c√≥digo, mientras t√∫
revisas, corriges y documentas el uso de IA en la carpeta ai/.

‚ö†Ô∏è INSTRUCCIONES DE USO:
1. Copia cada PASO individualmente en Cursor Pro.
2. Revisa el c√≥digo generado antes de continuar al siguiente paso.
3. Ejecuta tests despu√©s de cada paso cr√≠tico (PASO 4, PASO 8, PASO 9, PASO 10, etc.).
4. Documenta cualquier correcci√≥n manual en ai/decisions.md.
5. Los pasos marcados con ‚ö†Ô∏è IMPORTANTE contienen correcciones cr√≠ticas que deben aplicarse.

‚ö†Ô∏è CR√çTICO - PERSISTENCIA OBLIGATORIA:
- El PASO 8 (H2 + JPA) es OBLIGATORIO y debe completarse COMPLETAMENTE antes de continuar.
- Sin la persistencia implementada (PaymentOrderEntity, PaymentOrderJpaRepository, PaymentOrderPersistenceMapper, PaymentOrderRepositoryAdapter), 
  los endpoints REST NO funcionar√°n y los tests de integraci√≥n fallar√°n con UnsupportedOperationException.
- NO contin√∫es al PASO 9 hasta que el PASO 8 est√© completamente implementado y verificado.
- Verifica que PaymentOrderRepositoryAdapter.save() y findByReference() est√©n implementados (no deben lanzar excepciones).


PASO 0 ‚Äì Crear proyecto base (Java 21 + Gradle + Spring MVC + H2)
-----------------------------------------------------------------
Prompt para Cursor:

Crea un proyecto Spring Boot 3 con Java 21 usando Gradle (Groovy DSL).
Act√∫a como un generador de proyectos y crea lo siguiente:

- Nombre del proyecto (crear carpeta): payment-initiation-service
- Group: com.bank.paymentinitiation
- Paquete base: com.bank.paymentinitiation

En build.gradle configura:

- Plugins:
  - id 'java'
  - id 'org.springframework.boot' version '3.2.0'
  - id 'io.spring.dependency-management' version '1.1.4'
  - id 'org.openapi.generator' version '7.0.1'
  - id 'checkstyle'
  - id 'com.github.spotbugs' version '6.0.0'
  - id 'jacoco'

- Java 21:
  - sourceCompatibility = JavaVersion.VERSION_21
  - targetCompatibility = JavaVersion.VERSION_21

- Dependencias principales:
  - implementation 'org.springframework.boot:spring-boot-starter-web'           // Spring MVC
  - implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
  - implementation 'org.springframework.boot:spring-boot-starter-validation'
  - implementation 'org.springframework.boot:spring-boot-starter-actuator'
  - runtimeOnly  'com.h2database:h2'
  - MapStruct:
    - implementation "org.mapstruct:mapstruct:1.5.5.Final"
    - annotationProcessor "org.mapstruct:mapstruct-processor:1.5.5.Final"
  - Lombok:
    - compileOnly "org.projectlombok:lombok:1.18.30"
    - annotationProcessor "org.projectlombok:lombok:1.18.30"
    - annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"
  - Tests:
    - testImplementation 'org.springframework.boot:spring-boot-starter-test'
    - testImplementation 'org.springframework:spring-webflux'   // solo para WebTestClient

Configura:
- test { useJUnitPlatform() }
- jacoco b√°sico (toolVersion, reporte html/xml m√≠nimo).

--------------------------------------------------
Checkstyle (CONFIGURACI√ìN OBLIGATORIA)
--------------------------------------------------
- Usa encoding expl√≠cito UTF-8 en la configuraci√≥n de Checkstyle.
- Aplica una configuraci√≥n ‚Äúmedia‚Äù adecuada para proyectos BIAN:
    ‚Ä¢ Reglas de naming
    ‚Ä¢ Reglas de imports
    ‚Ä¢ Whitespace y llaves
    ‚Ä¢ Longitud de l√≠nea razonable (ej. 120)
    ‚Ä¢ Complejidad razonable
    ‚Ä¢ Buenas pr√°cticas b√°sicas
  (NO uses reglas extremas ni demasiado restrictivas que frenen el desarrollo).

- Debes crear y usar estos archivos obligatorios:
    ‚Ä¢ config/checkstyle/checkstyle.xml
    ‚Ä¢ config/checkstyle/suppressions.xml

- En build.gradle debes referenciarlos as√≠:
    ‚Ä¢ configFile = file("$rootDir/config/checkstyle/checkstyle.xml")
    ‚Ä¢ configProperties = ['checkstyle.suppressions.file': "$rootDir/config/checkstyle/suppressions.xml"]

‚ö†Ô∏è IMPORTANTE - Configuraci√≥n de Checkstyle:
- El m√≥dulo `LineLength` DEBE estar FUERA de `TreeWalker`, no dentro.
- Si `LineLength` est√° dentro de `TreeWalker`, Checkstyle lanzar√° el error: "TreeWalker is not allowed as a parent of LineLength".
- Estructura correcta en checkstyle.xml:
  ```xml
  <module name="Checker">
      <module name="LineLength">  <!-- Fuera de TreeWalker -->
          <property name="max" value="120"/>
      </module>
      <module name="TreeWalker">
          <!-- Otros m√≥dulos aqu√≠ -->
      </module>
  </module>
  ```

‚ö†Ô∏è CR√çTICO - Orden de Imports en Checkstyle:
- El orden de imports DEBE ser exactamente: java.* ‚Üí jakarta.* ‚Üí org.* ‚Üí com.*
- Entre cada grupo debe haber UNA l√≠nea en blanco.
- Los static imports van DENTRO del grupo org.*, despu√©s de los imports normales de org.* pero ANTES de com.*
- Ejemplo CORRECTO:
  ```java
  package com.example;
  
  import java.math.BigDecimal;        // Grupo 1: java.*
  import java.time.LocalDate;
  
  import jakarta.validation.Valid;    // Grupo 2: jakarta.*
  
  import org.springframework.web.bind.annotation.RestController;  // Grupo 3: org.* (normal)
  import static org.assertj.core.api.Assertions.assertThat;       // Grupo 3: org.* (static)
  import static org.mockito.Mockito.verify;                        // Grupo 3: org.* (static)
  
  import com.example.model.PaymentOrder;  // Grupo 4: com.*
  
  import lombok.RequiredArgsConstructor;   // Lombok debe estar separado, generalmente despu√©s de com.*
  ```
- Ejemplo INCORRECTO (causar√° error):
  ```java
  import jakarta.validation.Valid;
  import org.springframework.web.bind.annotation.RestController;  // ‚ùå Falta l√≠nea en blanco
  ```
- Los static imports de lombok (si los hay) deben ir en el mismo grupo que otros static imports de org.*

- ANTES de ejecutar el build completo, ejecuta:
    ./gradlew checkstyleMain --no-daemon

  IMPORTANTE (manejo de errores):
  ‚Ä¢ NO uses tail, grep ni recortes de salida (NO uses "| tail -3" ni "| tail -10").
  ‚Ä¢ Muestra el log COMPLETO del comando. Si es muy largo, muestra TODO y luego haz un resumen manual con:
      - Tipo de error (ImportOrder, LineLength, etc.)
      - Archivo y l√≠nea afectados
      - Mensaje completo del error
      - "Caused by" si existe
  ‚Ä¢ Si aparece un error en Checkstyle:
      ‚Üí Lee exactamente el mensaje del log (incluyendo "Caused by:", m√≥dulo afectado, archivo y l√≠nea).
      ‚Üí Errores comunes y soluciones:
        * "Orden incorrecto para el import": Reordenar imports seg√∫n grupos (java.* ‚Üí jakarta.* ‚Üí org.* ‚Üí com.*)
        * "Separaci√≥n extra en el grupo": Eliminar l√≠neas en blanco innecesarias dentro de un grupo
        * "deber√≠a separarse de los import previos": Agregar l√≠nea en blanco entre grupos (ej: entre jakarta.* y lombok)
      ‚Üí Identifica la causa real (ruta incorrecta, error DTD, m√≥dulo mal definido, regla inv√°lida, propiedad inexistente, orden de imports, etc.).
      ‚Üí Corrige la configuraci√≥n modificando SOLO los archivos necesarios:
            - build.gradle
            - config/checkstyle/checkstyle.xml
            - config/checkstyle/suppressions.xml
            - Archivos Java afectados (para errores de ImportOrder)
      ‚Üí Vuelve a ejecutar:
            ./gradlew checkstyleMain --no-daemon
        y luego:
            ./gradlew checkstyleTest --no-daemon
        hasta que ambos pasen sin errores.
  ‚Ä¢ Nunca elimines el plugin de Checkstyle ni ignores los errores: siempre corrige la configuraci√≥n seg√∫n el log completo.

--------------------------------------------------
‚ö†Ô∏è IMPORTANTE - SpotBugs
--------------------------------------------------
- SpotBugs: NO configures `effort` y `reportLevel` en el bloque `spotbugs {}` directamente como strings.
  Estos deben configurarse en las tareas individuales usando:
    - com.github.spotbugs.snom.Effort.valueOf('MAX')
    - com.github.spotbugs.snom.Confidence.valueOf('HIGH')
- La configuraci√≥n detallada de SpotBugs est√° en el PASO 14 del archivo super_prompt.txt, pero en este paso solo deja el plugin declarado sin romper el build.

Al final de este paso, el proyecto debe:
- Compilar correctamente.
- Tener Checkstyle configurado y ejecut√°ndose sin errores con `./gradlew checkstyleMain --no-daemon`.

Aseg√∫rate de que ./gradlew clean build compila correctamente.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y lo que gener√≥ la IA
- ai/decisions.md: Documenta cualquier correcci√≥n manual aplicada (ej: configuraci√≥n de SpotBugs)


PASO 1 ‚Äì Carpeta de evidencias de IA
------------------------------------
Crea en la ra√≠z del proyecto (junto a build.gradle):

- ai/prompts.md      ‚Üí lista de prompts usados (incluye los que uses con Cursor).
- ai/decisions.md    ‚Üí decisiones de dise√±o, correcciones manuales, trade-offs.
- ai/generations/    ‚Üí fragmentos relevantes generados por IA (por ejemplo openapi.yaml, controladores, etc.).

Inicializa los .md con t√≠tulos y una peque√±a descripci√≥n de c√≥mo se documentar√° el uso de IA.


PASO 2 ‚Äì Analizar el WSDL y los XML legacy
------------------------------------------
Usa PaymentOrderService.wsdl, SubmitPaymentOrder*.xml y GetPaymentOrderStatus*.xml como entrada.

Prompt sugerido para Cursor:

Analiza el archivo PaymentOrderService.wsdl y los XML de ejemplo (SubmitPaymentOrderRequest/Response, GetPaymentOrderStatusRequest/Response) y dame:

1) Operaciones SOAP disponibles relacionadas con √≥rdenes de pago.
2) Estructuras de datos principales (campos clave) de la orden de pago.
3) Estados posibles de la orden de pago en el servicio legacy.
4) Un mapeo de estos conceptos al Service Domain BIAN Payment Initiation y al BQ PaymentOrder.


Resume y copia el resultado en ai/decisions.md.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el an√°lisis generado
- ai/decisions.md: Guarda el resultado completo del an√°lisis del WSDL y mapeo a BIAN
- ai/generations/: Opcionalmente guarda el WSDL analizado si es relevante


PASO 3 ‚Äì Dise√±ar el contrato OpenAPI 3.0 (contract-first, alineado con Postman)
-------------------------------------------------------------------------------
Prompt para Cursor:

Bas√°ndote en el an√°lisis del WSDL y la colecci√≥n postman_collection.json (endpoints):

- POST http://localhost:8080/payment-initiation/payment-orders
- GET  http://localhost:8080/payment-initiation/payment-orders/{id}
- GET  http://localhost:8080/payment-initiation/payment-orders/{id}/status

Genera un archivo openapi/openapi.yaml con OpenAPI 3.0 que defina:

- servers:
  - url: http://localhost:8080
- paths:
  - POST /payment-initiation/payment-orders
    - operationId: initiatePaymentOrder
    - requestBody con esquema InitiatePaymentOrderRequest con campos alineados a la colecci√≥n Postman:
      - externalReference
      - debtorAccount { iban }
      - creditorAccount { iban }
      - instructedAmount { amount, currency }
      - remittanceInformation
      - requestedExecutionDate (date)
    - responses:
      - 201: InitiatePaymentOrderResponse
      - 400, 500 en formato application/problem+json
  - GET /payment-initiation/payment-orders/{id}
    - operationId: retrievePaymentOrder
    - 200: RetrievePaymentOrderResponse
    - 404: ProblemDetail
  - GET /payment-initiation/payment-orders/{id}/status
    - operationId: retrievePaymentOrderStatus
    - 200: PaymentOrderStatusResponse
    - 404: ProblemDetail

Define schemas:

- InitiatePaymentOrderRequest
- InitiatePaymentOrderResponse
- RetrievePaymentOrderResponse
- PaymentOrderStatusResponse
- PaymentAmount (value/currency)
- ProblemDetail (RFC 7807)

‚ö†Ô∏è IMPORTANTE - Validaciones en OpenAPI:
- NO uses `pattern` y `enum` juntos en el mismo campo. Si un campo tiene `enum`, OpenAPI Generator crear√° un Java enum, y `@Pattern` no puede aplicarse a enums.
- Ejemplo INCORRECTO (causar√° error de validaci√≥n):
  ```yaml
  currency:
    type: string
    enum: [USD, EUR, GBP]
    pattern: '^[A-Z]{3}$'  # ‚ùå NO usar pattern con enum
  ```
- Ejemplo CORRECTO:
  ```yaml
  currency:
    type: string
    enum: [USD, EUR, GBP]  # ‚úÖ Solo enum, sin pattern
  ```
- Para campos de texto con validaci√≥n de longitud (ej: IBAN), usa `minLength` y `maxLength`:
  ```yaml
  iban:
    type: string
    minLength: 15
    maxLength: 34
  ```
  ‚ö†Ô∏è NOTA: Si defines `minLength: 15` para IBANs, aseg√∫rate de que TODOS los ejemplos en tests, 
  Postman collection y documentaci√≥n usen IBANs de al menos 15 caracteres. Ejemplo: `"EC123456789012345678"`.

Implementa el contenido completo de openapi/openapi.yaml.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el contrato OpenAPI generado
- ai/decisions.md: Documenta decisiones de dise√±o del contrato (endpoints, schemas, validaciones)
- ai/generations/: Guarda una copia del openapi.yaml inicial generado por IA con comentarios sobre qu√© se mantuvo y qu√© se modific√≥


PASO 4 ‚Äì Configurar OpenAPI Generator en Gradle
-----------------------------------------------
Prompt:

En build.gradle, configura la tarea openApiGenerate:

- generatorName = 'spring'
- inputSpec   = "$rootDir/openapi/openapi.yaml"
- outputDir   = "$buildDir/generated"
- apiPackage  = 'com.bank.paymentinitiation.generated.api'
- modelPackage = 'com.bank.paymentinitiation.generated.model'
- invokerPackage = 'com.bank.paymentinitiation.generated.invoker'
- configOptions:
  - interfaceOnly = 'true'
  - useSpringBoot3 = 'true'
  - useTags = 'true'
  - dateLibrary = 'java8'
  - serializationLibrary = 'jackson'
  - hideGenerationTimestamp = 'true'

A√±ade la carpeta generada como source set:

- sourceSets.main.java.srcDir("$buildDir/generated/src/main/java")

Y haz que compileJava dependa de openApiGenerate.

‚ö†Ô∏è IMPORTANTE - Dependencias necesarias para c√≥digo generado:
Agrega estas dependencias adicionales que requiere el c√≥digo generado por OpenAPI:

- implementation "io.swagger.core.v3:swagger-annotations:2.2.21"
- implementation "org.openapitools:jackson-databind-nullable:0.2.6"
- implementation "jakarta.validation:jakarta.validation-api:3.0.2"
- implementation "jakarta.annotation:jakarta.annotation-api:2.1.1"

Comprueba que ./gradlew openApiGenerate && ./gradlew compileJava funciona sin errores.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la configuraci√≥n de OpenAPI Generator generada
- ai/decisions.md: Documenta las dependencias adicionales agregadas y por qu√© fueron necesarias


PASO 5 ‚Äì Estructura de paquetes (Hexagonal)
-------------------------------------------
Prompt:

Crea la siguiente estructura de paquetes bajo com.bank.paymentinitiation:

- domain
  - model
  - port.in
  - port.out
  - exception
  - service
- application
  - service
  - mapper (opcional)
- adapter.in.rest
  - dto (los modelos generados van en generated.model, aqu√≠ solo wrappers si los necesitas)
  - mapper
- adapter.out.persistence
  - entity
  - jpa
  - mapper
  - PaymentOrderRepositoryAdapter
- config

Crea clases vac√≠as (o interfaces) con javadoc describiendo su rol, sin meter a√∫n mucha l√≥gica.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la estructura de paquetes generada
- ai/decisions.md: Documenta la decisi√≥n de usar arquitectura hexagonal y la organizaci√≥n de paquetes


PASO 6 ‚Äì Modelo de dominio BIAN (PaymentOrder)
----------------------------------------------
Prompt:

En com.bank.paymentinitiation.domain.model crea:

- Enum PaymentStatus con valores: INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED.
- Value object PaymentAmount (BigDecimal value, String currency) con factor√≠a est√°tica que valide que value > 0.
- Value objects PayerReference, PayeeReference, ExternalReference (strings no vac√≠os).
- Aggregate root PaymentOrder con campos:
  - String paymentOrderReference
  - ExternalReference externalReference
  - PayerReference payerReference
  - PayeeReference payeeReference
  - PaymentAmount instructedAmount
  - String remittanceInformation
  - LocalDate requestedExecutionDate
  - PaymentStatus status
  - LocalDateTime createdAt
  - LocalDateTime updatedAt

Incluye m√©todos de dominio para:
- validar el agregado (validate())
- iniciar la orden (marcar INITIATED)
- cambiar estado respetando una secuencia razonable (por ejemplo INITIATED ‚Üí PENDING ‚Üí PROCESSED ‚Üí COMPLETED).

‚ö†Ô∏è IMPORTANTE - Orden de validaci√≥n en servicios de aplicaci√≥n:
- El m√©todo `validate()` del agregado PaymentOrder requiere que `status` y `createdAt` sean no-null.
- Estos campos se establecen cuando se llama a `initiate()`.
- Por lo tanto, en los servicios de aplicaci√≥n (ej: InitiatePaymentOrderService), el orden CORRECTO es:
  1. Generar `paymentOrderReference` (si no existe).
  2. Llamar a `order.initiate()` para establecer `status = INITIATED` y `createdAt = LocalDateTime.now()`.
  3. Llamar a `paymentOrderDomainService.validate(initiatedOrder)` y `initiatedOrder.validate()`.
  4. Guardar en el repositorio.
- NO llames a `validate()` antes de `initiate()`, ya que fallar√° con NullPointerException.

No uses anotaciones de Spring en el dominio. Usa Lombok (@Value/@Builder) cuando tenga sentido.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el modelo de dominio generado
- ai/decisions.md: Documenta decisiones sobre value objects, estados del enum PaymentStatus, y m√©todos de dominio
- ai/generations/: Opcionalmente guarda clases del dominio generadas inicialmente si hubo cambios significativos


PASO 7 ‚Äì Puertos de dominio (ports in/out) y servicios de aplicaci√≥n
--------------------------------------------------------------------
Prompt:

En domain.port.in crea interfaces:

- InitiatePaymentOrderUseCase
  - PaymentOrder initiate(PaymentOrder order);
- RetrievePaymentOrderUseCase
  - PaymentOrder retrieve(String paymentOrderReference);
- RetrievePaymentOrderStatusUseCase
  - PaymentStatus retrieveStatus(String paymentOrderReference);

En domain.port.out crea:

- PaymentOrderRepository
  - PaymentOrder save(PaymentOrder order);
  - Optional<PaymentOrder> findByReference(String paymentOrderReference);

En application.service crea implementaciones de estos casos de uso que:
- Inyectan PaymentOrderRepository (port out).
- Aplican reglas de negocio b√°sicas y delegan en el repositorio.
- Lanzan excepciones de dominio (PaymentOrderNotFoundException, InvalidPaymentException) cuando aplique.

‚ö†Ô∏è IMPORTANTE - Orden de operaciones en InitiatePaymentOrderService:
- El m√©todo `initiate()` del servicio DEBE seguir este orden:
  1. Generar `paymentOrderReference` si no existe (usando `PaymentOrderDomainService.generateReference()`).
  2. Llamar a `order.initiate()` para establecer `status = INITIATED` y `createdAt = LocalDateTime.now()`.
  3. Llamar a `paymentOrderDomainService.validate(initiatedOrder)` y `initiatedOrder.validate()`.
  4. Guardar en el repositorio usando `repository.save(initiatedOrder)`.
- NO llames a `validate()` antes de `initiate()`, ya que `validate()` requiere que `status` y `createdAt` sean no-null.
- Ejemplo de implementaci√≥n correcta:
  ```java
  public PaymentOrder initiate(PaymentOrder order) {
      if (order.getPaymentOrderReference() == null || order.getPaymentOrderReference().isBlank()) {
          String reference = paymentOrderDomainService.generateReference();
          order = order.toBuilder().paymentOrderReference(reference).build();
      }
      PaymentOrder initiatedOrder = order.initiate();  // Establece status y createdAt
      paymentOrderDomainService.validate(initiatedOrder);  // Valida despu√©s de initiate
      initiatedOrder.validate();  // Valida invariantes del agregado
      return repository.save(initiatedOrder);
  }
  ```

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y los puertos/servicios generados
- ai/decisions.md: Documenta decisiones sobre la separaci√≥n de puertos in/out y la implementaci√≥n de servicios de aplicaci√≥n


PASO 8 ‚Äì H2 + JPA (entidad, repositorio y adaptador de persistencia)
--------------------------------------------------------------------
‚ö†Ô∏è CR√çTICO - Este paso es OBLIGATORIO y debe completarse completamente antes de continuar al PASO 9.
Sin la persistencia implementada, los tests de integraci√≥n y los endpoints REST no funcionar√°n.

Prompt:

1. Configura application.yml para H2 en memoria:

spring:
  datasource:
    url: jdbc:h2:mem:paymentdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
      path: /h2-console
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: false
    properties:
      hibernate:
        format_sql: true

management:
  endpoints:
    web:
      exposure:
        include: health,info
      base-path: /actuator
  endpoint:
    health:
      show-details: when_authorized

2. En adapter.out.persistence.entity crea PaymentOrderEntity con:
   - @Entity y @Table(name = "payment_orders")
   - UUID id (clave primaria t√©cnica, @Id, @GeneratedValue)
   - String paymentOrderReference (identificador de negocio √∫nico, @Column(unique = true, nullable = false))
   - String externalReference (mapeado desde domain.ExternalReference.getValue())
   - String payerReference (mapeado desde domain.PayerReference.getValue())
   - String payeeReference (mapeado desde domain.PayeeReference.getValue())
   - BigDecimal amount (mapeado desde domain.PaymentAmount.getValue())
   - String currency (mapeado desde domain.PaymentAmount.getCurrency())
   - String remittanceInformation
   - LocalDate requestedExecutionDate
   - String status (mapeado desde domain.PaymentStatus.name(), enum como String)
   - LocalDateTime createdAt
   - LocalDateTime updatedAt
   - @Column con anotaciones apropiadas (@Column(nullable = false) donde aplique)
   - Constructor sin argumentos (requerido por JPA)
   - Constructor con todos los campos o builder (opcional, para facilitar creaci√≥n en tests)

3. En adapter.out.persistence.jpa crea PaymentOrderJpaRepository:
   - Interface que extiende JpaRepository<PaymentOrderEntity, UUID>
   - M√©todo: Optional<PaymentOrderEntity> findByPaymentOrderReference(String paymentOrderReference);
   - ‚ö†Ô∏è IMPORTANTE: El m√©todo debe buscar por paymentOrderReference, NO por id (UUID).
     Usa @Query si es necesario: @Query("SELECT e FROM PaymentOrderEntity e WHERE e.paymentOrderReference = :reference")

4. Completa PaymentOrderPersistenceMapper en adapter.out.persistence.mapper:
   - Descomenta y completa los m√©todos toEntity() y toDomain()
   - Usa @Mapping con expresiones para mapear value objects:
     - domain.ExternalReference.getValue() ‚Üí entity.externalReference
     - domain.PayerReference.getValue() ‚Üí entity.payerReference
     - domain.PayeeReference.getValue() ‚Üí entity.payeeReference
     - domain.PaymentAmount.getValue() ‚Üí entity.amount
     - domain.PaymentAmount.getCurrency() ‚Üí entity.currency
     - domain.PaymentStatus.name() ‚Üí entity.status (String)
   - Para toDomain(), crea value objects usando sus constructores:
     - new ExternalReference(entity.getExternalReference())
     - new PayerReference(entity.getPayerReference())
     - new PayeeReference(entity.getPayeeReference())
     - PaymentAmount.of(entity.getAmount(), entity.getCurrency())
     - PaymentStatus.valueOf(entity.getStatus())
   - Mapea paymentOrderReference ‚Üî id (el id t√©cnico UUID se usa como clave primaria, pero paymentOrderReference es el identificador de negocio)

5. Completa PaymentOrderRepositoryAdapter en adapter.out.persistence:
   - Inyecta PaymentOrderJpaRepository y PaymentOrderPersistenceMapper v√≠a constructor
   - Implementa save():
     - ‚ö†Ô∏è CR√çTICO: Verifica si la entidad ya existe buscando por paymentOrderReference (NO por id UUID).
     - Si existe: mapea PaymentOrder ‚Üí PaymentOrderEntity, PRESERVA el ID existente de la base de datos, y actualiza.
     - Si no existe: mapea PaymentOrder ‚Üí PaymentOrderEntity (el mapper generar√° un nuevo UUID para id).
     - Guarda la entidad usando jpaRepository.save(entity) (insert o update seg√∫n corresponda).
     - Mapea PaymentOrderEntity guardada ‚Üí PaymentOrder usando mapper.toDomain(savedEntity)
     - Retorna PaymentOrder
   - Implementa findByReference():
     - Busca entidad usando jpaRepository.findByPaymentOrderReference(paymentOrderReference)
     - Si existe, mapea PaymentOrderEntity ‚Üí PaymentOrder usando mapper.toDomain(entity)
     - Retorna Optional.of(mappedOrder) o Optional.empty()
   - ‚ö†Ô∏è IMPORTANTE: Elimina los TODOs y las excepciones UnsupportedOperationException.
     Este adaptador DEBE estar completamente implementado para que los endpoints REST funcionen.
   - Ejemplo de implementaci√≥n completa de save() con preservaci√≥n de ID:
     ```java
     @Override
     public PaymentOrder save(final PaymentOrder order) {
         // Verificar si la entidad ya existe por paymentOrderReference
         Optional<PaymentOrderEntity> existingEntity = jpaRepository
             .findByPaymentOrderReference(order.getPaymentOrderReference());
         
         PaymentOrderEntity entity;
         if (existingEntity.isPresent()) {
             // Actualizar entidad existente: preservar ID y actualizar todos los dem√°s campos
             PaymentOrderEntity existing = existingEntity.get();
             entity = mapper.toEntity(order);
             entity.setId(existing.getId()); // Preservar el ID existente
         } else {
             // Crear nueva entidad
             entity = mapper.toEntity(order);
         }
         
         // Guardar entidad (insert o update)
         PaymentOrderEntity savedEntity = jpaRepository.save(entity);
         
         // Mapear de vuelta a dominio y retornar
         return mapper.toDomain(savedEntity);
     }
     ```

‚ö†Ô∏è VERIFICACI√ìN OBLIGATORIA:
Despu√©s de completar este paso, ejecuta:
- ./gradlew compileJava --no-daemon (debe compilar sin errores)
- ./gradlew test --no-daemon (los tests unitarios deben pasar)
- Verifica que PaymentOrderRepositoryAdapter.save() y findByReference() est√©n implementados (no deben lanzar UnsupportedOperationException)
- Verifica que PaymentOrderPersistenceMapper tenga los m√©todos toEntity() y toDomain() implementados (no comentados)
- Verifica que PaymentOrderEntity tenga todos los campos necesarios y anotaciones JPA correctas
- Verifica que PaymentOrderJpaRepository tenga el m√©todo findByPaymentOrderReference() implementado

‚ö†Ô∏è CR√çTICO - NO contin√∫es al PASO 9 hasta que:
- PaymentOrderEntity est√© creada y compilando
- PaymentOrderJpaRepository est√© creada y compilando
- PaymentOrderPersistenceMapper est√© completamente implementado (m√©todos descomentados y funcionando)
- PaymentOrderRepositoryAdapter est√© completamente implementado (save() y findByReference() funcionando, sin UnsupportedOperationException)
- Todos los tests unitarios pasen
- El proyecto compile sin errores

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la configuraci√≥n de H2/JPA generada
- ai/decisions.md: Documenta decisiones sobre la estructura de la entidad JPA, uso de UUID vs paymentOrderReference, mapeo de value objects, y configuraci√≥n de H2


PASO 9 ‚Äì MapStruct para mapeos (REST ‚Üî Dominio ‚Üî Entidad)
----------------------------------------------------------
Prompt:

Configura MapStruct usando:

- implementation "org.mapstruct:mapstruct:1.5.5.Final"
- annotationProcessor "org.mapstruct:mapstruct-processor:1.5.5.Final"

Crea en adapter.in.rest.mapper:

- PaymentOrderRestMapper con m√©todos:
  - PaymentOrder toDomain(InitiatePaymentOrderRequest request);
  - InitiatePaymentOrderResponse toInitiateResponse(PaymentOrder domain);
  - RetrievePaymentOrderResponse toRetrieveResponse(PaymentOrder domain);
  - PaymentOrderStatusResponse toStatusResponse(PaymentOrder domain);

Crea en adapter.out.persistence.mapper:

- PaymentOrderPersistenceMapper con m√©todos:
  - PaymentOrderEntity toEntity(PaymentOrder domain);
  - PaymentOrder toDomain(PaymentOrderEntity entity);

‚ö†Ô∏è IMPORTANTE - Completar mapper de persistencia:
- Si PaymentOrderPersistenceMapper ya existe pero est√° comentado (del PASO 8), descomenta y completa los m√©todos.
- Si no existe, cr√©alo con los m√©todos completos usando @Mapping con expresiones para value objects.
- Usa @Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR).
- ‚ö†Ô∏è CR√çTICO: Este mapper DEBE estar completamente implementado para que PaymentOrderRepositoryAdapter funcione.
- ‚ö†Ô∏è NOTA: Si ya completaste el PASO 8 completamente, este mapper ya deber√≠a estar implementado. 
  Solo verifica que est√© funcionando correctamente y que los m√©todos no est√©n comentados.
- ‚ö†Ô∏è NOTA: Si ya completaste el PASO 8 completamente, este mapper ya deber√≠a estar implementado. 
  Solo verifica que est√© funcionando correctamente y que los m√©todos no est√©n comentados.

‚ö†Ô∏è IMPORTANTE - Evitar ambig√ºedades de tipos:
- En los mappers MapStruct, usa nombres completamente calificados (fully qualified names) para tipos 
  que tienen el mismo nombre en diferentes paquetes (ej: PaymentAmount, PaymentStatus en dominio vs generated.model).
- Ejemplo: usa `com.bank.paymentinitiation.domain.model.PaymentAmount` en lugar de solo `PaymentAmount` 
  cuando hay ambig√ºedad entre dominio y DTOs generados.
- Para m√©todos `toDomain(InitiatePaymentOrderRequest request, String paymentOrderReference)`, 
  el mapper debe recibir el `paymentOrderReference` como par√°metro adicional porque se genera 
  en el controlador, no en el mapper.

‚ö†Ô∏è Conversi√≥n de timestamps:
- Agrega m√©todos @Named para convertir LocalDateTime ‚Üí OffsetDateTime en mappers REST, 
  ya que los DTOs de OpenAPI usan OffsetDateTime pero el dominio usa LocalDateTime.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y los mappers MapStruct generados
- ai/decisions.md: Documenta las correcciones manuales aplicadas (ambig√ºedades de tipos, conversiones de timestamps, m√©todos custom)
- ai/generations/: Opcionalmente guarda mappers generados inicialmente si hubo cambios significativos


PASO 10 ‚Äì Adaptador REST (implementando interfaces generadas)
-------------------------------------------------------------
Prompt:

Usando las interfaces generadas en com.bank.paymentinitiation.generated.api, crea PaymentOrdersController en adapter.in.rest que:

- Implemente PaymentOrdersApi (el nombre generado por OpenAPI).
- Inyecte los use cases, PaymentOrderRestMapper y PaymentOrderReferenceGenerator.
- Para POST /payment-initiation/payment-orders:
  - Reciba InitiatePaymentOrderRequest con @Valid.
  - Genere paymentOrderReference usando PaymentOrderReferenceGenerator.
  - Mapee DTO ‚Üí dominio usando `mapper.toDomain(request, paymentOrderReference)`.
  - Llame InitiatePaymentOrderUseCase, mapee dominio ‚Üí InitiatePaymentOrderResponse.
  - Devuelva ResponseEntity.status(HttpStatus.CREATED).body(response).
- Para GET /payment-initiation/payment-orders/{id}:
  - Llame RetrievePaymentOrderUseCase, mapee dominio ‚Üí RetrievePaymentOrderResponse.
  - Devuelva ResponseEntity.ok(response).
- Para GET /payment-initiation/payment-orders/{id}/status:
  - Llame RetrievePaymentOrderUseCase (necesita orden completa para mapear a response con paymentOrderReference y lastUpdated).
  - Mapee dominio ‚Üí PaymentOrderStatusResponse usando mapper.toStatusResponse().
  - Devuelva ResponseEntity.ok(response).
  - ‚ö†Ô∏è NOTA: Aunque existe RetrievePaymentOrderStatusUseCase que retorna solo PaymentStatus, 
    el controlador usa RetrievePaymentOrderUseCase porque necesita la orden completa para 
    incluir paymentOrderReference y lastUpdated en la respuesta.

‚ö†Ô∏è IMPORTANTE - Servicios y componentes necesarios:

1. Crea PaymentOrderReferenceGenerator en application.service:
   - Componente Spring (@Component) que genera referencias √∫nicas en formato "PO-{n√∫mero}".
   - ‚ö†Ô∏è CR√çTICO: El formato DEBE cumplir con el patr√≥n del OpenAPI: `^PO-[0-9]+$` (solo n√∫meros despu√©s de "PO-").
     El OpenAPI define `pattern: '^PO-[0-9]+$'` para el par√°metro `paymentOrderId`, por lo que NO se pueden usar letras.
   - ‚ö†Ô∏è CR√çTICO: NO uses UUIDs con letras, ya que no cumplir√°n el patr√≥n `^PO-[0-9]+$` y causar√°n errores de validaci√≥n.
   - Genera un identificador num√©rico √∫nico usando timestamp + n√∫mero aleatorio.
   - Ejemplo de implementaci√≥n CORRECTA:
     ```java
     @Component
     public class PaymentOrderReferenceGenerator {
         public String generate() {
             // Genera un identificador num√©rico usando timestamp (√∫ltimos 10 d√≠gitos) + aleatorio (6 d√≠gitos)
             // Esto asegura unicidad mientras cumple el patr√≥n ^PO-[0-9]+$
             long timestamp = System.currentTimeMillis();
             long random = (long) (Math.random() * 1000000); // 6 d√≠gitos
             String numericId = String.format("%010d%06d", timestamp % 10000000000L, random);
             return "PO-" + numericId;
         }
     }
     ```
   - Ejemplo de referencia generada: "PO-1234567890123456" (16 d√≠gitos num√©ricos).
   - ‚ö†Ô∏è NOTA: Este formato es obligatorio para cumplir con la validaci√≥n del OpenAPI y evitar errores de ConstraintViolationException.

2. Crea ApplicationConfig en config/:
   - Clase de configuraci√≥n Spring con @Configuration.
   - ‚ö†Ô∏è NOTA: Los servicios de aplicaci√≥n (InitiatePaymentOrderService, RetrievePaymentOrderService, RetrievePaymentOrderStatusService) 
     ya tienen @Service, por lo que Spring los detecta autom√°ticamente. ApplicationConfig puede estar vac√≠a o contener 
     configuraci√≥n adicional si es necesaria.

3. ‚ö†Ô∏è CR√çTICO - Verifica y completa PaymentOrderRepositoryAdapter (si no se complet√≥ en PASO 8):
   - Debe tener @Component para ser detectado por Spring.
   - DEBE inyectar PaymentOrderJpaRepository y PaymentOrderPersistenceMapper v√≠a constructor.
   - Implementa COMPLETAMENTE los m√©todos save() y findByReference() usando PaymentOrderJpaRepository y PaymentOrderPersistenceMapper.
   - ‚ö†Ô∏è CR√çTICO: Elimina TODOS los TODOs y excepciones UnsupportedOperationException.
     Sin este adaptador implementado, los endpoints REST NO funcionar√°n y los tests de integraci√≥n fallar√°n.
   - Si el adaptador ya est√° implementado (del PASO 8), verifica que funcione correctamente.
   - Ejemplo de implementaci√≥n completa:
     ```java
     @Component
     @RequiredArgsConstructor
     public class PaymentOrderRepositoryAdapter implements PaymentOrderRepository {
         private final PaymentOrderJpaRepository jpaRepository;
         private final PaymentOrderPersistenceMapper mapper;
         
         @Override
         public PaymentOrder save(PaymentOrder order) {
             // Verificar si la entidad ya existe por paymentOrderReference
             Optional<PaymentOrderEntity> existingEntity = jpaRepository
                 .findByPaymentOrderReference(order.getPaymentOrderReference());
             
             PaymentOrderEntity entity;
             if (existingEntity.isPresent()) {
                 // Actualizar entidad existente: preservar ID y actualizar todos los dem√°s campos
                 PaymentOrderEntity existing = existingEntity.get();
                 entity = mapper.toEntity(order);
                 entity.setId(existing.getId()); // Preservar el ID existente
             } else {
                 // Crear nueva entidad
                 entity = mapper.toEntity(order);
             }
             
             // Guardar entidad (insert o update)
             PaymentOrderEntity savedEntity = jpaRepository.save(entity);
             
             // Mapear de vuelta a dominio y retornar
             return mapper.toDomain(savedEntity);
         }
         
         @Override
         public Optional<PaymentOrder> findByReference(String paymentOrderReference) {
             return jpaRepository.findByPaymentOrderReference(paymentOrderReference)
                 .map(mapper::toDomain);
         }
     }
     ```

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el controlador REST generado
- ai/decisions.md: Documenta decisiones sobre PaymentOrderReferenceGenerator, ApplicationConfig, y la implementaci√≥n del controlador
- ai/generations/: Opcionalmente guarda el controlador generado inicialmente si hubo cambios significativos


PASO 11 ‚Äì Manejo global de errores (RFC 7807)
---------------------------------------------
Prompt:

Crea en adapter.in.rest un @RestControllerAdvice GlobalExceptionHandler que maneje:

- PaymentOrderNotFoundException ‚Üí 404 NOT FOUND, body ProblemDetail con title "Payment Order Not Found".
- InvalidPaymentException ‚Üí 400 BAD REQUEST, body ProblemDetail con title "Invalid Payment Order".
- MethodArgumentNotValidException ‚Üí 400 BAD REQUEST, body ProblemDetail con title "Bad Request" y detail que describe los errores de validaci√≥n (campos faltantes, valores inv√°lidos, etc.).
  - Esta excepci√≥n se lanza cuando `@Valid` falla en los par√°metros del controlador.
- HttpMessageNotReadableException ‚Üí 400 BAD REQUEST, body ProblemDetail con title "Bad Request" y detail que describe el error (JSON malformado, formato de fecha inv√°lido, etc.).
  - Esta excepci√≥n se lanza cuando el JSON del request body no puede ser parseado (ej: fecha en formato incorrecto, JSON sint√°cticamente inv√°lido).
- Exception gen√©rica ‚Üí 500 INTERNAL SERVER ERROR.

‚ö†Ô∏è IMPORTANTE - Handlers adicionales:
- Los handlers para `MethodArgumentNotValidException` y `HttpMessageNotReadableException` son OBLIGATORIOS 
  para que los tests de integraci√≥n pasen correctamente cuando se env√≠an requests inv√°lidos.
- Sin estos handlers, Spring Boot retornar√° 500 INTERNAL SERVER ERROR en lugar de 400 BAD REQUEST para errores de validaci√≥n.

Usa org.springframework.http.ProblemDetail (Spring 6+). Todos los errores deben tener content-type application/problem+json.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el GlobalExceptionHandler generado
- ai/decisions.md: Documenta decisiones sobre el manejo de errores RFC 7807 y el mapeo de excepciones de dominio a HTTP


PASO 12 ‚Äì Tests unitarios (dominio, casos de uso, mappers)
----------------------------------------------------------
Prompt:
Crea tests unitarios siguiendo buenas pr√°cticas de testing para el microservicio Payment Initiation.

‚ö†Ô∏è MUY IMPORTANTE ‚Äì REGLA OBLIGATORIA PARA LEER LOGS
Cuando ejecutes comandos como:

    ./gradlew test --no-daemon
    ./gradlew build --no-daemon
    ./gradlew checkstyleMain --no-daemon
    ./gradlew check --no-daemon

NO uses grep, tail ni ning√∫n filtro como:

    | grep "FAILED"
    | grep -A 10
    | tail -3
    | tail -10

Estos comandos OCULTAN el log real y te impiden corregir los errores correctamente.

En su lugar:

1. Muestra el log COMPLETO del error.
2. Si el log es muy largo, NO lo recortes. En vez de eso, mu√©stralo completo y luego provee un RESUMEN manual con:
   ‚Ä¢ La excepci√≥n principal (tipo y mensaje)
   ‚Ä¢ ‚ÄúCaused by‚Äù
   ‚Ä¢ El archivo involucrado
   ‚Ä¢ La l√≠nea espec√≠fica
   ‚Ä¢ El m√≥dulo afectado (JUnit, Checkstyle, SpotBugs, Jacoco)
3. Usa esa informaci√≥n para:
   ‚Ä¢ Identificar el error real
   ‚Ä¢ Explicar la causa ra√≠z
   ‚Ä¢ Proponer y aplicar la correcci√≥n adecuada
   ‚Ä¢ Ejecutar el comando nuevamente hasta que pase sin errores

Nunca adivines soluciones sin ver el log completo. La depuraci√≥n SIEMPRE debe ser basada en el error exacto que muestra Gradle.


-------------------------------------------------------------------
1) TESTS DEL AGREGADO PaymentOrder (domain.model.PaymentOrderTest)
-------------------------------------------------------------------

Cubre al menos estos escenarios:

- Validaciones de creaci√≥n:
  - Creaci√≥n exitosa con campos v√°lidos.
  - Falla si:
    ‚Ä¢ paymentOrderReference es null/blank
    ‚Ä¢ externalReference es null
    ‚Ä¢ payerReference es null
    ‚Ä¢ payeeReference es null
    ‚Ä¢ instructedAmount es null o amount <= 0
    ‚Ä¢ requestedExecutionDate es null
    ‚Ä¢ createdAt null cuando es requerido
    ‚Ä¢ status null cuando sea requerido

- Reglas de negocio / transiciones de estado:
  ‚Ä¢ INITIATED ‚Üí PENDING / CANCELLED
  ‚Ä¢ PENDING ‚Üí PROCESSED / FAILED / CANCELLED
  ‚Ä¢ PROCESSED ‚Üí COMPLETED / FAILED
  ‚Ä¢ Transiciones inv√°lidas deben lanzar IllegalStateException
  ‚Ä¢ Estados finales (COMPLETED, FAILED, CANCELLED) no permiten m√°s cambios
  ‚Ä¢ updatedAt debe cambiar en cada transici√≥n v√°lida

- Buenas pr√°cticas:
  ‚Ä¢ Usa AAA (Arrange ‚Äì Act ‚Äì Assert)
  ‚Ä¢ Usa AssertJ: assertThat(), assertThatThrownBy(), etc.
  ‚Ä¢ Usa @DisplayName con descripciones claras
  ‚Ä¢ Usa builders/helpers para evitar repetir datos


-------------------------------------------------------------------
2) TESTS DE SERVICIOS DE APLICACI√ìN
-------------------------------------------------------------------

Clases sugeridas:
- InitiatePaymentOrderServiceTest
- RetrievePaymentOrderServiceTest
- RetrievePaymentOrderStatusServiceTest

Configuraci√≥n:
- @ExtendWith(MockitoExtension.class)
- @Mock PaymentOrderRepository
- @InjectMocks servicio bajo test

Casos m√≠nimos:

a) InitiatePaymentOrderServiceTest
- shouldInitiatePaymentOrderSuccessfully()
- shouldThrowExceptionWhenValidationFails()
- shouldUseExistingPaymentOrderReference()
- shouldNotSaveWhenOrderInvalid()

b) RetrievePaymentOrderServiceTest
- shouldRetrievePaymentOrderSuccessfully()
- shouldThrowWhenOrderNotFound()
- shouldThrowWhenReferenceIsNullOrBlank()

c) RetrievePaymentOrderStatusServiceTest
- Igual que retrieve, pero enfocado solo en status / lastUpdated.


-------------------------------------------------------------------
3) TESTS DE MAPPERS MAPSTRUCT (RECOMENDADO)
-------------------------------------------------------------------

Si existen mappers como PaymentOrderRestMapper o PaymentOrderPersistenceMapper, crear tests:

- shouldMapRequestToDomain()
- shouldMapDomainToInitiateResponse()
- shouldMapDomainToRetrieveResponse()
- shouldMapDomainToStatusResponse()

- shouldMapDomainToEntity()
- shouldMapEntityToDomain()
- shouldMapAllStatuses()


-------------------------------------------------------------------
4) CONVENCIONES DE TESTS
-------------------------------------------------------------------

‚Ä¢ Nombres estilo:
  should[Behavior]When[Condition]()
  shouldReturnXWhenY()

‚Ä¢ Usar @DisplayName con lenguaje natural

‚Ä¢ AssertJ obligatorio:
  assertThat()
  assertThatThrownBy()
  assertThat(list).hasSize()

‚Ä¢ Mockito:
  verify(repository).save(...)
  verify(repository, never()).save(...)
  when(findBy...).thenReturn(...)
  doThrow(...).when(...)


-------------------------------------------------------------------
5) COBERTURA ESPERADA
-------------------------------------------------------------------

- Dominio (Aggregate, Value Objects): 85‚Äì95%
- Servicios de Aplicaci√≥n: 90‚Äì100%
- Mappers: cubrir campos clave (IDs, referencias, monto, status)

‚ö†Ô∏è IMPORTANTE - Tests adicionales necesarios para alcanzar 85% de cobertura global:
Si despu√©s de crear los tests b√°sicos la cobertura no alcanza el 85% requerido (verificado en PASO 14), 
debes agregar tests adicionales para:

- PaymentOrderDomainService: tests para el m√©todo validate() (validaci√≥n exitosa, null check)
- GlobalExceptionHandler: tests para todos los handlers de excepciones (404, 400, 500, validaci√≥n, JSON malformado)
- PaymentOrderReferenceGenerator: tests para verificar formato correcto, unicidad, y cumplimiento del patr√≥n ^PO-[0-9]+$
- PaymentOrderRepositoryAdapter: tests para save() (nuevo y actualizaci√≥n), findByReference() (existe y no existe)
- Value Objects (ExternalReference, PayerReference, PayeeReference, PaymentAmount): tests para equals(), hashCode(), toString()
- PaymentOrder.changeStatus(): tests para casos edge (null status, transiciones a FAILED desde diferentes estados, transiciones a CANCELLED desde PROCESSED, etc.)

Estos tests adicionales son OBLIGATORIOS si la cobertura no alcanza 85% en el PASO 14.


-------------------------------------------------------------------
DOCUMENTACI√ìN IA
-------------------------------------------------------------------

Despu√©s de completar este paso, documenta:

- ai/prompts.md: registra este prompt y describe los tests creados.
- ai/decisions.md: documenta decisiones sobre estrategia de testing, cobertura objetivo y casos cr√≠ticos.

PASO 13 ‚Äì Tests de integraci√≥n del microservicio Payment Initiation

Configura y crea tests de integraci√≥n usando Spring Boot Test + WebTestClient, asegurando que los endpoints REST funcionen de extremo a extremo con H2 real, el contrato OpenAPI y la colecci√≥n Postman.

‚ö†Ô∏è MUY IMPORTANTE ‚Äì REGLA OBLIGATORIA PARA LEER LOGS (NO GREP / NO TAIL)
Al ejecutar comandos como:

    ./gradlew test --no-daemon
    ./gradlew build --no-daemon
    ./gradlew check --no-daemon

NO uses grep, tail ni filtros como:
    | grep "FAILED"
    | grep -A 10
    | tail -3
    | tail -10

Estos comandos OCULTAN informaci√≥n cr√≠tica del log, impiden encontrar fallos reales y hacen que no puedas corregir nada.

En su lugar:
1. Muestra SIEMPRE el log COMPLETO del error sin filtrar.
2. Si es muy largo, mu√©stralo completo y despu√©s haz un resumen con:
   ‚Ä¢ Excepci√≥n principal
   ‚Ä¢ "Caused by"
   ‚Ä¢ Archivo y l√≠nea afectados
   ‚Ä¢ Componente que fall√≥ (JUnit, Jackson, Checkstyle, WebTestClient, etc.)
3. Con esa informaci√≥n:
   ‚Ä¢ Identifica la causa real
   ‚Ä¢ Explica por qu√© ocurri√≥
   ‚Ä¢ Corrige √∫nicamente los archivos necesarios
   ‚Ä¢ Re-ejecuta `./gradlew test` hasta que pase sin errores

Nunca adivines soluciones sin ver el log completo.


---------------------------------------------------------------
CONFIGURACI√ìN GENERAL DEL TEST DE INTEGRACI√ìN
---------------------------------------------------------------

Crea la clase:

    src/test/java/.../adapter/in/rest/PaymentInitiationIntegrationTest

con el siguiente contenido base:

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class PaymentInitiationIntegrationTest {

    @Autowired
    private WebTestClient webTestClient;

    @Autowired
    private PaymentOrderJpaRepository repository;

    @BeforeEach
    void setUp() {
        repository.deleteAll(); // limpiar estado entre tests
    }
}
```

‚ö†Ô∏è CR√çTICO - Requisitos previos para tests de integraci√≥n:
- PaymentOrderEntity DEBE estar creada (PASO 8)
- PaymentOrderJpaRepository DEBE estar creada (PASO 8)
- PaymentOrderPersistenceMapper DEBE estar completamente implementado (PASO 8 o PASO 9)
- PaymentOrderRepositoryAdapter DEBE estar completamente implementado (PASO 8 o PASO 10)
- Sin estos componentes, los tests de integraci√≥n fallar√°n con UnsupportedOperationException.

Requisitos:
	‚Ä¢	Usar H2 real (configuraci√≥n de application.yml).
	‚Ä¢	No usar mocks en tests de integraci√≥n.
	‚Ä¢	Validar la aplicaci√≥n completa: controladores, mappers, servicios, repositorio, JPA, H2, validaciones y serializaci√≥n JSON.
	‚Ä¢	‚ö†Ô∏è IMPORTANTE: Los tests de integraci√≥n requieren que la persistencia est√© completamente implementada.
	  Si los tests fallan con UnsupportedOperationException, vuelve al PASO 8 y completa la implementaci√≥n.
TESTS A IMPLEMENTAR

1) POST /payment-initiation/payment-orders ‚Äì Creaci√≥n EXITOSA

Enviar JSON basado en Postman:

‚ö†Ô∏è IMPORTANTE - IBANs en tests:
Los IBANs en los payloads DEBEN cumplir con `minLength: 15` definido en OpenAPI.
Ejemplo CORRECTO (al menos 15 caracteres):
{
"externalReference": "EXT-1",
"debtorAccount": { "iban": "EC123456789012345678" },
"creditorAccount": { "iban": "EC987654321098765432" },
"instructedAmount": { "amount": 150.75, "currency": "USD" },
"remittanceInformation": "Factura 001-123",
"requestedExecutionDate": "2025-10-31"
}

Verificaciones:
	‚Ä¢	.expectStatus().isCreated()
	‚Ä¢	jsonPath("$.paymentOrderId").exists() (‚ö†Ô∏è NOTA: El campo en la respuesta es "paymentOrderId", no "paymentOrderReference")
	‚Ä¢	jsonPath("$.status").isEqualTo("ACCEPTED") (‚ö†Ô∏è NOTA: El estado en la respuesta es "ACCEPTED" seg√∫n OpenAPI, que mapea a INITIATED en el dominio)
	‚Ä¢	jsonPath("$.paymentOrderId").isNotEmpty()
	‚Ä¢	‚ö†Ô∏è IMPORTANTE: La respuesta InitiatePaymentOrderResponse solo contiene paymentOrderId y status, 
	  NO incluye debtorAccount, creditorAccount, instructedAmount ni createdAt. 
	  Para verificar esos campos, usa el endpoint GET /payment-initiation/payment-orders/{id} despu√©s de crear la orden.

2) GET /payment-initiation/payment-orders/{id} ‚Äì Recuperaci√≥n COMPLETA

Flujo:
	1.	Crear una orden via POST (capturar paymentOrderId del response)
	2.	Usar ese ID (paymentOrderId) en el GET
	‚ö†Ô∏è NOTA: El campo en la respuesta POST es "paymentOrderId", no "paymentOrderReference"

Verificaciones:
	‚Ä¢	.expectStatus().isOk()
	‚Ä¢	jsonPath("$.paymentOrderId").isEqualTo(createdId) (‚ö†Ô∏è NOTA: El campo en la respuesta es "paymentOrderId")
	‚Ä¢	jsonPath("$.externalReference").isEqualTo("EXT-1")
	‚Ä¢	jsonPath("$.debtorAccount.iban").isEqualTo("EC123456789012345678")
	‚Ä¢	jsonPath("$.creditorAccount.iban").isEqualTo("EC987654321098765432")
	‚Ä¢	jsonPath("$.instructedAmount.amount").isEqualTo(150.75)
	‚Ä¢	jsonPath("$.instructedAmount.currency").isEqualTo("USD")
	‚Ä¢	jsonPath("$.remittanceInformation").isEqualTo("Factura 001-123")
	‚Ä¢	jsonPath("$.requestedExecutionDate").isEqualTo("2025-10-31")
	‚Ä¢	jsonPath("$.status").isEqualTo("ACCEPTED")
	‚Ä¢	jsonPath("$.lastUpdate").exists() (‚ö†Ô∏è NOTA: El campo en la respuesta es "lastUpdate", no "lastUpdated" ni "createdAt")

3) GET /payment-initiation/payment-orders/{id}/status ‚Äì Solo estado

Verificaciones:
	‚Ä¢	.expectStatus().isOk()
	‚Ä¢	jsonPath("$.paymentOrderId").isEqualTo(createdId) (‚ö†Ô∏è NOTA: El campo en la respuesta es "paymentOrderId")
	‚Ä¢	jsonPath("$.status").isEqualTo("ACCEPTED") (‚ö†Ô∏è NOTA: El campo en la respuesta es "status", no "paymentOrderStatus")
	‚Ä¢	jsonPath("$.lastUpdate").exists() (‚ö†Ô∏è NOTA: El campo en la respuesta es "lastUpdate", no "lastUpdated")

4) Casos de ERROR (404, 400)

a) GET con ID inexistente ‚Üí 404
	‚Ä¢	.expectStatus().isNotFound()
	‚Ä¢	Validar ProblemDetail RFC 7807:
‚Ä¢ status = 404
‚Ä¢ title = "Payment Order Not Found"
‚Ä¢ detail contiene el ID
	‚Ä¢	‚ö†Ô∏è IMPORTANTE: El ID usado en el test DEBE cumplir con el patr√≥n `^PO-[0-9]+$` del OpenAPI.
	  Ejemplo CORRECTO: `"PO-99999999999999999999999999999999"` (solo n√∫meros)
	  Ejemplo INCORRECTO: `"PO-NONEXISTENT"` (contiene letras, causar√° ConstraintViolationException)

b) POST con body inv√°lido ‚Üí 400
Ejemplos:
	‚Ä¢	Falta debtorAccount
	‚Ä¢	Falta instructedAmount
	‚Ä¢	amount <= 0
	‚Ä¢	currency inv√°lida
	‚Ä¢	fecha incorrecta

Verificaciones:
	‚Ä¢	.expectStatus().isBadRequest()
	‚Ä¢	ProblemDetail:
‚Ä¢ status = 400
‚Ä¢ title = ‚ÄúBad Request‚Äù
‚Ä¢ detail describe el error

‚∏ª

MEJORES PR√ÅCTICAS OBLIGATORIAS CON WEBTESTCLIENT
	‚Ä¢	Usar AAA (Arrange ‚Äì Act ‚Äì Assert)
	‚Ä¢	Evitar .block()
	‚Ä¢	Limpiar H2 en cada @BeforeEach
	‚Ä¢	Para capturar el ID del POST:
‚ö†Ô∏è IMPORTANTE - Captura de valores en WebTestClient:
- NO uses `.value(String.class)` directamente, ya que no existe ese m√©todo en WebTestClient.
- En su lugar, usa un Consumer o un array para capturar el valor:
  ```java
  String[] paymentOrderReference = new String[1];
  webTestClient.post()
      .uri("/payment-initiation/payment-orders")
      .bodyValue(requestJson)
      .exchange()
      .expectStatus().isCreated()
      .expectBody()
      .jsonPath("$.paymentOrderId") (‚ö†Ô∏è NOTA: El campo en la respuesta es "paymentOrderId", no "paymentOrderReference")
      .value(ref -> paymentOrderReference[0] = ref.toString());
  // Usar paymentOrderReference[0] en tests posteriores
  ```
  O alternativamente, usa `.consumeWith()` para extraer el valor del response body.
	‚Ä¢	Reusar ese ID con transformaciones funcionales o variables locales.
	‚Ä¢	‚ö†Ô∏è IMPORTANTE - IBANs en tests:
	  - Los IBANs en los payloads de test DEBEN cumplir con `minLength: 15` definido en `openapi.yaml`.
	  - Ejemplo CORRECTO: `"EC123456789012345678"` (al menos 15 caracteres).
	  - Ejemplo INCORRECTO: `"EC12DEBTOR"` (solo 10 caracteres, causar√° error de validaci√≥n).
	‚Ä¢	‚ö†Ô∏è IMPORTANTE - Fechas en tests:
	  - Aseg√∫rate de que las fechas en los assertions coincidan EXACTAMENTE con las fechas en los request payloads.
	  - Si el request usa `"requestedExecutionDate": "2025-12-31"`, el assertion debe esperar `"2025-12-31"`, no `"2024-12-31"`.
	  - ‚ö†Ô∏è CR√çTICO: Las fechas DEBEN ser FUTURAS (no en el pasado) para pasar la validaci√≥n del dominio PaymentOrder.
	    El dominio valida que `requestedExecutionDate` no est√© en el pasado. Usa `LocalDate.now().plusDays(1).toString()` 
	    en lugar de fechas fijas como "2025-10-31" que pueden estar en el pasado dependiendo de la fecha actual.
	    Ejemplo CORRECTO: `"requestedExecutionDate": LocalDate.now().plusDays(1).toString()`
	    Ejemplo INCORRECTO: `"requestedExecutionDate": "2025-10-31"` (puede estar en el pasado y causar error de validaci√≥n)

    ‚∏ª

    CRITERIO DE √âXITO
El comando:
./gradlew test --no-daemon
debe pasar COMPLETAMENTE sin fallos.

‚ö†Ô∏è IMPORTANTE - Si los tests de integraci√≥n fallan:
- Si ves UnsupportedOperationException en PaymentOrderRepositoryAdapter, vuelve al PASO 8 y completa la implementaci√≥n de persistencia.
- Verifica que PaymentOrderEntity, PaymentOrderJpaRepository, PaymentOrderPersistenceMapper y PaymentOrderRepositoryAdapter est√©n completamente implementados.
- Ejecuta ./gradlew compileJava --no-daemon para verificar que no hay errores de compilaci√≥n.
- Los tests de validaci√≥n (400, 404) deber√≠an pasar incluso sin persistencia, pero los tests de √©xito (POST, GET) requieren persistencia completa.

Los endpoints deben comportarse exactamente seg√∫n:
	‚Ä¢	La colecci√≥n Postman
	‚Ä¢	El contrato OpenAPI
	‚Ä¢	El dominio Payment Initiation
	‚Ä¢	Las reglas de validaci√≥n

‚∏ª

DOCUMENTACI√ìN IA

Despu√©s de completar este paso debes documentar:
	‚Ä¢	ai/prompts.md
Registrar este prompt y los tests de integraci√≥n generados.
	‚Ä¢	ai/decisions.md
Explicar decisiones sobre:
‚Ä¢ uso de WebTestClient
‚Ä¢ casos de integraci√≥n cubiertos
‚Ä¢ alineaci√≥n con OpenAPI/Postman
‚Ä¢ manejo de errores y validaciones end-to-end

PASO 14 ‚Äì Calidad: JaCoCo, Checkstyle y SpotBugs
-------------------------------------------------
Prompt:

En build.gradle:

- Configura jacoco para generar reporte HTML y verificaci√≥n de cobertura m√≠nima (>= 85%).
  
- Excluir de cobertura JaCoCo:
  - C√≥digo generado (**/generated/**)
  - Entidades JPA (PaymentOrderEntity)
  - Implementaciones de MapStruct (*MapperImpl.class)
  - Clase principal (PaymentInitiationServiceApplication)
  - Configuraci√≥n (config/**)

‚ö†Ô∏è IMPORTANTE - Si la cobertura no alcanza 85%:
- Revisa el reporte HTML de JaCoCo para identificar qu√© componentes no est√°n cubiertos.
- Agrega tests adicionales para:
  - PaymentOrderDomainService (si falta)
  - GlobalExceptionHandler (si falta)
  - PaymentOrderReferenceGenerator (si falta)
  - PaymentOrderRepositoryAdapter (si falta)
  - Value Objects: equals(), hashCode(), toString() (si falta)
  - Casos edge en PaymentOrder.changeStatus() (null status, transiciones a FAILED/CANCELLED desde diferentes estados)
- Ejecuta `./gradlew test jacocoTestReport --no-daemon` para generar el reporte y verificar qu√© falta cubrir.
- Contin√∫a agregando tests hasta que `./gradlew jacocoTestCoverageVerification --no-daemon` pase sin errores.
  
- Configura checkstyle apuntando a config/checkstyle/checkstyle.xml:
  - maxWarnings: 100 (permite hasta 100 warnings por tarea antes de fallar, necesario para warnings aceptables como MagicNumber en tests, VisibilityModifier con Lombok, etc.)
  - Excluir c√≥digo generado en checkstyle.xml usando BeforeExecutionExclusionFileFilter:
    - Patr√≥n: "generated/.*"
    - Patr√≥n: ".*MapperImpl\.java$"
  - ‚ö†Ô∏è CR√çTICO - Configuraci√≥n del ImportOrder en checkstyle.xml:
    ```xml
    <module name="ImportOrder">
        <property name="groups" value="/^java\./,javax,jakarta,org,com"/>
        <property name="ordered" value="true"/>
        <property name="separated" value="true"/>
    </module>
    ```
    - Los grupos est√°n separados por comas sin espacios: `/^java\./,javax,jakarta,org,com`
    - `separated = true` requiere una l√≠nea en blanco entre grupos.
    - Los static imports se agrupan autom√°ticamente con su paquete base (ej: static org.assertj.* va con org.*).
    - Para m√°s detalles sobre el orden correcto, ver PASO 0 secci√≥n "‚ö†Ô∏è CR√çTICO - Orden de Imports en Checkstyle" y "‚ö†Ô∏è GU√çA COMPLETA - Orden de Imports (CR√çTICO)".
  
- Configura spotbugs con nivel de severidad alto:
  ‚ö†Ô∏è IMPORTANTE: NO uses strings directamente para effort y reportLevel.
  En su lugar, configura cada tarea individualmente:
  
  ```gradle
  tasks.named('spotbugsMain') {
      effort = com.github.spotbugs.snom.Effort.valueOf('MAX')
      reportLevel = com.github.spotbugs.snom.Confidence.valueOf('HIGH')
      excludeFilter = file("${rootProject.projectDir}/config/spotbugs/exclude.xml")
  }
  ```
  
  Crea config/spotbugs/exclude.xml para excluir:
  - C√≥digo generado (com.bank.paymentinitiation.generated)
  - Implementaciones MapStruct (*MapperImpl)
  - Entidades JPA (PaymentOrderEntity)
  - Clase principal (PaymentInitiationServiceApplication)

- Configura el task check:
  ```gradle
  check {
      dependsOn 'checkstyleMain'
      dependsOn 'checkstyleTest'
      dependsOn 'spotbugsMain'
      dependsOn 'spotbugsTest'
      dependsOn 'test'
      dependsOn 'jacocoTestCoverageVerification'
      finalizedBy 'jacocoTestReport'  // Ejecuta despu√©s de los tests
  }
  ```
  ‚ö†Ô∏è NOTA: jacocoTestReport depende de test, as√≠ que se ejecuta despu√©s (finalizedBy) 
  para evitar dependencias circulares.
  
  ‚ö†Ô∏è IMPORTANTE - Ejecutar checkstyle antes de continuar:
  - Despu√©s de cada cambio en c√≥digo, ejecuta primero:
    ```bash
    ./gradlew checkstyleMain checkstyleTest --no-daemon
    ```
  - Si hay errores de ImportOrder, corr√≠gelos INMEDIATAMENTE antes de continuar.
  - Solo contin√∫a al siguiente paso cuando checkstyleMain y checkstyleTest pasen sin errores.

‚ö†Ô∏è GU√çA COMPLETA - Orden de Imports (CR√çTICO):
Para evitar errores de Checkstyle, SIEMPRE sigue este orden estricto:

1. **Grupo java.*** (sin separaci√≥n entre imports del mismo grupo):
   ```java
   import java.math.BigDecimal;
   import java.time.LocalDate;
   import java.time.LocalDateTime;
   ```

2. **L√≠nea en blanco** (separaci√≥n obligatoria)

3. **Grupo jakarta.*** (o javax.*):
   ```java
   import jakarta.validation.Valid;
   import jakarta.persistence.Entity;
   ```

4. **L√≠nea en blanco** (separaci√≥n obligatoria)

5. **Grupo org.*** (imports normales primero):
   ```java
   import org.junit.jupiter.api.Test;
   import org.springframework.web.bind.annotation.RestController;
   ```

6. **Static imports del grupo org.*** (sin l√≠nea en blanco, dentro del mismo grupo):
   ```java
   import static org.assertj.core.api.Assertions.assertThat;
   import static org.mockito.Mockito.verify;
   ```

7. **L√≠nea en blanco** (separaci√≥n obligatoria)

8. **Grupo com.***:
   ```java
   import com.bank.paymentinitiation.domain.model.PaymentOrder;
   import com.bank.paymentinitiation.application.service.InitiatePaymentOrderService;
   ```

9. **L√≠nea en blanco** (separaci√≥n obligatoria)

10. **Lombok** (si existe, generalmente al final):
    ```java
    import lombok.RequiredArgsConstructor;
    import lombok.extern.slf4j.Slf4j;
    ```

Ejemplo COMPLETO y CORRECTO:
```java
package com.bank.paymentinitiation.adapter.in.rest;

import java.time.LocalDateTime;

import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;
import static org.assertj.core.api.Assertions.assertThat;

import com.bank.paymentinitiation.domain.model.PaymentOrder;
import com.bank.paymentinitiation.generated.api.PaymentOrdersApi;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
```

Errores COMUNES a evitar:
- ‚ùå Poner jakarta.* despu√©s de org.*
- ‚ùå Poner static imports despu√©s de com.*
- ‚ùå No separar grupos con l√≠nea en blanco
- ‚ùå Separar static imports de org.* con l√≠nea en blanco antes de com.*
- ‚ùå Poner lombok entre jakarta.* y org.*

No seas extremo con las reglas pero s√≠ suficiente para que el c√≥digo est√© ordenado.

‚ö†Ô∏è VERIFICACI√ìN FINAL DE COBERTURA:
Despu√©s de configurar JaCoCo, ejecuta:
1. `./gradlew test jacocoTestReport --no-daemon` (genera reporte HTML)
2. Revisa `build/reports/jacoco/test/html/index.html` para identificar componentes sin cobertura
3. Si la cobertura es < 85%, agrega tests adicionales seg√∫n las instrucciones del PASO 12
4. Ejecuta `./gradlew jacocoTestCoverageVerification --no-daemon` hasta que pase
5. Ejecuta `./gradlew check --no-daemon` para verificar todos los quality gates

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la configuraci√≥n de quality gates generada
- ai/decisions.md: Documenta todas las correcciones manuales aplicadas (SpotBugs, Checkstyle, JaCoCo), exclusiones de c√≥digo generado, y ajustes de cobertura m√≠nima
- ai/generations/: Opcionalmente guarda archivos de configuraci√≥n generados (checkstyle.xml, exclude.xml de SpotBugs) si hubo cambios significativos


PASO 15 ‚Äì Docker y docker-compose
---------------------------------
Prompt:

Crea un Dockerfile multi-stage para Gradle + Java 21:

- Stage builder: eclipse-temurin:21-jdk-alpine
  - Copia archivos de configuraci√≥n (gradle/, gradlew, build.gradle, settings.gradle)
  - Copia c√≥digo fuente (src/, openapi/, config/)
  - Da permisos de ejecuci√≥n a gradlew (chmod +x gradlew)
  - Compila con ./gradlew clean build -x test --no-daemon
  - Verifica que se gener√≥ el JAR con ls -la build/libs/

- Stage runtime: eclipse-temurin:21-jre-alpine
  - Instala wget para health checks (apk add --no-cache wget)
  - Crea usuario no-root para seguridad (addgroup/adduser spring)
  - Copia el JAR desde builder: payment-initiation-service-0.0.1-SNAPSHOT.jar ‚Üí app.jar
  - Usa usuario no-root (USER spring:spring)
  - Expone puerto 8080 (EXPOSE 8080)
  - Configura HEALTHCHECK usando /actuator/health
  - ENTRYPOINT: java -jar app.jar

Crea docker-compose.yml con un servicio payment-initiation-service que:

- build: context: ., dockerfile: Dockerfile
- container_name: payment-initiation-service
- ports: "8080:8080"
- environment:
  - SPRING_PROFILES_ACTIVE=docker
  - JAVA_OPTS=-Xmx512m -Xms256m
- healthcheck: usando wget con /actuator/health
- restart: unless-stopped
- networks: payment-network (bridge)

‚ö†Ô∏è IMPORTANTE: Crea .dockerignore para excluir:
- build/, .gradle/, out/
- .idea/, .vscode/, *.iml
- .git/
- Dockerfile, docker-compose.yml
- **/test-results/, **/reports/
- ai/ (documentaci√≥n, no necesario en runtime)

No necesitas otro contenedor de DB porque H2 es embebido.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y los archivos Docker generados
- ai/decisions.md: Documenta decisiones sobre Dockerfile multi-stage, docker-compose.yml, y .dockerignore
- ai/generations/: Opcionalmente guarda Dockerfile y docker-compose.yml iniciales si hubo cambios significativos


PASO 16 ‚Äì README y documentaci√≥n de IA
--------------------------------------
Prompt:

Crea README.md con:

1) Descripci√≥n del proyecto (BIAN Payment Initiation / PaymentOrder, migraci√≥n de SOAP a REST).
2) Arquitectura hexagonal y estructura de paquetes.
3) Stack t√©cnico (Java 21, Spring Boot 3, H2, JPA, Gradle, MapStruct, OpenAPI, WebTestClient, JaCoCo, Checkstyle, SpotBugs, Docker).
4) C√≥mo ejecutar:
   - ./gradlew clean check
   - ./gradlew bootRun
   - docker compose up --build
5) C√≥mo probar con Postman (referencia a postman_collection.json).
6) Uso de IA (descripci√≥n de carpeta ai/, qu√© se ha documentado).

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el README generado
- ai/decisions.md: Opcionalmente documenta decisiones finales sobre la estructura del README
- Verifica que toda la documentaci√≥n en ai/ est√° completa y actualizada

