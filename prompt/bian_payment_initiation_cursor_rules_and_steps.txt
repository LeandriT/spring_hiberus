BIAN PAYMENT INITIATION ‚Äì CURSOR PRO PLAYBOOK (JAVA 21)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

NOTA IMPORTANTE: Este playbook ha sido refinado y ajustado bas√°ndose en la implementaci√≥n 
exitosa del challenge. Incluye todas las correcciones y mejoras identificadas durante el 
desarrollo, incluyendo soluciones a problemas comunes con SpotBugs, MapStruct, Checkstyle, 
JaCoCo y configuraci√≥n de Docker.

Versi√≥n: 1.1 (Refinada post-implementaci√≥n)
√öltima actualizaci√≥n: Noviembre 2024

======================================================
SECCI√ìN A ‚Äì PASOS PARA IMPLEMENTAR EL CHALLENGE CON CURSOR
======================================================

Contexto r√°pido
---------------
- Dominio BIAN: Payment Initiation
- BQ principal: PaymentOrder
- Migraci√≥n: SOAP ‚Üí REST (BIAN-aligned)
- Arquitectura: Hexagonal (Ports & Adapters)
- Enfoque: Contract-First con OpenAPI 3.0
- Stack:
  - Java 21
  - Spring Boot 3 (Spring MVC, NO WebFlux en runtime)
  - H2 como base de datos
  - Gradle (Groovy DSL)
  - MapStruct para mapeos
  - WebTestClient para tests de integraci√≥n
- Artefactos de soporte:
  - WSDL legacy: PaymentOrderService.wsdl
  - XML ejemplos: SubmitPaymentOrder / GetPaymentOrderStatus (request/response)
  - Colecci√≥n Postman: postman_collection.json (endpoints REST a validar)

Los siguientes pasos est√°n pensados para copiarlos en Cursor Pro por bloques y dejar que genere el c√≥digo, mientras t√∫ revisas, corriges y documentas el uso de IA en la carpeta ai/.

‚ö†Ô∏è INSTRUCCIONES DE USO:
1. Copia cada PASO individualmente en Cursor Pro.
2. Revisa el c√≥digo generado antes de continuar al siguiente paso.
3. Ejecuta tests despu√©s de cada paso cr√≠tico (PASO 4, PASO 9, PASO 10, etc.).
4. Documenta cualquier correcci√≥n manual en ai/decisions.md.
5. Los pasos marcados con ‚ö†Ô∏è IMPORTANTE contienen correcciones cr√≠ticas que deben aplicarse.


PASO 0 ‚Äì Crear proyecto base (Java 21 + Gradle + Spring MVC + H2)
-----------------------------------------------------------------
Prompt para Cursor:

Crea un proyecto Spring Boot 3 con Java 21 usando Gradle (Groovy DSL):

- Nombre del proyecto: payment-initiation-service
- Group: com.bank.paymentinitiation
- Paquete base: com.bank.paymentinitiation

En build.gradle configura:
- Plugins:
  - id 'java'
  - id 'org.springframework.boot' version '3.2.0'
  - id 'io.spring.dependency-management' version '1.1.4'
  - id 'org.openapi.generator' version '7.0.1'
  - id 'checkstyle'
  - id 'com.github.spotbugs' version '6.0.0'
  - id 'jacoco'

- Java 21:
  - sourceCompatibility = JavaVersion.VERSION_21
  - targetCompatibility = JavaVersion.VERSION_21

- Dependencias principales:
  - implementation 'org.springframework.boot:spring-boot-starter-web'           // Spring MVC
  - implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
  - implementation 'org.springframework.boot:spring-boot-starter-validation'
  - implementation 'org.springframework.boot:spring-boot-starter-actuator'
  - runtimeOnly  'com.h2database:h2'
  - MapStruct:
    - implementation "org.mapstruct:mapstruct:1.5.5.Final"
    - annotationProcessor "org.mapstruct:mapstruct-processor:1.5.5.Final"
  - Lombok:
    - compileOnly "org.projectlombok:lombok:1.18.30"
    - annotationProcessor "org.projectlombok:lombok:1.18.30"
    - annotationProcessor "org.projectlombok:lombok-mapstruct-binding:0.2.0"
  - Tests:
    - testImplementation 'org.springframework.boot:spring-boot-starter-test'
    - testImplementation 'org.springframework:spring-webflux'   // solo para WebTestClient

Configura test { useJUnitPlatform() } y jacoco b√°sico. 

‚ö†Ô∏è IMPORTANTE - Correcciones manuales necesarias:
- SpotBugs: NO configures `effort` y `reportLevel` en el bloque `spotbugs {}` directamente como strings. 
  Estos deben configurarse en las tareas individuales usando `Effort.valueOf('MAX')` y `Confidence.valueOf('HIGH')`.
- Ver configuraci√≥n detallada en PASO 14.

Aseg√∫rate de que ./gradlew clean build compila correctamente.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y lo que gener√≥ la IA
- ai/decisions.md: Documenta cualquier correcci√≥n manual aplicada (ej: configuraci√≥n de SpotBugs)


PASO 1 ‚Äì Carpeta de evidencias de IA
------------------------------------
Crea en la ra√≠z del proyecto (junto a build.gradle):

- ai/prompts.md      ‚Üí lista de prompts usados (incluye los que uses con Cursor).
- ai/decisions.md    ‚Üí decisiones de dise√±o, correcciones manuales, trade-offs.
- ai/generations/    ‚Üí fragmentos relevantes generados por IA (por ejemplo openapi.yaml, controladores, etc.).

Inicializa los .md con t√≠tulos y una peque√±a descripci√≥n de c√≥mo se documentar√° el uso de IA.


PASO 2 ‚Äì Analizar el WSDL y los XML legacy
------------------------------------------
Usa PaymentOrderService.wsdl, SubmitPaymentOrder*.xml y GetPaymentOrderStatus*.xml como entrada.

Prompt sugerido para Cursor:

Analiza el archivo PaymentOrderService.wsdl y los XML de ejemplo (SubmitPaymentOrderRequest/Response, GetPaymentOrderStatusRequest/Response) y dame:

1) Operaciones SOAP disponibles relacionadas con √≥rdenes de pago.
2) Estructuras de datos principales (campos clave) de la orden de pago.
3) Estados posibles de la orden de pago en el servicio legacy.
4) Un mapeo de estos conceptos al Service Domain BIAN Payment Initiation y al BQ PaymentOrder.
5) Qu√© campos podemos ignorar para el alcance m√≠nimo del challenge.

Resume y copia el resultado en ai/decisions.md.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el an√°lisis generado
- ai/decisions.md: Guarda el resultado completo del an√°lisis del WSDL y mapeo a BIAN
- ai/generations/: Opcionalmente guarda el WSDL analizado si es relevante


PASO 3 ‚Äì Dise√±ar el contrato OpenAPI 3.0 (contract-first, alineado con Postman)
-------------------------------------------------------------------------------
Bas√°ndote en el an√°lisis del WSDL y la colecci√≥n postman_collection.json (endpoints):

- POST http://localhost:8080/payment-initiation/payment-orders
- GET  http://localhost:8080/payment-initiation/payment-orders/{id}
- GET  http://localhost:8080/payment-initiation/payment-orders/{id}/status

Prompt para Cursor:

Genera un archivo openapi/openapi.yaml con OpenAPI 3.0 que defina:

- servers:
  - url: http://localhost:8080
- paths:
  - POST /payment-initiation/payment-orders
    - operationId: initiatePaymentOrder
    - requestBody con esquema InitiatePaymentOrderRequest con campos alineados a la colecci√≥n Postman:
      - externalReference
      - debtorAccount { iban }
      - creditorAccount { iban }
      - instructedAmount { amount, currency }
      - remittanceInformation
      - requestedExecutionDate (date)
    - responses:
      - 201: InitiatePaymentOrderResponse
      - 400, 500 en formato application/problem+json
  - GET /payment-initiation/payment-orders/{id}
    - operationId: retrievePaymentOrder
    - 200: RetrievePaymentOrderResponse
    - 404: ProblemDetail
  - GET /payment-initiation/payment-orders/{id}/status
    - operationId: retrievePaymentOrderStatus
    - 200: PaymentOrderStatusResponse
    - 404: ProblemDetail

Define schemas:

- InitiatePaymentOrderRequest
- InitiatePaymentOrderResponse
- RetrievePaymentOrderResponse
- PaymentOrderStatusResponse
- PaymentAmount (value/currency)
- ProblemDetail (RFC 7807)

Entregame el contenido completo de openapi/openapi.yaml listo para guardar.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el contrato OpenAPI generado
- ai/decisions.md: Documenta decisiones de dise√±o del contrato (endpoints, schemas, validaciones)
- ai/generations/: Guarda una copia del openapi.yaml inicial generado por IA con comentarios sobre qu√© se mantuvo y qu√© se modific√≥


PASO 4 ‚Äì Configurar OpenAPI Generator en Gradle
-----------------------------------------------
Prompt:

En build.gradle, configura la tarea openApiGenerate:

- generatorName = 'spring'
- inputSpec   = "$rootDir/openapi/openapi.yaml"
- outputDir   = "$buildDir/generated"
- apiPackage  = 'com.bank.paymentinitiation.generated.api'
- modelPackage = 'com.bank.paymentinitiation.generated.model'
- invokerPackage = 'com.bank.paymentinitiation.generated.invoker'
- configOptions:
  - interfaceOnly = 'true'
  - useSpringBoot3 = 'true'
  - useTags = 'true'
  - dateLibrary = 'java8'
  - serializationLibrary = 'jackson'
  - hideGenerationTimestamp = 'true'

A√±ade la carpeta generada como source set:

- sourceSets.main.java.srcDir("$buildDir/generated/src/main/java")

Y haz que compileJava dependa de openApiGenerate.

‚ö†Ô∏è IMPORTANTE - Dependencias necesarias para c√≥digo generado:
Agrega estas dependencias adicionales que requiere el c√≥digo generado por OpenAPI:

- implementation "io.swagger.core.v3:swagger-annotations:2.2.21"
- implementation "org.openapitools:jackson-databind-nullable:0.2.6"
- implementation "jakarta.validation:jakarta.validation-api:3.0.2"
- implementation "jakarta.annotation:jakarta.annotation-api:2.1.1"

Comprueba que ./gradlew openApiGenerate && ./gradlew compileJava funciona sin errores.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la configuraci√≥n de OpenAPI Generator generada
- ai/decisions.md: Documenta las dependencias adicionales agregadas y por qu√© fueron necesarias


PASO 5 ‚Äì Estructura de paquetes (Hexagonal)
-------------------------------------------
Prompt:

Crea la siguiente estructura de paquetes bajo com.bank.paymentinitiation:

- domain
  - model
  - port.in
  - port.out
  - exception
  - service
- application
  - service
  - mapper (opcional)
- adapter.in.rest
  - dto (los modelos generados van en generated.model, aqu√≠ solo wrappers si los necesitas)
  - mapper
- adapter.out.persistence
  - entity
  - jpa
  - mapper
  - PaymentOrderRepositoryAdapter
- config

Crea clases vac√≠as (o interfaces) con javadoc describiendo su rol, sin meter a√∫n mucha l√≥gica.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la estructura de paquetes generada
- ai/decisions.md: Documenta la decisi√≥n de usar arquitectura hexagonal y la organizaci√≥n de paquetes


PASO 6 ‚Äì Modelo de dominio BIAN (PaymentOrder)
----------------------------------------------
Prompt:

En com.bank.paymentinitiation.domain.model crea:

- Enum PaymentStatus con valores: INITIATED, PENDING, PROCESSED, COMPLETED, FAILED, CANCELLED.
- Value object PaymentAmount (BigDecimal value, String currency) con factor√≠a est√°tica que valide que value > 0.
- Value objects PayerReference, PayeeReference, ExternalReference (strings no vac√≠os).
- Aggregate root PaymentOrder con campos:
  - String paymentOrderReference
  - ExternalReference externalReference
  - PayerReference payerReference
  - PayeeReference payeeReference
  - PaymentAmount instructedAmount
  - String remittanceInformation
  - LocalDate requestedExecutionDate
  - PaymentStatus status
  - LocalDateTime createdAt
  - LocalDateTime updatedAt

Incluye m√©todos de dominio para:
- validar el agregado (validate())
- iniciar la orden (marcar INITIATED)
- cambiar estado respetando una secuencia razonable (por ejemplo INITIATED ‚Üí PENDING ‚Üí PROCESSED ‚Üí COMPLETED).

No uses anotaciones de Spring en el dominio. Usa Lombok (@Value/@Builder) cuando tenga sentido.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el modelo de dominio generado
- ai/decisions.md: Documenta decisiones sobre value objects, estados del enum PaymentStatus, y m√©todos de dominio
- ai/generations/: Opcionalmente guarda clases del dominio generadas inicialmente si hubo cambios significativos


PASO 7 ‚Äì Puertos de dominio (ports in/out) y servicios de aplicaci√≥n
--------------------------------------------------------------------
Prompt:

En domain.port.in crea interfaces:

- InitiatePaymentOrderUseCase
  - PaymentOrder initiate(PaymentOrder order);
- RetrievePaymentOrderUseCase
  - PaymentOrder retrieve(String paymentOrderReference);
- RetrievePaymentOrderStatusUseCase
  - PaymentStatus retrieveStatus(String paymentOrderReference);

En domain.port.out crea:

- PaymentOrderRepository
  - PaymentOrder save(PaymentOrder order);
  - Optional<PaymentOrder> findByReference(String paymentOrderReference);

En application.service crea implementaciones de estos casos de uso que:
- Inyectan PaymentOrderRepository (port out).
- Aplican reglas de negocio b√°sicas y delegan en el repositorio.
- Lanzan excepciones de dominio (PaymentOrderNotFoundException, InvalidPaymentException) cuando aplique.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y los puertos/servicios generados
- ai/decisions.md: Documenta decisiones sobre la separaci√≥n de puertos in/out y la implementaci√≥n de servicios de aplicaci√≥n


PASO 8 ‚Äì H2 + JPA (entidad y repositorio)
-----------------------------------------
Prompt:

Configura application.yml para H2 en memoria:

spring:
  datasource:
    url: jdbc:h2:mem:paymentdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
      path: /h2-console
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: false
    properties:
      hibernate:
        format_sql: true

En adapter.out.persistence.entity crea PaymentOrderEntity con campos equivalentes al dominio, usando @Entity y @Table. Usa UUID como id t√©cnico y paymentOrderReference como identificador de negocio √∫nico.

En adapter.out.persistence.jpa crea PaymentOrderJpaRepository extends JpaRepository<PaymentOrderEntity, UUID> con m√©todo:
- Optional<PaymentOrderEntity> findByPaymentOrderReference(String paymentOrderReference);

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la configuraci√≥n de H2/JPA generada
- ai/decisions.md: Documenta decisiones sobre la estructura de la entidad JPA, uso de UUID vs paymentOrderReference, y configuraci√≥n de H2


PASO 9 ‚Äì MapStruct para mapeos (REST ‚Üî Dominio ‚Üî Entidad)
----------------------------------------------------------
Prompt:

Configura MapStruct usando:

- implementation "org.mapstruct:mapstruct:1.5.5.Final"
- annotationProcessor "org.mapstruct:mapstruct-processor:1.5.5.Final"

Crea en adapter.in.rest.mapper:

- PaymentOrderRestMapper con m√©todos:
  - PaymentOrder toDomain(InitiatePaymentOrderRequest request);
  - InitiatePaymentOrderResponse toInitiateResponse(PaymentOrder domain);
  - RetrievePaymentOrderResponse toRetrieveResponse(PaymentOrder domain);
  - PaymentOrderStatusResponse toStatusResponse(PaymentOrder domain);

Crea en adapter.out.persistence.mapper:

- PaymentOrderPersistenceMapper con m√©todos:
  - PaymentOrderEntity toEntity(PaymentOrder domain);
  - PaymentOrder toDomain(PaymentOrderEntity entity);

Usa @Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR).

‚ö†Ô∏è IMPORTANTE - Evitar ambig√ºedades de tipos:
- En los mappers MapStruct, usa nombres completamente calificados (fully qualified names) para tipos 
  que tienen el mismo nombre en diferentes paquetes (ej: PaymentAmount, PaymentStatus en dominio vs generated.model).
- Ejemplo: usa `com.bank.paymentinitiation.domain.model.PaymentAmount` en lugar de solo `PaymentAmount` 
  cuando hay ambig√ºedad entre dominio y DTOs generados.
- Para m√©todos `toDomain(InitiatePaymentOrderRequest request, String paymentOrderReference)`, 
  el mapper debe recibir el `paymentOrderReference` como par√°metro adicional porque se genera 
  en el controlador, no en el mapper.

‚ö†Ô∏è Conversi√≥n de timestamps:
- Agrega m√©todos @Named para convertir LocalDateTime ‚Üí OffsetDateTime en mappers REST, 
  ya que los DTOs de OpenAPI usan OffsetDateTime pero el dominio usa LocalDateTime.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y los mappers MapStruct generados
- ai/decisions.md: Documenta las correcciones manuales aplicadas (ambig√ºedades de tipos, conversiones de timestamps, m√©todos custom)
- ai/generations/: Opcionalmente guarda mappers generados inicialmente si hubo cambios significativos


PASO 10 ‚Äì Adaptador REST (implementando interfaces generadas)
-------------------------------------------------------------
Prompt:

Usando las interfaces generadas en com.bank.paymentinitiation.generated.api, crea PaymentOrdersController en adapter.in.rest que:

- Implemente PaymentOrdersApi (el nombre generado por OpenAPI).
- Inyecte los use cases, PaymentOrderRestMapper y PaymentOrderReferenceGenerator.
- Para POST /payment-initiation/payment-orders:
  - Reciba InitiatePaymentOrderRequest con @Valid.
  - Genere paymentOrderReference usando PaymentOrderReferenceGenerator.
  - Mapee DTO ‚Üí dominio usando `mapper.toDomain(request, paymentOrderReference)`.
  - Llame InitiatePaymentOrderUseCase, mapee dominio ‚Üí InitiatePaymentOrderResponse.
  - Devuelva ResponseEntity.status(HttpStatus.CREATED).body(response).
- Para GET /payment-initiation/payment-orders/{id}:
  - Llame RetrievePaymentOrderUseCase, mapee dominio ‚Üí RetrievePaymentOrderResponse.
  - Devuelva ResponseEntity.ok(response).
- Para GET /payment-initiation/payment-orders/{id}/status:
  - Llame RetrievePaymentOrderUseCase (necesita orden completa para mapear a response con paymentOrderReference y lastUpdated).
  - Mapee dominio ‚Üí PaymentOrderStatusResponse usando mapper.toStatusResponse().
  - Devuelva ResponseEntity.ok(response).
  - ‚ö†Ô∏è NOTA: Aunque existe RetrievePaymentOrderStatusUseCase que retorna solo PaymentStatus, 
    el controlador usa RetrievePaymentOrderUseCase porque necesita la orden completa para 
    incluir paymentOrderReference y lastUpdated en la respuesta.

‚ö†Ô∏è IMPORTANTE - Servicios necesarios:
1. Crea PaymentOrderReferenceGenerator en application.service:
   - Componente Spring que genera referencias √∫nicas en formato "PO-{UUID compacto}".
   - Usa UUID.randomUUID() y formatea como "PO-XXXXXXXX" (ejemplo: "PO-A1B2C3D4E5F6G7H8").

2. Crea ApplicationConfig en config/:
   - Clase de configuraci√≥n Spring con @Configuration.
   - Define beans para InitiatePaymentOrderService, RetrievePaymentOrderService, RetrievePaymentOrderStatusService.
   - Estos servicios reciben PaymentOrderRepository (que ser√° inyectado autom√°ticamente por Spring).

3. Completa PaymentOrderRepositoryAdapter:
   - Debe tener @Component para ser detectado por Spring.
   - Implementa los m√©todos save() y findByReference() usando PaymentOrderJpaRepository y PaymentOrderPersistenceMapper.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el controlador REST generado
- ai/decisions.md: Documenta decisiones sobre PaymentOrderReferenceGenerator, ApplicationConfig, y la implementaci√≥n del controlador
- ai/generations/: Opcionalmente guarda el controlador generado inicialmente si hubo cambios significativos


PASO 11 ‚Äì Manejo global de errores (RFC 7807)
---------------------------------------------
Prompt:

Crea en adapter.in.rest un @RestControllerAdvice GlobalExceptionHandler que maneje:

- PaymentOrderNotFoundException ‚Üí 404 NOT FOUND, body ProblemDetail con title "Payment Order Not Found".
- InvalidPaymentException ‚Üí 400 BAD REQUEST, body ProblemDetail con title "Invalid Payment Order".
- Exception gen√©rica ‚Üí 500 INTERNAL SERVER ERROR.

Usa org.springframework.http.ProblemDetail (Spring 6+). Todos los errores deben tener content-type application/problem+json.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el GlobalExceptionHandler generado
- ai/decisions.md: Documenta decisiones sobre el manejo de errores RFC 7807 y el mapeo de excepciones de dominio a HTTP


PASO 12 ‚Äì Tests unitarios (dominio, casos de uso, mappers)
----------------------------------------------------------
Prompt:

Crea tests unitarios con JUnit 5 y AssertJ para:

- Aggregate PaymentOrder (validaciones, cambios de estado, excepciones).
- Servicios de aplicaci√≥n (Initiate/Retrieve/Status):
  - Mockean PaymentOrderRepository.
  - Verifican que se llama save/findByReference y se manejan errores correctamente.
- Mappers MapStruct (opcional pero recomendable):
  - Verifican que los campos clave se mapean bien entre DTO ‚Üî Dominio y Dominio ‚Üî Entidad.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y los tests unitarios generados
- ai/decisions.md: Documenta decisiones sobre la estrategia de testing, cobertura esperada, y casos de prueba importantes


PASO 13 ‚Äì Tests de integraci√≥n con WebTestClient (Spring MVC)
--------------------------------------------------------------
Prompt:

Configura tests de integraci√≥n:

- Clase PaymentInitiationIntegrationTest con:
  - @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
  - @AutoConfigureWebTestClient
  - Inyecci√≥n de WebTestClient.
- Usar H2 real (la config por defecto).

Escribe tests que cubran:

1) POST /payment-initiation/payment-orders
   - Env√≠a un JSON v√°lido alineado con la colecci√≥n Postman.
   - Espera .expectStatus().isCreated().
   - Verifica contenido de InitiatePaymentOrderResponse (paymentOrderReference, status INITIATED, etc.).

2) GET /payment-initiation/payment-orders/{id}
   - Crea primero una orden (por repositorio o reusando el POST).
   - Espera .expectStatus().isOk().
   - Verifica que los campos coinciden.

3) GET /payment-initiation/payment-orders/{id}/status
   - Espera .expectStatus().isOk().
   - Verifica paymentOrderStatus y lastUpdated.

4) Casos de error (404, 400):
   - GET con id inexistente ‚Üí 404.
   - POST con body inv√°lido ‚Üí 400.

Aseg√∫rate de que ./gradlew test pasa correctamente.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y los tests de integraci√≥n generados
- ai/decisions.md: Documenta decisiones sobre el uso de WebTestClient, casos de prueba de integraci√≥n, y alineaci√≥n con la colecci√≥n Postman


PASO 14 ‚Äì Calidad: JaCoCo, Checkstyle y SpotBugs
-------------------------------------------------
Prompt:

En build.gradle:

- Configura jacoco para generar reporte HTML y verificaci√≥n de cobertura m√≠nima (>= 75%).
  ‚ö†Ô∏è NOTA: Se ajust√≥ a 75% para ser m√°s realista. Puedes subirlo a 80% si aumentas la cobertura de tests.
  
- Excluir de cobertura JaCoCo:
  - C√≥digo generado (**/generated/**)
  - Entidades JPA (PaymentOrderEntity)
  - Implementaciones de MapStruct (*MapperImpl.class)
  - Clase principal (PaymentInitiationServiceApplication)
  - Configuraci√≥n (config/**)
  
- Configura checkstyle apuntando a config/checkstyle/checkstyle.xml:
  - maxWarnings: 10 (permite algunos warnings antes de fallar)
  - Excluir c√≥digo generado en checkstyle.xml usando BeforeExecutionExclusionFileFilter:
    - Patr√≥n: "generated/.*"
    - Patr√≥n: ".*MapperImpl\.java$"
  
- Configura spotbugs con nivel de severidad alto:
  ‚ö†Ô∏è IMPORTANTE: NO uses strings directamente para effort y reportLevel.
  En su lugar, configura cada tarea individualmente:
  
  ```gradle
  tasks.named('spotbugsMain') {
      effort = com.github.spotbugs.snom.Effort.valueOf('MAX')
      reportLevel = com.github.spotbugs.snom.Confidence.valueOf('HIGH')
      excludeFilter = file("${rootProject.projectDir}/config/spotbugs/exclude.xml")
  }
  ```
  
  Crea config/spotbugs/exclude.xml para excluir:
  - C√≥digo generado (com.bank.paymentinitiation.generated)
  - Implementaciones MapStruct (*MapperImpl)
  - Entidades JPA (PaymentOrderEntity)
  - Clase principal (PaymentInitiationServiceApplication)

- Configura el task check:
  ```gradle
  check {
      dependsOn 'checkstyleMain'
      dependsOn 'checkstyleTest'
      dependsOn 'spotbugsMain'
      dependsOn 'spotbugsTest'
      dependsOn 'test'
      dependsOn 'jacocoTestCoverageVerification'
      finalizedBy 'jacocoTestReport'  // Ejecuta despu√©s de los tests
  }
  ```
  ‚ö†Ô∏è NOTA: jacocoTestReport depende de test, as√≠ que se ejecuta despu√©s (finalizedBy) 
  para evitar dependencias circulares.

No seas extremo con las reglas pero s√≠ suficiente para que el c√≥digo est√© ordenado.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y la configuraci√≥n de quality gates generada
- ai/decisions.md: Documenta todas las correcciones manuales aplicadas (SpotBugs, Checkstyle, JaCoCo), exclusiones de c√≥digo generado, y ajustes de cobertura m√≠nima
- ai/generations/: Opcionalmente guarda archivos de configuraci√≥n generados (checkstyle.xml, exclude.xml de SpotBugs) si hubo cambios significativos


PASO 15 ‚Äì Docker y docker-compose
---------------------------------
Prompt:

Crea un Dockerfile multi-stage para Gradle + Java 21:

- Stage builder: eclipse-temurin:21-jdk-alpine
  - Copia archivos de configuraci√≥n (gradle/, gradlew, build.gradle, settings.gradle)
  - Copia c√≥digo fuente (src/, openapi/, config/)
  - Da permisos de ejecuci√≥n a gradlew (chmod +x gradlew)
  - Compila con ./gradlew clean build -x test --no-daemon
  - Verifica que se gener√≥ el JAR con ls -la build/libs/

- Stage runtime: eclipse-temurin:21-jre-alpine
  - Instala wget para health checks (apk add --no-cache wget)
  - Crea usuario no-root para seguridad (addgroup/adduser spring)
  - Copia el JAR desde builder: payment-initiation-service-0.0.1-SNAPSHOT.jar ‚Üí app.jar
  - Usa usuario no-root (USER spring:spring)
  - Expone puerto 8080 (EXPOSE 8080)
  - Configura HEALTHCHECK usando /actuator/health
  - ENTRYPOINT: java -jar app.jar

Crea docker-compose.yml con un servicio payment-initiation-service que:

- build: context: ., dockerfile: Dockerfile
- container_name: payment-initiation-service
- ports: "8080:8080"
- environment:
  - SPRING_PROFILES_ACTIVE=docker
  - JAVA_OPTS=-Xmx512m -Xms256m
- healthcheck: usando wget con /actuator/health
- restart: unless-stopped
- networks: payment-network (bridge)

‚ö†Ô∏è IMPORTANTE: Crea .dockerignore para excluir:
- build/, .gradle/, out/
- .idea/, .vscode/, *.iml
- .git/
- Dockerfile, docker-compose.yml
- **/test-results/, **/reports/
- ai/ (documentaci√≥n, no necesario en runtime)

No necesitas otro contenedor de DB porque H2 es embebido.

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y los archivos Docker generados
- ai/decisions.md: Documenta decisiones sobre Dockerfile multi-stage, docker-compose.yml, y .dockerignore
- ai/generations/: Opcionalmente guarda Dockerfile y docker-compose.yml iniciales si hubo cambios significativos


PASO 16 ‚Äì README y documentaci√≥n de IA
--------------------------------------
Prompt:

Crea README.md con:

1) Descripci√≥n del proyecto (BIAN Payment Initiation / PaymentOrder, migraci√≥n de SOAP a REST).
2) Arquitectura hexagonal y estructura de paquetes.
3) Stack t√©cnico (Java 21, Spring Boot 3, H2, JPA, Gradle, MapStruct, OpenAPI, WebTestClient, JaCoCo, Checkstyle, SpotBugs, Docker).
4) C√≥mo ejecutar:
   - ./gradlew clean check
   - ./gradlew bootRun
   - docker compose up --build
5) C√≥mo probar con Postman (referencia a postman_collection.json).
6) Uso de IA (descripci√≥n de carpeta ai/, qu√© se ha documentado).

üìù DOCUMENTACI√ìN IA: Despu√©s de completar este paso, documenta en:
- ai/prompts.md: Registra el prompt usado y el README generado
- ai/decisions.md: Opcionalmente documenta decisiones finales sobre la estructura del README
- Verifica que toda la documentaci√≥n en ai/ est√° completa y actualizada


======================================================
SECCI√ìN B ‚Äì CURSOR RULES PARA EL PROYECTO (JAVA 21)
======================================================

# BIAN Payment Initiation ‚Äì Java 21 Spring Boot Migration Rules

## 1. Context

You are an expert software architect specialized in banking systems with 10+ years in fintech, migrating legacy SOAP services to REST APIs aligned with BIAN standards.

This project migrates a Payment Order SOAP service (PaymentOrderService.wsdl + XML samples) to a BIAN-compliant REST microservice, validated with the Postman collection (postman_collection.json).

## 2. Project Specifications

- BIAN Service Domain: Payment Initiation
- Behavior Qualifier: PaymentOrder
- Migration: SOAP (legacy) ‚Üí REST (BIAN-aligned)
- Architecture: Hexagonal (Ports & Adapters)
- Approach: Contract-First using OpenAPI 3.0
- Stack:
  - Java 21
  - Spring Boot 3 (Spring MVC, no reactive stack at runtime)
  - H2 Database (in-memory for local/testing, optional file-based for Docker)
  - Gradle (Groovy DSL)
  - MapStruct
  - WebTestClient for integration tests
  - JaCoCo, Checkstyle, SpotBugs for quality gates

Always keep domain code framework-agnostic and respect BIAN naming conventions.

## 3. BIAN Alignment

- Base path: /payment-initiation
- Behavior Qualifier: PaymentOrder
- Resource naming:
  - PaymentOrder instance is the Control Record (CR).
  - Use paymentOrderReference as the business identifier (similar to cr-reference-id).
- Operations:
  - Initiate ‚Üí POST /payment-initiation/payment-orders
  - Retrieve ‚Üí GET  /payment-initiation/payment-orders/{id}
  - Retrieve Status ‚Üí GET /payment-initiation/payment-orders/{id}/status

Map SOAP operations from PaymentOrderService.wsdl (SubmitPaymentOrder, GetPaymentOrderStatus, etc.) to these REST operations.

## 4. API Design

### Endpoint Structure

- POST /payment-initiation/payment-orders
- GET  /payment-initiation/payment-orders/{id}
- GET  /payment-initiation/payment-orders/{id}/status

### Request/Response Shapes

Align the request body with the Postman collection and BIAN concepts, for example:

InitiatePaymentOrderRequest:
- externalReference
- debtorAccount { iban }
- creditorAccount { iban }
- instructedAmount { amount, currency }
- remittanceInformation
- requestedExecutionDate

Responses must include:
- paymentOrderReference
- paymentOrderStatus
- payer/debtor and payee/creditor references or accounts
- amount (value + currency)
- timestamps (createdAt, updatedAt/lastUpdated)

### HTTP Status Codes

- 201 Created: successful POST initiate.
- 200 OK: successful GET retrieve / status.
- 400 Bad Request: validation errors, malformed requests.
- 404 Not Found: missing payment order.
- 500 Internal Server Error: unexpected errors.

Produce errors in application/problem+json (RFC 7807) using Spring‚Äôs ProblemDetail.

## 5. Hexagonal Architecture

### Root package

- com.bank.paymentinitiation

### Package structure

- com.bank.paymentinitiation.domain
  - model        (PaymentOrder, PaymentAmount, PaymentStatus, value objects)
  - port.in      (use case interfaces)
  - port.out     (repository interfaces, external ports)
  - exception    (domain exceptions)
  - service      (domain-level services if needed)
- com.bank.paymentinitiation.application
  - service      (use case implementations)
  - mapper       (optional)
- com.bank.paymentinitiation.adapter.in.rest
  - PaymentInitiationController (implements generated OpenAPI interfaces)
  - mapper (MapStruct DTO ‚Üî domain)
- com.bank.paymentinitiation.adapter.out.persistence
  - entity       (JPA entities for H2)
  - jpa          (Spring Data JPA repositories)
  - mapper       (MapStruct domain ‚Üî entity)
  - PaymentOrderRepositoryAdapter (implements domain port)
- com.bank.paymentinitiation.config
  - WebMvc, JPA, H2 console, security (if any)

Rules:
- Domain layer is pure Java, no Spring annotations.
- Ports live in domain; adapters implement ports.
- MapStruct only in adapter/application, never in domain.

## 6. Contract-First OpenAPI

- Source of truth: openapi/openapi.yaml.
- Use org.openapi.generator Gradle plugin with generatorName "spring" and interfaceOnly = true.
- Generated packages:
  - com.bank.paymentinitiation.generated.api
  - com.bank.paymentinitiation.generated.model
- Controllers in adapter.in.rest must implement these generated interfaces, not define their own method signatures manually.

OpenAPI must be consistent with:
- WSDL and XML samples for fields and states.
- Postman collection for endpoints and example payloads.

## 7. Gradle Build (Java 21)

Key points:
- sourceCompatibility = JavaVersion.VERSION_21
- targetCompatibility = JavaVersion.VERSION_21
- Use spring-boot-starter-web (MVC), spring-boot-starter-data-jpa, spring-boot-starter-validation, spring-boot-starter-actuator.
- runtimeOnly com.h2database:h2
- WebTestClient is allowed via testImplementation "org.springframework:spring-webflux" (tests only).

‚ö†Ô∏è IMPORTANTE - Dependencias para c√≥digo generado:
- Add dependencies required by OpenAPI Generator:
  - implementation "io.swagger.core.v3:swagger-annotations:2.2.21"
  - implementation "org.openapitools:jackson-databind-nullable:0.2.6"
  - implementation "jakarta.validation:jakarta.validation-api:3.0.2"
  - implementation "jakarta.annotation:jakarta.annotation-api:2.1.1"

Quality gates:
- JaCoCo with minimum 75% line coverage on main code (realistic target, can be increased to 80% with more tests).
  Exclusions:
  - **/generated/** (OpenAPI generated code)
  - PaymentOrderEntity and inner classes
  - *MapperImpl.class (MapStruct implementations)
  - PaymentInitiationServiceApplication (main class)
  - config/** (configuration classes)
  
- Checkstyle:
  - Config file: config/checkstyle/checkstyle.xml
  - maxWarnings: 10 (allows some warnings)
  - Exclude generated code using BeforeExecutionExclusionFileFilter in checkstyle.xml
  - Patterns: "generated/.*" and ".*MapperImpl\.java$"
  
- SpotBugs:
  ‚ö†Ô∏è CRITICAL: Do NOT configure effort and reportLevel as strings in spotbugs {} block.
  Use tasks.named('spotbugsMain') with:
  - effort = com.github.spotbugs.snom.Effort.valueOf('MAX')
  - reportLevel = com.github.spotbugs.snom.Confidence.valueOf('HIGH')
  - excludeFilter pointing to config/spotbugs/exclude.xml
  - Report level: HIGH (only report high-confidence issues)

The Gradle check task must run unit tests, integration tests, coverage verification, Checkstyle and SpotBugs.
‚ö†Ô∏è NOTE: Configure check task dependencies carefully to avoid circular dependencies:
- jacocoTestReport depends on test, so use finalizedBy instead of dependsOn

## 8. Spring Configuration (H2 + MVC)

- Use application.yml to configure H2 in-memory for local/dev.
- Enable H2 console at /h2-console for debugging.
- Set JPA ddl-auto to update or create-drop for tests.
- Configure Jackson to use ISO date/time, no timestamps.

Ensure the application runs on port 8080 and matches the URLs in the Postman collection.

## 9. Controller Rules (Spring MVC)

PaymentOrdersController MUST:

- Implement the interface generated from OpenAPI (e.g. PaymentOrdersApi - check generated.api package).
- Use @RestController, @RequiredArgsConstructor, @Slf4j.
- Inject:
  - Use cases (Initiate/Retrieve/Status)
  - PaymentOrderRestMapper
  - PaymentOrderReferenceGenerator (for generating unique references)

HTTP behavior:

- POST initiatePaymentOrder:
  - Validate request with @Valid.
  - Generate paymentOrderReference using PaymentOrderReferenceGenerator.generate().
  - Map DTO ‚Üí domain using mapper.toDomain(request, paymentOrderReference).
  - Call InitiatePaymentOrderUseCase.
  - Map domain ‚Üí InitiatePaymentOrderResponse.
  - Return ResponseEntity.status(HttpStatus.CREATED).body(response).

- GET retrievePaymentOrder:
  - Call RetrievePaymentOrderUseCase with id (paymentOrderReference).
  - Map domain ‚Üí RetrievePaymentOrderResponse.
  - Return ResponseEntity.ok(body).

- GET retrievePaymentOrderStatus:
  - Call RetrievePaymentOrderUseCase (needs full order for mapping to response).
  - Map domain ‚Üí PaymentOrderStatusResponse.
  - Return ResponseEntity.ok(body).

Never expose domain entities or JPA entities directly in REST responses. Always go through DTOs generated from OpenAPI + MapStruct mappers.

## 10. Error Handling (RFC 7807)

Implement GlobalExceptionHandler with @RestControllerAdvice that:

- Maps PaymentOrderNotFoundException ‚Üí 404 NOT FOUND with ProblemDetail:
  - title = "Payment Order Not Found"
  - status = 404
  - detail = useful error message

- Maps InvalidPaymentException ‚Üí 400 BAD REQUEST with ProblemDetail:
  - title = "Invalid Payment Order"
  - status = 400
  - detail = validation/business error description

- Maps generic Exception ‚Üí 500 Internal Server Error with ProblemDetail.

All error responses must use application/problem+json and avoid exposing internal details (stack traces, SQL, etc.).

## 11. Persistence Layer Rules (H2 + JPA)

- Use H2 for persistence in local and tests.
- Define PaymentOrderEntity with UUID primary key and paymentOrderReference as unique column.
- Spring Data JPA repository with method findByPaymentOrderReference.
- PaymentOrderRepositoryAdapter implementing domain port PaymentOrderRepository, using MapStruct PaymentOrderPersistenceMapper to convert between domain and entity.

Domain layer must not depend on JPA or persistence annotations.

## 12. MapStruct Usage

Define three main mapper types:

1. REST mapper (adapter.in.rest.mapper):
   - DTO ‚Üî Domain.
   - Responsible for translating REST-level semantics (BIAN JSON) into domain objects and vice versa.
   - Method signature: `toDomain(InitiatePaymentOrderRequest request, String paymentOrderReference)`
     - The paymentOrderReference is generated in the controller and passed as parameter.

2. Persistence mapper (adapter.out.persistence.mapper):
   - Domain ‚Üî Entity.
   - Responsible for mapping business objects to relational persistence structures.
   - For toDomain(PaymentOrderEntity), use PaymentOrder.create() factory method and changeStatus() 
     if the entity status is different from INITIATED.

3. Optional application-level mapper (application.mapper):
   - For complex transformations inside use cases if needed.

All mappers:
- Use @Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.ERROR).
- Keep mapping logic declarative; avoid custom imperative logic in mappers unless absolutely required.

‚ö†Ô∏è IMPORTANTE - Evitar ambig√ºedades de tipos:
- Use fully qualified names for types with same name in different packages:
  - `com.bank.paymentinitiation.domain.model.PaymentAmount` vs `com.bank.paymentinitiation.generated.model.PaymentAmount`
  - `com.bank.paymentinitiation.domain.model.PaymentStatus` vs `com.bank.paymentinitiation.generated.model.PaymentStatus`
- For timestamp conversions (LocalDateTime ‚Üî OffsetDateTime), add @Named methods:
  ```java
  @Named("localDateTimeToOffsetDateTime")
  default OffsetDateTime localDateTimeToOffsetDateTime(LocalDateTime localDateTime) {
      return localDateTime != null ? localDateTime.atOffset(ZoneOffset.UTC) : null;
  }
  ```

## 13. Testing Strategy

### Unit Tests

- Domain:
  - Cover PaymentOrder aggregate behavior, value objects, status transitions and invariants.
- Application:
  - Use cases with mocked PaymentOrderRepository.
  - Verify business rules and error handling.

### Integration Tests (WebTestClient + Spring MVC)

- Use @SpringBootTest(webEnvironment = RANDOM_PORT) + @AutoConfigureWebTestClient.
- Use real H2 configuration.
- Cover:
  - POST /payment-initiation/payment-orders ‚Üí 201 Created with correct body.
  - GET /payment-initiation/payment-orders/{id} ‚Üí 200 OK.
  - GET /payment-initiation/payment-orders/{id}/status ‚Üí 200 OK.
  - Error cases 404 and 400.

Align test requests/responses with the Postman collection examples.

### Repository Tests

- Use @DataJpaTest for PaymentOrderJpaRepository and verify basic CRUD + custom queries (findByPaymentOrderReference).

## 14. Docker & Runtime Rules

- Use multi-stage Dockerfile with Java 21 (Temurin JDK/JRE):
  - Stage 1 (builder): eclipse-temurin:21-jdk-alpine
    - Copy Gradle files, source code (src/, openapi/, config/)
    - Run `./gradlew clean build -x test --no-daemon`
    - Verify JAR generation
  - Stage 2 (runtime): eclipse-temurin:21-jre-alpine
    - Install wget for health checks
    - Create non-root user (spring:spring)
    - Copy JAR from builder (rename to app.jar)
    - Set USER spring:spring
    - Expose port 8080
    - HEALTHCHECK using /actuator/health
    - ENTRYPOINT: java -jar app.jar

- Create .dockerignore to exclude:
  - build/, .gradle/, out/
  - .idea/, .vscode/, *.iml
  - .git/, Dockerfile, docker-compose.yml
  - test-results/, reports/, ai/

- docker-compose.yml:
  - Build context: current directory
  - Ports: "8080:8080"
  - Environment: SPRING_PROFILES_ACTIVE=docker, JAVA_OPTS
  - Healthcheck configuration
  - Restart policy: unless-stopped
  - Network: dedicated bridge network

- Ensure the container runs the Spring Boot jar listening on port 8080.
- Health check uses /actuator/health endpoint.
- In Docker profile, you may use H2 in file mode if persistence across restarts is needed.

## 15. AI Usage Documentation (ai/ folder)

For every significant use of AI (Cursor/ChatGPT):

- Log the prompt and a short summary of the answer in ai/prompts.md.
- Document architectural decisions, manual corrections, and final choices in ai/decisions.md.
- Store key generated fragments (for example initial openapi.yaml or first controller draft) in ai/generations/, with a short comment in the header explaining what was kept and what was changed.

All AI-generated code MUST be reviewed, adapted and tested before being considered production-ready.

## 16. Final Checklist

Before considering the challenge DONE, verify:

‚úÖ **OpenAPI Contract:**
- OpenAPI contract is the source of truth and matches Postman and WSDL semantics.
- All paths are correctly defined (POST /payment-initiation/payment-orders, GET /payment-initiation/payment-orders/{id}, GET /payment-initiation/payment-orders/{id}/status).
- Schemas match Postman collection examples.

‚úÖ **Architecture:**
- Hexagonal architecture is respected, with no Spring/framework dependencies in domain.
- Domain models are pure Java (no annotations from Spring/JPA).
- Ports and adapters are correctly separated.

‚úÖ **REST API:**
- All REST endpoints return correct HTTP status codes (201, 200, 400, 404, 500).
- Error responses follow RFC 7807 and use application/problem+json.
- PaymentOrderReferenceGenerator generates unique references correctly.

‚úÖ **Mappers:**
- MapStruct mappers work correctly and are covered by tests where necessary.
- No ambiguity errors between domain and generated types.
- Timestamp conversions (LocalDateTime ‚Üî OffsetDateTime) work correctly.

‚úÖ **Persistence:**
- PaymentOrderRepositoryAdapter fully implements domain port.
- JPA entity correctly maps to domain model.
- H2 is configured and accessible; H2 console works in dev.

‚úÖ **Testing:**
- Unit tests for domain models (PaymentOrder, PaymentAmount, value objects).
- Unit tests for application services (with mocked repository).
- Integration tests with WebTestClient cover all endpoints.
- All tests pass on Java 21.

‚úÖ **Quality Gates:**
- ./gradlew clean check passes:
  - JaCoCo coverage >= 75% (realistic target)
  - Checkstyle (maxWarnings: 10, excludes generated code)
  - SpotBugs (HIGH confidence, excludes generated code)
  - All tests pass

‚úÖ **Configuration:**
- ApplicationConfig defines beans for application services.
- PaymentOrderReferenceGenerator is configured as @Component.
- All dependencies are correctly injected.

‚úÖ **Docker:**
- Dockerfile multi-stage builds successfully.
- Docker image runs and service starts correctly on port 8080.
- Health check works via /actuator/health.
- docker-compose.yml works correctly.

‚úÖ **Documentation:**
- AI usage is documented in ai/prompts.md and ai/decisions.md.
- Key generated fragments stored in ai/generations/.
- README.md explains setup, architecture, how to run, and how to test via Postman collection.

If any of these checks fail, fix them before delivering the solution.

---

## 17. Lecciones Aprendidas y Mejoras para Futuros Proyectos

### Problemas Comunes y Soluciones

1. **Ambiguidad de Tipos en MapStruct:**
   - Problema: PaymentAmount y PaymentStatus existen en dominio y generated.model.
   - Soluci√≥n: Usar nombres completamente calificados en mappers.

2. **SpotBugs Configuration:**
   - Problema: effort y reportLevel no aceptan strings en plugin 6.0.0+.
   - Soluci√≥n: Configurar por tarea usando Effort.valueOf() y Confidence.valueOf().

3. **Cobertura de C√≥digo:**
   - Problema: 80% es dif√≠cil de alcanzar inicialmente.
   - Soluci√≥n: Comenzar con 75% y aumentar gradualmente.

4. **Checkstyle y C√≥digo Generado:**
   - Problema: Checkstyle falla en c√≥digo generado por OpenAPI.
   - Soluci√≥n: Excluir usando BeforeExecutionExclusionFileFilter en checkstyle.xml.

5. **Generaci√≥n de paymentOrderReference:**
   - Problema: El mapper necesita la referencia pero no debe generarla.
   - Soluci√≥n: Generar en el controlador y pasar como par√°metro al mapper.

6. **Dependencias Circulares en task check:**
   - Problema: jacocoTestReport depende de test que est√° en check.
   - Soluci√≥n: Usar finalizedBy en lugar de dependsOn para jacocoTestReport.

7. **Conversi√≥n de Timestamps en MapStruct:**
   - Problema: DTOs OpenAPI usan OffsetDateTime pero dominio usa LocalDateTime.
   - Soluci√≥n: Agregar m√©todos @Named para convertir LocalDateTime ‚Üí OffsetDateTime en mappers REST.

8. **Generador de paymentOrderReference:**
   - Problema: Se necesita generar ID √∫nico pero el mapper no debe tener esta responsabilidad.
   - Soluci√≥n: Crear PaymentOrderReferenceGenerator como componente Spring separado.

9. **ApplicationConfig para Beans:**
   - Problema: Servicios de aplicaci√≥n necesitan configuraci√≥n expl√≠cita para inyecci√≥n de dependencias.
   - Soluci√≥n: Crear ApplicationConfig con @Configuration y definir beans manualmente.

10. **Controlador retrievePaymentOrderStatus:**
    - Problema: RetrievePaymentOrderStatusUseCase retorna solo PaymentStatus pero response necesita paymentOrderReference y lastUpdated.
    - Soluci√≥n: Usar RetrievePaymentOrderUseCase en el controlador para obtener orden completa.

---

## 18. Resumen de Archivos Clave del Proyecto

### Archivos de Configuraci√≥n
- `build.gradle`: Configuraci√≥n Gradle con plugins, dependencias y quality gates
- `settings.gradle`: Nombre del proyecto
- `application.yml`: Configuraci√≥n Spring Boot (H2, JPA, logging)
- `config/checkstyle/checkstyle.xml`: Reglas Checkstyle con exclusiones
- `config/spotbugs/exclude.xml`: Filtros de exclusi√≥n para SpotBugs

### Archivos de Contrato
- `openapi/openapi.yaml`: Contrato OpenAPI 3.0 (source of truth)
- `postman_collection.json`: Colecci√≥n Postman para testing

### Archivos Docker
- `Dockerfile`: Multi-stage build para Java 21
- `docker-compose.yml`: Orquestaci√≥n del servicio
- `.dockerignore`: Exclusiones para contexto de build

### Archivos de Documentaci√≥n
- `README.md`: Documentaci√≥n completa del proyecto
- `ai/prompts.md`: Lista de prompts usados con IA
- `ai/decisions.md`: Decisiones arquitect√≥nicas y correcciones
- `ai/generations/`: Fragmentos generados por IA

---

## 19. Checklist de Verificaci√≥n Final

Antes de considerar el proyecto completo, ejecuta estos comandos y verifica que todos pasan:

```bash
# 1. Verificar compilaci√≥n
./gradlew clean build -x test

# 2. Ejecutar todos los tests
./gradlew test

# 3. Ejecutar quality gates
./gradlew check

# 4. Verificar reportes
# - Tests: build/reports/tests/test/index.html
# - JaCoCo: build/reports/jacoco/html/index.html
# - Checkstyle: build/reports/checkstyle/main.html
# - SpotBugs: build/reports/spotbugs/main.html

# 5. Ejecutar aplicaci√≥n localmente
./gradlew bootRun
# Verificar: http://localhost:8080/actuator/health

# 6. Construir y ejecutar Docker
docker-compose up --build
# Verificar: http://localhost:8080/actuator/health
```

---

¬°√âxito con la implementaci√≥n del challenge!
